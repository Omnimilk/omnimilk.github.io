<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-24T15:20:27.779Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Huawei Summary 1: Mindspore</title>
    <link href="http://yoursite.com/2021/06/24/Huawei-Summary-1-Mindspore/"/>
    <id>http://yoursite.com/2021/06/24/Huawei-Summary-1-Mindspore/</id>
    <published>2021-06-24T14:05:45.000Z</published>
    <updated>2021-06-24T15:20:27.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作总结1-：-Mindspore"><a href="#工作总结1-：-Mindspore" class="headerlink" title="工作总结1 ： Mindspore"></a>工作总结1 ： Mindspore</h1><p>EAI的工作交付完成后有一段时间空闲期，没有实际的活儿，和浩哥一起学了一些程序分析相关的东西。浩哥技术不错，也乐于组织一些技术分享，经常带着我们一群编译器小白讲解概念和“结对编程”（其实是边写代码边给我们将思路）。这期间最大的收获就是学了一些source 2 source转换和ANTLR的一些知识。记得当时准备一个链接器专利需要自动改写linker script，于是准备用ANTLR做source 2 source的转换，但是当时能找到的只有一个ANTLR2 语法的linker script语法文件，为了让ANTLR4的运行时能正确解析，还套娃去找了一个将ANTLR2语法文件转换成ANTLR4语法文件的工具hhh。</p><h2 id="TIK算子实现"><a href="#TIK算子实现" class="headerlink" title="TIK算子实现"></a>TIK算子实现</h2><p>空闲的状态没有持续太久，我们组就打包卖给海思图灵去写vector core和scalar core的算子。我当时主要是负责vector core算子的编写，vector core开发用的是<strong>TIK</strong>(Tensor Iterator Kernel), 是一个Python开发框架，框架会将我们写的TIK代码转换为CCE-C代码，然后用CCE-C的编译器编译出device侧的二进制。开发流程十分传统厚重，感受了一把<strong>原汁原味</strong>的瀑布式开发流程，每个算子实现都要写概要设计文档、详细设计文档，然后设计文档也有集体检视，文档检视还有缺陷率的要求（&gt;5%）。</p><p>负责实现的第一个算子是<strong>SGBM</strong>，用于作双目视差计算的，最高需要支持1080p的灰度图作为输入。这个算法比较复杂，主要分为4个步骤：</p><ol><li>预处理：水平Sobel算子处理后得到图像的梯度信息</li><li>代价计算：原图像SAD代价+梯度图中的梯度代价</li><li><strong>动态规划</strong>：代价由左上角向右下角传播，OpenCV默认使用四条传播路径</li><li>后处理：唯一性检测、亚像素插值、左右一致性检测etc</li></ol><p>算法根据上面步骤分给了三个人做，我主要负责<strong>动态规划</strong>部分的实现。动态规划计算时，每个像素依赖当前行和上一行中的像素，但是无法一次容纳最大size的两行像素。因此我们需要同时对行和列进行tiling切分，每次处理两行x64个像素,先从左向右传播，后从上向下传播。这样的tiling切分会导致host到device的数据搬运和后续处理的<strong>流水线效率不高</strong>，最后算法整体测试时结果也验证了这一点。但这是算法特性（下一行依赖上一行）决定的，最后算法要不要异构下放到vector core这个需求又回去重新评估了。。</p><p>后面又负责了<strong>WarpAffine</strong>和<strong>WarpPerspective</strong>两个算子的实现，这两个算子数学公式看起来都很简单，只是简单的<em>双线性内插值</em>。但是<a href="https://github.com/opencv/opencv/blob/master/modules/imgproc/src/imgwarp.hpp" target="_blank" rel="noopener">OpenCV的实现</a>却用了3000行+，其中用到了很多巧妙的优化小技巧，例如对小方格进行量化切分成NxN的小格，每个格子中直接存放了周围四个像素点的权重。这两个算法分析好优化方案之后就无甚可书了，tiling按照行搬入即可，写到最后我的代码补全工具比我还要懂TIK，写几个字母能直接补全一两行。</p><h2 id="ME开发"><a href="#ME开发" class="headerlink" title="ME开发"></a>ME开发</h2><p>ME(Mindspore前端)的主要工作之前已经汇总过了，可以看<a href="https://omnimilk.github.io/2020/08/09/Python-Pass/" target="_blank" rel="noopener">这篇</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作总结1-：-Mindspore&quot;&gt;&lt;a href=&quot;#工作总结1-：-Mindspore&quot; class=&quot;headerlink&quot; title=&quot;工作总结1 ： Mindspore&quot;&gt;&lt;/a&gt;工作总结1 ： Mindspore&lt;/h1&gt;&lt;p&gt;EAI的工作交付完成</summary>
      
    
    
    
    
    <category term="Work" scheme="http://yoursite.com/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>Huawei Summary 0: EAI</title>
    <link href="http://yoursite.com/2021/06/23/Huawei-Summary-0-EAI/"/>
    <id>http://yoursite.com/2021/06/23/Huawei-Summary-0-EAI/</id>
    <published>2021-06-23T07:39:35.000Z</published>
    <updated>2021-06-24T13:56:10.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作总结0：-EAI框架"><a href="#工作总结0：-EAI框架" class="headerlink" title="工作总结0： EAI框架"></a>工作总结0： EAI框架</h1><p> 趁着这段时间有空，将在公司的经历记录一下，一者是趁着还有印象留个纪念，二者是为这段时间和以后的面试理理思绪。</p><p><strong>EAI框架</strong>是进公司的第一个项目，内容的话是实现一个包含<strong>经典机器学习推理算法</strong>+<strong>科学计算</strong>的纯C(Cython也算上)的框架，几个刚进公司连C都没怎么写过的小年轻硬莽出来的。经典机器学习算法的话主要是包含<em>KNN</em>、<em>谱聚类</em>、<em>SVD</em>、<em>Ensemble Learning</em>这些算法，目标是对比<strong>scikit-learn</strong>等python库在公司Arm平台实现5x+的加速（全靠对手衬托…）； 科学计算的部分的话，主要是一些<strong>numpy</strong>格式矩阵的转置等操作、各种插值算法，最离谱也是我印象最深的是对glibc里<em>log10</em>函数的加速哈哈。</p><h2 id="Ensemble-Learning"><a href="#Ensemble-Learning" class="headerlink" title="Ensemble Learning"></a>Ensemble Learning</h2><p>这里ensemble learning算法的弱模型都是基于决策树的，更具体的来说包含：<em>random forest</em>，<em>isolated forest</em>，<em>AdaBoost</em>, <a href="https://www.cnblogs.com/42-Curry/p/9801599.html" target="_blank" rel="noopener"><em>GBDT</em></a>。<strong>scikit-learn</strong>里这些算法的决策树最后都是调用到<a href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/tree/_tree.pyx" target="_blank" rel="noopener">Cython的实现</a>，所以其实基准性能也不算太差。</p><p>上面提到的几种算法在训练的时候各有不同，但在推理的时候极其相似：都是把数据（feature vector）喂给决策树，得到一个值（回归值、深度等）；然后将每个决策树得到的值以某种方式组合起来（平均值、加权平均等），得到最终的值。</p><p>每棵树的推理过程都可以理解成下面过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">TreeInfer</span><span class="params">(<span class="keyword">float</span>* x, Node* nodes)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">   idx = nodes-&gt;children[x[nodes[idx].fIdx] &gt; nodes[idx].threshold];</span><br><span class="line">   idx = nodes-&gt;children[x[nodes[idx].fIdx] &gt; nodes[idx].threshold];</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> nodes[idx].score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推理的过程非常简单，算法层面的优化不大，优化主要是从访存和并行两方面入手。</p><h3 id="访存优化：Quick-Scorer算法"><a href="#访存优化：Quick-Scorer算法" class="headerlink" title="访存优化：Quick Scorer算法"></a>访存优化：Quick Scorer算法</h3><p>上面naive实现的代码中容易看到，每个决策树推理的过程中，下一个节点的位置依赖于模型中的阈值和输入的数据，无法提前预知。因此，上面的实现容易造成大量的cache miss，访存局部性较差。</p><p>为了解决上面的访存问题，<a href="https://www.slideshare.net/raffaeleperego/quickscorer-a-fast-algorithm-to-rank-documents-with-additive-ensembles-of-regression-trees" target="_blank" rel="noopener">Quick Scorer</a>（<a href="https://www.cse.cuhk.edu.hk/irwin.king/_media/presentations/sigir15bestpaper.pdf" target="_blank" rel="noopener">paper</a>）算法通过对模型中阈值按feature分组，每个组内的阈值预先排序，然后使用一些巧妙的bit representation实现了顺序访问也能找到输入feature vector在每棵决策树中对应的叶子节点。</p><p>具体做法如下：</p><p>对于一个输入feature vector和一棵选定的决策树，树中的<strong>内部节点</strong>（inner nodes）可以根据它们所包含的feature threshold <strong>T</strong>与feature value <strong>V</strong>的大小关系划分为两组：<strong>True Nodes</strong>和<strong>False Nodes</strong>。如下图所示，<strong>True Nodes</strong>表示 <strong>V</strong> &lt; <strong>T</strong>的节点，<strong>False Nodes</strong>表示<strong>V</strong> &gt;= <strong>T</strong>的节点。</p><p><img src="/images/true_nodes_false_nodes.jpg" alt="TFNodes"></p><p><strong>推论0</strong>：<strong>True Nodes</strong>只有右子树中的节点可能被访问到（candidates）; <strong>False Nodes</strong>只有左子树中的节点可能被访问到。</p><p><strong>推论1</strong>： <strong>True Nodes</strong>的左子树不可能被访问到，可以安全的被排除出candidates；<strong>False Nodes</strong>可以安全的排除右子树</p><p>作者利用<strong>推论1</strong>设计了一种内部节点的bit representation（见下图）：每个内部节点有一个长为叶子节点个树的bitvector，从左到右每个bit对应从左到右每个叶子节点，不可能访问到的标记为0，可能访问到的标记为1（candidates，<strong>NOTE</strong>：不属于当前节点左右子树的节点也是candidates）。</p><p><img src="/images/qs_bitvector.jpg" alt="TFNodes"></p><p>如上图所示，我们在所有<strong>False Nodes</strong>的candidates中<strong>取交集</strong>（bit and operation），<strong>从左往右第一个candidate</strong>便是我们要找的叶子节点。</p><p>Why? 目标节点在交集中显而易见，那么为什么是从左往右第一个呢？</p><p>分两种情况讨论，</p><ol><li>结果的bit vector中没有0，那么显而易见就是决策通路上全是<strong>True Nodes</strong>，也就是走到了第1个叶子节点，满足我们的结论。</li><li>结果的bit vector中有0，那么从左往右第一个<strong>False Node</strong>必然在决策通路中（更左的<strong>False Node</strong>如果存在会导致第一个1左移），对此节点也作两种情况讨论：<ol><li>此节点右子树直接连接叶子节点，显然满足我们的结论。</li><li>此节点右子树不直接连接叶子节点，则后续决策通路全为<strong>True Nodes</strong>（如果直接连接的右子节点为<strong>False Node</strong>, 则按上面的求并集的过程，第一个0会右边移动，所以直接右子节点为<strong>True Node</strong>, and so on and so forth）, 也就是说决策通路通往的就是此节点的第一个candidate，满足我们的结论。</li></ol></li></ol><p>Q.E.D.</p><p>如此，以任意顺序访问节点来进行推理成为了可能。那么，如何快速得到所有<strong>False Nodes</strong>呢？答案就是上文提到的，对模型中的阈值，按照feature分组并在推理前做好<strong>排序</strong>即可。优化后推理流程中，模型的主要数据结构的访问都由原来的随机访存，变为了线性或者稀疏线性，访存性能得到了一定程度的提升。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>框架推理接口同时提供C接口和Cython暴露出来的python接口，接口中输入为多个样本，我们选择了进行数据并行多线程加速。值得注意的时，Python中让人头疼的GIL，在调用C实现时可以比较容易的绕过。</p><h3 id="模型序列化和反序列化"><a href="#模型序列化和反序列化" class="headerlink" title="模型序列化和反序列化"></a>模型序列化和反序列化</h3><p>一开始这个工具只是为了个人开发测试用，于是快速手橹了几个python脚本，把模型序列化成json格式，反序列化则是从头手写的json解析器。后面得知这玩意儿要作为交付件交付，无知者无畏就这么交付了，但凡有一个大哥带，也不会不用上protobuf-c啥的。。</p><h2 id="插值算法：-二次插值，样条插值"><a href="#插值算法：-二次插值，样条插值" class="headerlink" title="插值算法： 二次插值，样条插值"></a>插值算法： 二次插值，样条插值</h2><p>二次插值比较简单，<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html#scipy.interpolate.CubicSpline" target="_blank" rel="noopener">三次样条插值</a>需要自己解线性方程组，问题规模不是很大，只是实现了简单的高斯消元求解。然后印象比较深刻的就是，三次样条插值的边界条件默认设置是”not-a-knot”,  这只指定了一个方程，要使方程有唯一解还需要一个额外的边界条件，找遍了scipy的源码也没找到怎么设置的，最后是试错才找到的。。</p><h2 id="log10加速"><a href="#log10加速" class="headerlink" title="log10加速"></a>log10加速</h2><p>这个需求是某业务部门profiling之后发现的性能瓶颈之一，计算log10竟然占到了所有计算时间的超过10%。log10作为glibc数学库中的一部分，自然本身的实现也是不差的，优化谈何容易，但是好在互联网上有各色好心人分享自己的智慧。一番搜寻之后，找到了一个ebay的工程师写的<a href="https://tech.ebayinc.com/engineering/fast-approximate-logarithms-part-i-the-basics/" target="_blank" rel="noopener">博客</a>，讲的是他优化log2实现的过程，里面涉及的知识面十分广。文中讲到的几个大点至今还有印象，IEEE 754浮点数的定义可以帮助我们快速用位操作计算log2；log2的计算有许多近似公式可以选择，选择近似公式既要考虑速度由要考虑公式在各种情况下的数值稳定性；选择好一个近似公式之后，公式中的各个参数如何通过凸优化求解。给大神递可乐orz</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>中间还穿插做了一个小工具，可以用于<strong>裁剪python库</strong>。这个裁剪工具根据粒度的不同分两部分，第一个部分是<strong>文件级的裁剪</strong>，根据应用的使用情况裁剪掉库中不需要的各种文件。原理比较简单，运行一个大佬用Go写的用户态文件系统，这个文件系统会统计每个文件的访问次数，裁剪脚本（python实现）以此作为判断是否需要的依据，删掉不需要的文件。另一个部分是<strong>函数级裁剪</strong>，一个文件中也会有许多用不到的函数，同样可以裁剪掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作总结0：-EAI框架&quot;&gt;&lt;a href=&quot;#工作总结0：-EAI框架&quot; class=&quot;headerlink&quot; title=&quot;工作总结0： EAI框架&quot;&gt;&lt;/a&gt;工作总结0： EAI框架&lt;/h1&gt;&lt;p&gt; 趁着这段时间有空，将在公司的经历记录一下，一者是趁着还有印</summary>
      
    
    
    
    
    <category term="Work" scheme="http://yoursite.com/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>dithering</title>
    <link href="http://yoursite.com/2021/05/06/dithering/"/>
    <id>http://yoursite.com/2021/05/06/dithering/</id>
    <published>2021-05-06T13:50:56.000Z</published>
    <updated>2021-06-24T13:56:59.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像平滑算法：-Dithering"><a href="#图像平滑算法：-Dithering" class="headerlink" title="图像平滑算法： Dithering"></a>图像平滑算法： Dithering</h1><p>看<a href="https://www.bilibili.com/video/BV1Cf4y1y7KT" target="_blank" rel="noopener">稚晖君的视频</a>用墨水屏显示图像的部分提到了这个算法，感觉很有意思。墨水屏或者黑白打印机只能显示二值的黑白像素，dithering算法能帮我们用黑白近似灰度图像。其实，更一般地，dithering算法可以用来<strong>平滑</strong>各种信号量化带来的误差。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>考虑将灰度图像（0为全黑，255为全白）<strong>量化</strong>为黑白图片，灰度值为42时我们如何量化呢？简单的做法是取灰度上的近邻，用0来表示灰度值为42的像素。对于量化产生的误差，如果直接忽略，最后生成的图像质量会很差，因此我们需要找到更好的<strong>处理量化误差</strong>的方式。</p><h3 id="error-diffusion"><a href="#error-diffusion" class="headerlink" title="error diffusion"></a>error diffusion</h3><p>error diffusion dithering算法以某种顺序处理像素，处理像素时的量化误差在迭代处理像素时扩散（diffusion）。例如：当前像素为42，量化为0的误差为42，假设下一个像素值为100，那么加上传递过来的误差等于142，此像素应该量化为1，此时误差变为142 - 255 = -113，继续向下一个像素传递，以此类推。</p><p><strong>缺点</strong>：原图中的色块会扩散为黑色的线。</p><p>上面线性的处理的一个意想（liao）不（zhi）到（zhong）的后果（artifacts）就是会导致生成图像中奇怪的条纹。核心的原因就是2D图像采用了1D的误差扩散方式。</p><h3 id="2D-error-diffusion-Floyd-Steinberg-Dithering"><a href="#2D-error-diffusion-Floyd-Steinberg-Dithering" class="headerlink" title="2D error-diffusion: Floyd-Steinberg Dithering"></a>2D error-diffusion: Floyd-Steinberg Dithering</h3><p>从左上角向右下角扩散，局部涉及的像素和系数表如下：</p><div class="table-container"><table><thead><tr><th></th><th>X</th><th>7/16</th></tr></thead><tbody><tr><td>3/16</td><td>5/16</td><td>1/16</td></tr></tbody></table></div><h3 id="2D-error-diffusion-Jarvis-Judice-and-Ninke-Dithering"><a href="#2D-error-diffusion-Jarvis-Judice-and-Ninke-Dithering" class="headerlink" title="2D error-diffusion: Jarvis, Judice, and Ninke Dithering"></a>2D error-diffusion: Jarvis, Judice, and Ninke Dithering</h3><p>同样是左上角向右下角扩散，设计的像素和系数表如下：</p><div class="table-container"><table><thead><tr><th></th><th></th><th>X</th><th>7/48</th><th>5/48</th></tr></thead><tbody><tr><td>3/48</td><td>5/48</td><td>7/48</td><td>5/48</td><td>3/48</td></tr><tr><td>1/48</td><td>3/48</td><td>5/48</td><td>3/48</td><td>1/48</td></tr></tbody></table></div><p>很多其他的扩散方式可以选择，but you get the idea.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图像平滑算法：-Dithering&quot;&gt;&lt;a href=&quot;#图像平滑算法：-Dithering&quot; class=&quot;headerlink&quot; title=&quot;图像平滑算法： Dithering&quot;&gt;&lt;/a&gt;图像平滑算法： Dithering&lt;/h1&gt;&lt;p&gt;看&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="signal processing" scheme="http://yoursite.com/tags/signal-processing/"/>
    
  </entry>
  
  <entry>
    <title>manimgl install</title>
    <link href="http://yoursite.com/2021/04/24/manimgl-install/"/>
    <id>http://yoursite.com/2021/04/24/manimgl-install/</id>
    <published>2021-04-24T13:59:33.000Z</published>
    <updated>2021-04-24T15:44:18.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="manimgl安装"><a href="#manimgl安装" class="headerlink" title="manimgl安装"></a>manimgl安装</h1><p>准备用<code>manimgl</code>渲染一些数学释义，配置tex的过程折腾了一番，记录一下备忘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install tex</span><br><span class="line">sudo apt-get install texlive-latex-base dvipng texlive-latex-extra cm-super xzdec</span><br><span class="line"><span class="comment"># setup tlmgr</span></span><br><span class="line">tlmgr init-usertree</span><br><span class="line">tlmgr option repository ftp://tug.org/historic/systems/texlive/2017/tlnet-final</span><br><span class="line"><span class="comment"># update tlmgr</span></span><br><span class="line"><span class="comment">#wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh</span></span><br><span class="line"><span class="comment">#sh update-tlmgr-latest.sh -- --upgrade</span></span><br><span class="line"><span class="comment"># install physics.sty</span></span><br><span class="line">sudo $(<span class="built_in">which</span> tlmgr) install physics</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;manimgl安装&quot;&gt;&lt;a href=&quot;#manimgl安装&quot; class=&quot;headerlink&quot; title=&quot;manimgl安装&quot;&gt;&lt;/a&gt;manimgl安装&lt;/h1&gt;&lt;p&gt;准备用&lt;code&gt;manimgl&lt;/code&gt;渲染一些数学释义，配置tex的过程折腾</summary>
      
    
    
    
    
    <category term="manimgl" scheme="http://yoursite.com/tags/manimgl/"/>
    
  </entry>
  
  <entry>
    <title>LLVM0</title>
    <link href="http://yoursite.com/2020/09/07/LLVM0/"/>
    <id>http://yoursite.com/2020/09/07/LLVM0/</id>
    <published>2020-09-07T02:29:44.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLVM学习笔记0：安装"><a href="#LLVM学习笔记0：安装" class="headerlink" title="LLVM学习笔记0：安装"></a>LLVM学习笔记0：安装</h1><p>算是重拾LLVM，这次重头记录学习历程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装比较简单，<code>apt-get</code>直接安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang</span><br><span class="line">sudo apt-get install llvm</span><br></pre></td></tr></table></figure><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>使用LLVM CookBook里的一个小例子验证安装是否成功。</p><p>demo code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define i32 @test1(i32 %A) &#123;</span><br><span class="line">    %B &#x3D; add i32 %A, 0</span><br><span class="line">    ret i32 %B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class="line">    ret i32 %X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @caller() &#123;</span><br><span class="line">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class="line">    ret i32 %A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将上述LLVM代码输入到<code>testfile.ll</code></li><li>运行<code>opt</code>工具中指令合并的pass：<code>opt -S -instcombine testfile.ll -o output1.ll</code></li><li>运行死代码消除pass：<code>opt -S -deadargelim testfile.ll -o output2.ll</code></li></ol><p>我们容易通过查看上面运行pass后的输出代码确认pass已生效：</p><p><code>output1.ll</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;tesetfile.ll&#39;</span><br><span class="line"></span><br><span class="line">define i32 @test1(i32 %A) &#123;</span><br><span class="line">    ret i32 %A  ; eliminated adding 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class="line">    return i32 %X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @caller() &#123;</span><br><span class="line">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class="line">    ret i32 %A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>output2.ll</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;testfile.ll&#39;</span><br><span class="line"></span><br><span class="line">define i32 @test1(i32 %A) &#123;</span><br><span class="line">    %B &#x3D; add i32 %A, 0</span><br><span class="line">    ret i32 %B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i32 @test(i32 %X) &#123; ; eliminated dead arg</span><br><span class="line">    ret i32 %X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @caller() &#123;</span><br><span class="line">    %A &#x3D; call i32 @test(i32 123) ; elminated dead arg</span><br><span class="line">    ret i32 %A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLVM学习笔记0：安装&quot;&gt;&lt;a href=&quot;#LLVM学习笔记0：安装&quot; class=&quot;headerlink&quot; title=&quot;LLVM学习笔记0：安装&quot;&gt;&lt;/a&gt;LLVM学习笔记0：安装&lt;/h1&gt;&lt;p&gt;算是重拾LLVM，这次重头记录学习历程。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="LLVM, compiler" scheme="http://yoursite.com/tags/LLVM-compiler/"/>
    
  </entry>
  
  <entry>
    <title>two-list system</title>
    <link href="http://yoursite.com/2020/08/23/two-list-system/"/>
    <id>http://yoursite.com/2020/08/23/two-list-system/</id>
    <published>2020-08-23T12:09:15.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意力分配：Two-List-System"><a href="#注意力分配：Two-List-System" class="headerlink" title="注意力分配：Two-List System"></a>注意力分配：Two-List System</h1><p>对于我这种容易分心的人，有限的精力很容易被看起来有趣的事情骗走。但是要做一只卓有成效的社畜，有长远的目标并为之专注是必须的。最近看到一个巴菲特的目标管理方式，感觉很有启发，记录并用起来。</p><p>故事最原始的出处没有查证，<a href="https://hacpai.com/article/1534498720955" target="_blank" rel="noopener">随手找了一个版本</a>。大意是，我们都有很多的目标，花时间将其中对我们来说最重要的整理出来是很值得的。首先，我们可以整理出对我们最重要的25个目标。但我们精力有限，显然不可能同时追求这些目标，可以再从这25个目标中选出对我们来说最重要的5个形成一个短名单。</p><p>对于这样两个目标列表的使用容易陷入一个误区：优先追求对我们最重要的5个目标，剩下的20个目标放于次要的优先级，等我们有空再去花精力。但是巴菲特告诉我们，我们要尽力避免在剩下的20个目标上花任何精力。因为正是这些次要目标才是最容易让我们分心浪费掉精力的，因为他们会给我们错误的激励（那些我们完全不感兴趣的目标反而不会）。</p><p>知易行难，小目标理起来～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注意力分配：Two-List-System&quot;&gt;&lt;a href=&quot;#注意力分配：Two-List-System&quot; class=&quot;headerlink&quot; title=&quot;注意力分配：Two-List System&quot;&gt;&lt;/a&gt;注意力分配：Two-List System&lt;/</summary>
      
    
    
    
    
    <category term="mind-hack" scheme="http://yoursite.com/tags/mind-hack/"/>
    
  </entry>
  
  <entry>
    <title>C++ Performance Trick: OutOfLine Pattern</title>
    <link href="http://yoursite.com/2020/08/14/C-Performance-Trick-OutOfLine-Pattern/"/>
    <id>http://yoursite.com/2020/08/14/C-Performance-Trick-OutOfLine-Pattern/</id>
    <published>2020-08-14T02:54:58.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OutOfLine模式提升C-代码访存局部性"><a href="#OutOfLine模式提升C-代码访存局部性" class="headerlink" title="OutOfLine模式提升C++代码访存局部性"></a>OutOfLine模式提升C++代码访存局部性</h1><p>公司内网看到一个提升C++代码性能的模式（源头是<a href="https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/" target="_blank" rel="noopener">这篇blog</a>），能够以一种容易维护的方式很大程度提升访存的局部性，感觉挺有意思，记录一下。</p><h2 id="从例子说起"><a href="#从例子说起" class="headerlink" title="从例子说起"></a>从例子说起</h2><p>假设你的系统需要打开大量的路径(文件、sockets，pipes)，对于这些路径你需要打开、处理、关闭对应的文件描述符并取消文件描述符和对应路径之间的联系。</p><p>对于这样的需求，我们可能写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnlinkingFD</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> path;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  UnlinkingFD(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; p) : path(p) &#123;</span><br><span class="line">    fd = <span class="built_in">open</span>(p.c_str(), O_RDWR, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~UnlinkingFD() &#123;</span><br><span class="line">      <span class="built_in">close</span>(fd); </span><br><span class="line">      unlink(path.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  UnlinkingFD(<span class="keyword">const</span> UnlinkingFD&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个打开的路径对应一个上面的对象保存对应的路径和文件描述符，大量的打开的文件描述符可能以<code>UnlinkingFD</code>对象形式保存在数组中。上面的代码在功能和逻辑上是完好的，RAII也会在对象生命周期结束时关掉文件描述符并取消和对应路径之间的关联。</p><h3 id="场景-amp-性能分析"><a href="#场景-amp-性能分析" class="headerlink" title="场景&amp;性能分析"></a>场景&amp;性能分析</h3><p>假设我们经常需要用到<code>fd</code>，但是<code>path</code>只在对象生命周期结束时使用。因为一个上面的<code>UnlinkingFD</code>对象需要占用40Bytes，而我们常用的<code>fd</code>只占用了其中的4Bytes，这意味着我们在访问<code>UnlinkingFD</code>数组时cache miss的概率大大提升。</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>将<code>array-of-structs</code>变为<code>struct-of-arrays</code>，这当然可以帮助提升性能，但是我们将无法使用RAII来帮我们做资源管理，单一的fd无法及时得到释放。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p><code>UnlinkingFD</code>对象中不直接保存<code>string</code>对象，而是使用一个<code>unique_ptr</code>指针。这样一个<code>UnlinkingFD</code>对象就从40Bytes降低到了16Bytes，降低了cache miss的概率。</p><h3 id="方案3：OutOfLine模式"><a href="#方案3：OutOfLine模式" class="headerlink" title="方案3：OutOfLine模式"></a>方案3：OutOfLine模式</h3><p>OutOfLine模式可以帮我们将像<code>path</code>这样的冷数据完全移到对象之外，但是仍然保留RAII为我们管理资源。</p><h4 id="OutOfLine用法"><a href="#OutOfLine用法" class="headerlink" title="OutOfLine用法"></a>OutOfLine用法</h4><p><code>OutOfLine</code>类是一个<a href="https://omnimilk.github.io/2020/07/01/expression-template/" target="_blank" rel="noopener">静态多态</a>的基类。 使用此基类时要传入两个模板参数，第一个模板参数为继承的子类，第二个模板参数为要挂在“热”对象上的冷数据的类型。</p><p>例如，对于上面的<code>UnlinkingFD</code>类，改写后的用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnlinkingFD</span> :</span> <span class="keyword">private</span> OutOfLine&lt;UnlinkingFD, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  UnlinkingFD(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(p) &#123;</span><br><span class="line">    fd = <span class="built_in">open</span>(p.c_str(), O_RDWR, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~UnlinkingFD();</span><br><span class="line">  UnlinkingFD(<span class="keyword">const</span> UnlinkingFD&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>OutOfLine模式将冷数据从对象中剥离出去的思路时通过一个全局对象将“热”对象的指针和冷数据关联起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FastData</span>, <span class="title">class</span> <span class="title">ColdData</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutOfLine</span> &#123;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;OutOfLine <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每次创建“热”数据对象时，将热数据对象的指针关联到对应的冷数据上</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">TArgs</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">OutOfLine</span>(<span class="title">TArgs</span>&amp;&amp;.. <span class="title">args</span>) &#123;</span></span><br><span class="line">        global_map_[<span class="keyword">this</span>] = <span class="built_in">std</span>::make_unique&lt;ColdData&gt;(<span class="built_in">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// “热”数据对象析构时，将全局映射中对应的冷数据对象也清理掉</span></span><br><span class="line">    ~OutOfLine() &#123;global_map_.erase(<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="comment">// move “热”数据对象时，将对应的冷数据重新关联（此后不应该在通过旧的“热”数据对象来找冷数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OutOfLine</span><span class="params">(OutOfLine&amp;&amp; other)</span> </span>&#123; *<span class="keyword">this</span> = other;&#125;</span><br><span class="line">    OutOfLine&amp; <span class="keyword">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class="line">        global_map_[<span class="keyword">this</span>] = <span class="built_in">std</span>::<span class="built_in">move</span>(global_map_[&amp;other]);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// non-copyable for simplicity</span></span><br><span class="line">    OutOfLine(OutOfLine <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    OutOfLine&amp; <span class="keyword">operator</span>=(OutOfLine <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 获取当前“热”对象对应的冷数据</span></span><br><span class="line">    <span class="function">ColdData&amp; <span class="title">cold</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *global_map_[<span class="keyword">this</span>]; &#125;</span><br><span class="line">    <span class="function">ColdData <span class="keyword">const</span>&amp; <span class="title">cold</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *global_map_[<span class="keyword">this</span>]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能-amp-资源管理"><a href="#性能-amp-资源管理" class="headerlink" title="性能&amp;资源管理"></a>性能&amp;资源管理</h4><p>静态继承自<code>OutOfLine</code>类的<code>UnlinkingFD</code>现在只有4Bytes， 因此需要高频访问的<code>UnlinkingFD</code>对象的数组的cache miss被降到最低。同时RAII会同时替我们管理“热”数据对象及对应的冷数据。</p><h4 id="NOTE-构造函数初始化顺序"><a href="#NOTE-构造函数初始化顺序" class="headerlink" title="NOTE: 构造函数初始化顺序"></a>NOTE: 构造函数初始化顺序</h4><p>上面静态继承的过程实际上一定程度上限定了热数据和冷数据构造的顺序，因为C++构造函数初始化的顺序如下：</p><ol><li>构造虚拟基类，继承自多个虚拟基类时，按照被继承的顺序构造</li><li>构造非虚拟基类，继承自多个非虚拟基类时，按照被继承的顺序构造</li><li>构造成员对象，按照成员对象的声明顺序构造</li><li>调用类自身的构造函数</li></ol><p>因此，当我们构造一个“热”数据对象时，会首先构造<code>OutOfLine</code>基类（此时<code>OutOfLine</code>类的构造函数中会构造冷数据对象），然后构造“热”数据对象。这就意味着<strong><em>冷数据对象的构造不能依赖于“热”数据对象</em></strong>。</p><h4 id="控制初始化顺序"><a href="#控制初始化顺序" class="headerlink" title="控制初始化顺序"></a>控制初始化顺序</h4><p>当冷数据对象的初始化依赖于热数据对象时，我们需要hack一下初始化的顺序。方法如下：为<code>OutOfLine</code>静态基类提供一个特别的构造函数，这个构造函数以tag类<code>TwoPhaseInit</code>为入参。当我们调用这个构造函数时，冷数据不会被初始化，此时处于一种半构造的状态。然后我们在“热”数据初始化之后显式的调用<code>init_cold_data</code>来初始化冷数据。释放时同理可以引入<code>release_cold_data</code>来hack析构的顺序。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class="line">  OutOfLine(TwoPhaseInit)&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">TArgs</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">init_cold_data</span>(<span class="title">TArgs</span>&amp;&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">    global_map_.<span class="built_in">find</span>(<span class="keyword">this</span>)-&gt;second = <span class="built_in">std</span>::make_unique&lt;ColdData&gt;(<span class="built_in">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_cold_data</span><span class="params">()</span> </span>&#123; global_map_[<span class="keyword">this</span>].reset(); &#125;</span><br></pre></td></tr></table></figure><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h4 id="OutOfLine代码"><a href="#OutOfLine代码" class="headerlink" title="OutOfLine代码"></a><code>OutOfLine</code>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FastData</span>, <span class="title">class</span> <span class="title">ColdData</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutOfLine</span> &#123;</span></span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;OutOfLine <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">TArgs</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutOfLine</span>(<span class="title">TArgs</span>&amp;&amp;... <span class="title">args</span>) :</span> OutOfLine(TwoPhaseInit()) &#123;</span><br><span class="line">    init_cold_data(<span class="built_in">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  ~OutOfLine() &#123; global_map_.erase(<span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">OutOfLine</span><span class="params">(OutOfLine&amp;&amp; other)</span> : <span class="title">OutOfLine</span><span class="params">(OutOfLine::TwoPhaseInit())</span> </span>&#123; (*<span class="keyword">this</span>) = <span class="built_in">std</span>::<span class="built_in">move</span>(other); &#125;</span><br><span class="line">  OutOfLine&amp; <span class="keyword">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class="line">    global_map_[<span class="keyword">this</span>] = <span class="built_in">std</span>::<span class="built_in">move</span>(global_map_[&amp;other]);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  OutOfLine(OutOfLine <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  OutOfLine&amp; <span class="keyword">operator</span>=(OutOfLine <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ColdData&amp; <span class="title">cold</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *global_map_[<span class="keyword">this</span>]; &#125;</span><br><span class="line">  <span class="function">ColdData <span class="keyword">const</span>&amp; <span class="title">cold</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *global_map_[<span class="keyword">this</span>]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class="line">  OutOfLine(TwoPhaseInit) &#123; global_map_.try_emplace(<span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">TArgs</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">init_cold_data</span>(<span class="title">TArgs</span>&amp;&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">    global_map_.<span class="built_in">find</span>(<span class="keyword">this</span>)-&gt;second = <span class="built_in">std</span>::make_unique&lt;ColdData&gt;(<span class="built_in">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release_cold_data</span><span class="params">()</span> </span>&#123; global_map_[<span class="keyword">this</span>].reset(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="benchmark代码"><a href="#benchmark代码" class="headerlink" title="benchmark代码"></a>benchmark代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g++ --std=c++1z -Wall -Wextra -O3 -o ool_benchmark ool_benchmark.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"out_of_line.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deomonstrates keeping the cold data in the object with the fast data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Together</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">uint32_t</span> value;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> metadata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demonstrates "giving up" and just not storing the associated cold-data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OnlyFastData</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">uint32_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demonstrates using OutOfLine to store the cold data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WithOOL</span> :</span> <span class="keyword">public</span> OutOfLine&lt;WithOOL, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">uint32_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The crux of the optimization is that there's no space-overhead</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(WithOOL) == <span class="keyword">sizeof</span>(OnlyFastData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// We synthesize the data up-front so the generation can't interfere with the measured behavior in any way</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Data</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">make_data</span>() &#123;</span></span><br><span class="line">  srand(<span class="number">20180101</span>);</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Data&gt; <span class="title">data</span><span class="params">(<span class="number">10000000</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (Data&amp; d : data) &#123; d.value = rand(); &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We time to measure throughput of touching all the fast data once in sequence</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Data</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">trial</span>(<span class="title">const</span> <span class="title">char</span>* <span class="title">const</span> <span class="title">name</span>, <span class="title">const</span> <span class="title">Data</span>&amp; <span class="title">data</span>, <span class="title">const</span> <span class="title">bool</span> <span class="title">print</span>) &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">uint32_t</span> <span class="built_in">running</span> = <span class="number">0U</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> before = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; d : data) &#123; <span class="built_in">running</span> += d.value; &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> after = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">print</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" took "</span> &lt;&lt; (after - before).count() &lt;&lt; <span class="string">"ns and "</span> &lt;&lt; <span class="built_in">running</span></span><br><span class="line">              &lt;&lt; <span class="string">" is a value I don't want optimized away"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We generate all the datasets up front, to keep the effects of the allocator distant</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> together  = make_data&lt;Together&gt;();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> only_fast = make_data&lt;OnlyFastData&gt;();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> with_ool  = make_data&lt;WithOOL&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We run each trial twice, recording the results only the second time. The idea is to give a fair comparison, where</span></span><br><span class="line">  <span class="comment">// all 3 options have their caches primed and nobody thus has data fresher from the allocation.</span></span><br><span class="line">  trial(<span class="string">"With cold data in-line (original)               "</span>, together, <span class="literal">false</span>);</span><br><span class="line">  trial(<span class="string">"With cold data in-line (original)               "</span>, together, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  trial(<span class="string">"With cold data thrown away (best-case scenario) "</span>, only_fast, <span class="literal">false</span>);</span><br><span class="line">  trial(<span class="string">"With cold data thrown away (best-case scenario) "</span>, only_fast, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  trial(<span class="string">"With OutOfLIne                                  "</span>, with_ool, <span class="literal">false</span>);</span><br><span class="line">  trial(<span class="string">"With OutOfLIne                                  "</span>, with_ool, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>注意map的<code>try_emplace</code>方法是C++17引入的新特性，编译命令如下：<code>g++ benchmark.cpp -o benchmark -std=c++17</code>。在我自己的笔记本上运行的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">With cold data in-line (original)                took 82936589ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class="line">With cold data thrown away (best-case scenario)  took 74243139ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class="line">With OutOfLIne                                   took 73445932ns and 3350498669 is a value I don&#39;t want optimized away</span><br></pre></td></tr></table></figure><p>加速效果没有原始博客中的那么大，但付出的成本近乎免费，因此在性能优化时是很值得考虑的一个选项。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OutOfLine模式提升C-代码访存局部性&quot;&gt;&lt;a href=&quot;#OutOfLine模式提升C-代码访存局部性&quot; class=&quot;headerlink&quot; title=&quot;OutOfLine模式提升C++代码访存局部性&quot;&gt;&lt;/a&gt;OutOfLine模式提升C++代码访</summary>
      
    
    
    
    
    <category term="Performance, C++" scheme="http://yoursite.com/tags/Performance-C/"/>
    
  </entry>
  
  <entry>
    <title>Python_Pass</title>
    <link href="http://yoursite.com/2020/08/09/Python-Pass/"/>
    <id>http://yoursite.com/2020/08/09/Python-Pass/</id>
    <published>2020-08-09T07:00:53.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mindspore-Python-Pass"><a href="#Mindspore-Python-Pass" class="headerlink" title="Mindspore Python Pass"></a>Mindspore Python Pass</h1><p>Mindspore的Python Pass特性简单来说就是使能在Python中编写优化器中的pass。现在这一特性的开发将告一段落，简单记录一下。</p><h2 id="PRs"><a href="#PRs" class="headerlink" title="PRs"></a>PRs</h2><ol><li><p><a href="https://gitee.com/mindspore/mindspore/pulls/2478" target="_blank" rel="noopener">基本功能</a></p></li><li><p><a href="https://gitee.com/mindspore/mindspore/pulls/2963" target="_blank" rel="noopener">Python UT支持&amp;用例</a></p></li><li><a href="https://gitee.com/mindspore/mindspore/pulls/3715" target="_blank" rel="noopener">新Pattern表达方式</a></li><li><a href="https://gitee.com/mindspore/mindspore/pulls/4126" target="_blank" rel="noopener">添加Parameter支持</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mindspore-Python-Pass&quot;&gt;&lt;a href=&quot;#Mindspore-Python-Pass&quot; class=&quot;headerlink&quot; title=&quot;Mindspore Python Pass&quot;&gt;&lt;/a&gt;Mindspore Python Pass&lt;/</summary>
      
    
    
    
    
    <category term="Mindspore, Python, Optimizer, C++" scheme="http://yoursite.com/tags/Mindspore-Python-Optimizer-C/"/>
    
  </entry>
  
  <entry>
    <title>Pybind11 classes</title>
    <link href="http://yoursite.com/2020/07/27/Pybind11-classes/"/>
    <id>http://yoursite.com/2020/07/27/Pybind11-classes/</id>
    <published>2020-07-27T06:10:51.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pybind11-class绑定"><a href="#Pybind11-class绑定" class="headerlink" title="Pybind11 class绑定"></a>Pybind11 class绑定</h1><p>最近工作需要用到Pybind11 class绑定中一些较为高级的特性（虚函数、重载、继承），在此整理记录一下。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>class绑定对应<a href="https://omnimilk.github.io/2020/07/27/Pybind11-Type-Conversions/" target="_blank" rel="noopener">上一篇</a>中的第一种场景，即将C++原生类型通过<code>class_</code>函数向Python暴露。下面用一个小例子展示class绑定最基本的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">        .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">        .def(<span class="string">"setName"</span>, &amp;Pet::setName)</span><br><span class="line">        .def(<span class="string">"getName"</span>, &amp;Pet::getName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码向Python暴露了<code>Pet</code>类，其中有三个方法：<code>__init__</code>, <code>setName</code>, <code>getName</code>。</p><h3 id="设置关键字参数和默认参数"><a href="#设置关键字参数和默认参数" class="headerlink" title="设置关键字参数和默认参数"></a>设置关键字参数和默认参数</h3><p>在def函数时可以添加参数的名字及设置默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">  <span class="comment">//m.def("add", &amp;add, "A function which adds two numbers");</span></span><br><span class="line">  <span class="comment">// 变为关键字参数</span></span><br><span class="line">  m.def(<span class="string">"add"</span>, &amp;add, <span class="string">"A function which adds two numbers"</span>, py::arg(<span class="string">"i"</span>), py::arg(<span class="string">"j"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// python调用：example.add(i=1,  j=2)</span></span><br></pre></td></tr></table></figure><p>设置默认值类似（NOTE: C++接口中定义的默认值不会自动捕获，需要bind时设置）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">  <span class="comment">// 设置参数默认值</span></span><br><span class="line">  m.def(<span class="string">"add"</span>, &amp;add, <span class="string">"A function which adds two numbers"</span>, py::arg(<span class="string">"i"</span>) = <span class="number">1</span>, py::arg(<span class="string">"j"</span>) = <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定Lambda函数"><a href="#绑定Lambda函数" class="headerlink" title="绑定Lambda函数"></a>绑定Lambda函数</h3><p>上面的方法绑定是将Python方法绑定到方法指针上，实际上可以用Lambda函数替换。例如，给Pet类增加一个<code>__repr__</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">    .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">    .def(<span class="string">"setName"</span>, &amp;Pet::setName)</span><br><span class="line">    .def(<span class="string">"getName"</span>, &amp;Pet::getName)</span><br><span class="line">    .def(<span class="string">"__repr__"</span>,</span><br><span class="line">        [](<span class="keyword">const</span> Pet &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;example.Pet named '"</span> + a.name + <span class="string">"'&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="绑定成员变量"><a href="#绑定成员变量" class="headerlink" title="绑定成员变量"></a>绑定成员变量</h3><p>C++中公有成员变量可以绑定为Python中可以读写的attributes（const成员绑定为只读attributes），例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">        .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">        .def(<span class="string">"setName"</span>, &amp;Pet::setName)</span><br><span class="line">        .def(<span class="string">"getName"</span>, &amp;Pet::getName)</span><br><span class="line">        .def_readwrite(<span class="string">"name"</span>, &amp;Pet::name); <span class="comment">//公有非const成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Python中调用：</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p = example.Pet("Molly")</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.name</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.name = "Charly"</span></span><br></pre></td></tr></table></figure><p>私有成员变量可以通过绑定C++中的getter和setter成为Python中的property：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">  .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">  .def_property(<span class="string">"name"</span>, &amp;Pet::getName, &amp;Pet::setName);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>类似的方法还有：<code>def_readwrite_static()</code>, <code>def_readonly_static()</code>, <code>def_property_static()</code>, <code>def_property_readonly_static()</code></p><p>NOTE: Python可以动态的添加属性，绑定时也可以使能C++暴露的类在Python中支持动态属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// py::dynamic_attr()支持动态属性</span></span><br><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>, py::dynamic_attr())</span><br><span class="line">    .def(py::init&lt;&gt;())</span><br><span class="line">    .def_readwrite(<span class="string">"name"</span>, &amp;Pet::name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Python中动态向Pet添加属性</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p = example.Pet()</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.name = "charly"</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.age = 2 # 动态添加age属性</span></span><br></pre></td></tr></table></figure><h3 id="保持继承关系"><a href="#保持继承关系" class="headerlink" title="保持继承关系"></a>保持继承关系</h3><p>C++中的继承关系有两种方式保留到暴露到Python的类中，下面以一个例子说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> :</span> Pet &#123;</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : Pet(name) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bark</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"woof!"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一种方法是子类暴露时在<code>class_</code>的模板中指定基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">   .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">   .def_readwrite(<span class="string">"name"</span>, &amp;Pet::name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method 1: template parameter:</span></span><br><span class="line">py::class_&lt;Dog, Pet <span class="comment">/* &lt;- specify C++ parent type */</span>&gt;(m, <span class="string">"Dog"</span>)</span><br><span class="line">    .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">    .def(<span class="string">"bark"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure><p>第二种方法是在子类暴露时在<code>class_</code>的参数中传入基类的<code>class_</code>闭包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">py::class_&lt;Pet&gt; <span class="title">pet</span><span class="params">(m, <span class="string">"Pet"</span>)</span></span>;</span><br><span class="line">pet.def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">   .def_readwrite(<span class="string">"name"</span>, &amp;Pet::name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method 2: pass parent class_ object:</span></span><br><span class="line">py::class_&lt;Dog&gt;(m, <span class="string">"Dog"</span>, pet <span class="comment">/* &lt;- specify Python parent type */</span>)</span><br><span class="line">    .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;())</span><br><span class="line">    .def(<span class="string">"bark"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure><h3 id="自动向下类型转换（downcasting）"><a href="#自动向下类型转换（downcasting）" class="headerlink" title="自动向下类型转换（downcasting）"></a>自动向下类型转换（downcasting）</h3><p>自动向下类型转换指的是<strong>多态类型</strong>的基类指针形式返回子类对象，此指针被自动识别并转换为子类的指针。需要注意的是，上面的<code>Pet</code>和<code>Dog</code>并不是多态类型，因为<code>Pet</code>中没有定义虚函数。</p><p>下面以<code>Pet</code>和<code>Dog</code>为例展示<strong>没有</strong>自动downcasting时的行为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指向子类对象的基类指针</span></span><br><span class="line">m.def(<span class="string">"pet_store"</span>, []() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Pet&gt;(<span class="keyword">new</span> Dog(<span class="string">"Molly"</span>)); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有自动downcasting时的行为</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p = example.pet_stor()</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; type(p)</span></span><br><span class="line">Pet                                          # 没有被识别为Dog</span><br><span class="line"><span class="comment">// p.bark()</span></span><br><span class="line">AttributeError: 'Pet' object has no attribute 'bark'</span><br></pre></td></tr></table></figure><p>我们可以向<code>Pet</code>中添加一个虚函数来通知Pybind11这种多态关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolymorphicPet</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~PolymorphicPet() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolymorphicDog</span> :</span> PolymorphicPet &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bark</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"woof!"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same binding code</span></span><br><span class="line">py::class_&lt;PolymorphicPet&gt;(m, <span class="string">"PolymorphicPet"</span>);</span><br><span class="line">py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, <span class="string">"PolymorphicDog"</span>)</span><br><span class="line">    .def(py::init&lt;&gt;())</span><br><span class="line">    .def(<span class="string">"bark"</span>, &amp;PolymorphicDog::bark);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Again, return a base pointer to a derived instance</span></span><br><span class="line">m.def(<span class="string">"pet_store2"</span>, []() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PolymorphicPet&gt;(<span class="keyword">new</span> PolymorphicDog); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Python中调用</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p = example.pet_store2()</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; type(p)</span></span><br><span class="line"><span class="comment">// PolymorphicDog  # automatically downcast</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.bark()</span></span><br><span class="line"><span class="comment">// u'woof!'</span></span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>C++中重载的方法直接通过方法名取指针会有歧义，Pybind11有两种方法消除这种歧义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> age) : name(name), age(age) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> age_)</span> </span>&#123; age = age_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：指定方法指针类型，C++11+支持</span></span><br><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">   .def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;, <span class="keyword">int</span>&gt;())</span><br><span class="line">   .def(<span class="string">"set"</span>, (<span class="keyword">void</span> (Pet::*)(<span class="keyword">int</span>)) &amp;Pet::<span class="built_in">set</span>, <span class="string">"Set the pet's age"</span>)</span><br><span class="line">   .def(<span class="string">"set"</span>, (<span class="keyword">void</span> (Pet::*)(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)) &amp;Pet::<span class="built_in">set</span>, <span class="string">"Set the pet's name"</span>);</span><br><span class="line"><span class="comment">// 方法2：py::overload_cast自动推导返回值类型， C++14+支持</span></span><br><span class="line">py::class_&lt;Pet&gt;(m, <span class="string">"Pet"</span>)</span><br><span class="line">    .def(<span class="string">"set"</span>, py::overload_cast&lt;<span class="keyword">int</span>&gt;(&amp;Pet::<span class="built_in">set</span>), <span class="string">"Set the pet's age"</span>)</span><br><span class="line">    .def(<span class="string">"set"</span>, py::overload_cast&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;(&amp;Pet::<span class="built_in">set</span>), <span class="string">"Set the pet's name"</span>);</span><br></pre></td></tr></table></figure><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Kind &#123;</span><br><span class="line">        Dog = <span class="number">0</span>,</span><br><span class="line">        Cat</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, Kind type) : name(name), type(type) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Kind type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">py::class_&lt;Pet&gt; <span class="title">pet</span><span class="params">(m, <span class="string">"Pet"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">pet.def(py::init&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;, Pet::Kind&gt;())</span><br><span class="line">    .def_readwrite(<span class="string">"name"</span>, &amp;Pet::name)</span><br><span class="line">    .def_readwrite(<span class="string">"type"</span>, &amp;Pet::type);</span><br><span class="line"></span><br><span class="line">py::enum_&lt;Pet::Kind&gt;(pet, <span class="string">"Kind"</span>)</span><br><span class="line">    .value(<span class="string">"Dog"</span>, Pet::Kind::Dog)</span><br><span class="line">    .value(<span class="string">"Cat"</span>, Pet::Kind::Cat)</span><br><span class="line">    .export_values();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Python 调用：</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p = Pet('Lucy', Pet.Cat)</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; p.type</span></span><br><span class="line"><span class="comment">// Kind.Cat</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; int(p.type)</span></span><br><span class="line"><span class="comment">// 1L</span></span><br></pre></td></tr></table></figure><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="覆写虚函数"><a href="#覆写虚函数" class="headerlink" title="覆写虚函数"></a>覆写虚函数</h3><p>直接以例子来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Animal() &#123; &#125;</span><br><span class="line">    <span class="comment">// 纯虚函数， 有纯虚函数的类无法实例化， 因此无法定义构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n_times; ++i)</span><br><span class="line">            result += <span class="string">"woof! "</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入基类指针，调用实际对象的go方法</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">call_go</span><span class="params">(Animal *animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal-&gt;go(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad binding! 无法扩展，因为此处Animal类没有构造函数</span></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    py::class_&lt;Animal&gt;(m, <span class="string">"Animal"</span>)</span><br><span class="line">        .def(<span class="string">"go"</span>, &amp;Animal::go);</span><br><span class="line"></span><br><span class="line">    py::class_&lt;Dog, Animal&gt;(m, <span class="string">"Dog"</span>)</span><br><span class="line">        .def(py::init&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    m.def(<span class="string">"call_go"</span>, &amp;call_go);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在C++中新增一个跳转类来解决上述问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyAnimal</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Inherit the constructors */</span></span><br><span class="line">    <span class="keyword">using</span> Animal::Animal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trampoline (need one for each virtual function) */</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 对纯虚函数使用此宏 */</span></span><br><span class="line">        <span class="comment">/* 对有默认实现的虚函数，使用PYBIND11_OVERLOAD*/</span></span><br><span class="line">        PYBIND11_OVERLOAD_PURE(</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">/* Return type */</span></span><br><span class="line">            Animal,      <span class="comment">/* Parent class */</span></span><br><span class="line">            go,          <span class="comment">/* Name of function in C++ (must match Python name) */</span></span><br><span class="line">            n_times      <span class="comment">/* Argument(s) */</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    py::class_&lt;Animal, PyAnimal <span class="comment">/* &lt;--- trampoline*/</span>&gt;(m, <span class="string">"Animal"</span>)</span><br><span class="line">        .def(py::init&lt;&gt;())</span><br><span class="line">        .def(<span class="string">"go"</span>, &amp;Animal::go);</span><br><span class="line"></span><br><span class="line">    py::class_&lt;Dog, Animal&gt;(m, <span class="string">"Dog"</span>)</span><br><span class="line">        .def(py::init&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    m.def(<span class="string">"call_go"</span>, &amp;call_go);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Python中进行扩展和调用：</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; from example import *</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; d = Dog()</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; call_go(d)</span></span><br><span class="line"><span class="comment">u'woof! woof! woof! '</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; class Cat(Animal):</span></span><br><span class="line"><span class="comment">...     def go(self, n_times):</span></span><br><span class="line"><span class="comment">...             return "meow! " * n_times</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; class Dachshund(Dog):</span></span><br><span class="line"><span class="comment">...        def __init__(self, name):</span></span><br><span class="line"><span class="comment">...            Dog.__init__(self) # init c++ part</span></span><br><span class="line"><span class="comment">...            self.name = name</span></span><br><span class="line"><span class="comment">...        def bark(self):</span></span><br><span class="line"><span class="comment">...            return "yap!"</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; c = Cat()</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; call_go(c)</span></span><br><span class="line"><span class="comment">u'meow! meow! meow! '</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>NOTE: 用Python类扩展C++暴露出来的类时，不要使用<code>super()</code>, 不要使用<code>super()</code>, 不要使用<code>super()</code>! 应该直接使用对应类的<code>__init__</code>方法， 因为Python的方法解析顺序（MRO）和C++不一致。</p><h3 id="绑定虚函数和继承"><a href="#绑定虚函数和继承" class="headerlink" title="绑定虚函数和继承"></a>绑定虚函数和继承</h3><p>继续直接从例子开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"unknown"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n_times; ++i)</span><br><span class="line">            result += bark() + <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"woof!"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个跳转类， 覆写虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyAnimal</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Animal::Animal; <span class="comment">// Inherit constructors</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> <span class="keyword">override</span> </span>&#123; PYBIND11_OVERLOAD_PURE(<span class="built_in">std</span>::<span class="built_in">string</span>, Animal, go, n_times); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class="built_in">std</span>::<span class="built_in">string</span>, Animal, name, ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyDog</span> :</span> <span class="keyword">public</span> Dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Dog::Dog; <span class="comment">// Inherit constructors</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n_times)</span> <span class="keyword">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class="built_in">std</span>::<span class="built_in">string</span>, Dog, go, n_times); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class="built_in">std</span>::<span class="built_in">string</span>, Dog, name, ); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bark</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class="built_in">std</span>::<span class="built_in">string</span>, Dog, bark, ); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NOTE: 上面通过pybind11注册过的类的子类都需要定义跳转类来覆写父类中的虚函数，当子类较多或者虚函数较多时，可以使用模板类来避免大量重复代码（参考<a href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance" target="_blank" rel="noopener">这里</a>）。</p><h3 id="绑定自定义构造函数"><a href="#绑定自定义构造函数" class="headerlink" title="绑定自定义构造函数"></a>绑定自定义构造函数</h3><p>使用<code>py::init&lt;Args, ...&gt;()</code>或者<code>py::init_alias&lt;Args, ...&gt;()</code>绑定构造函数较方便，但有时我们需要绑定自定义的方法作为构造函数（例如：工厂方法，单例获取静态方法）。</p><p>下面的代码展示多种将C++方法绑定为Python构造函数的途径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example(<span class="keyword">int</span>); <span class="comment">// private constructor</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Factory function - returned by value:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Example <span class="title">create</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> Example(a); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These constructors are publicly callable:</span></span><br><span class="line">    Example(<span class="keyword">double</span>);</span><br><span class="line">    Example(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    Example(<span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">py::class_&lt;Example&gt;(m, <span class="string">"Example"</span>)</span><br><span class="line">    <span class="comment">// Bind the factory function as a constructor:</span></span><br><span class="line">    .def(py::init(&amp;Example::create))</span><br><span class="line">    <span class="comment">// Bind a lambda function returning a pointer wrapped in a holder:</span></span><br><span class="line">    .def(py::init([](<span class="built_in">std</span>::<span class="built_in">string</span> arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Example&gt;(<span class="keyword">new</span> Example(arg));</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">// Return a raw pointer:</span></span><br><span class="line">    .def(py::init([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="keyword">new</span> Example(a, b); &#125;))</span><br><span class="line">    <span class="comment">// You can mix the above with regular C++ constructor bindings as well:</span></span><br><span class="line">    .def(py::init&lt;<span class="keyword">double</span>&gt;())</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h4 id="有虚函数跳转类的构造函数"><a href="#有虚函数跳转类的构造函数" class="headerlink" title="有虚函数跳转类的构造函数"></a>有虚函数跳转类的构造函数</h4><p>两种方法：</p><ol><li>以右值引用的方式将基类值传给子类构造函数</li><li>向<code>py::init&lt;&gt;</code>提供两个工厂函数，第一个在不需要子类时调（即暴露的类只在Python中被使用而没有被继承），第二个在需要子类时被调用</li></ol><p>两种方式的demo如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/factory.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Example() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyExample</span> :</span> <span class="keyword">public</span> Example &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Example::Example;</span><br><span class="line">    <span class="comment">// 第一种方式：跳转类以右值引用方式接收基类</span></span><br><span class="line">    PyExample(Example &amp;&amp;base) : Example(<span class="built_in">std</span>::<span class="built_in">move</span>(base)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">py::class_&lt;Example, PyExample&gt;(m, <span class="string">"Example"</span>)</span><br><span class="line">    <span class="comment">// Returns an Example pointer.  If a PyExample is needed, the Example instance will be moved via the extra constructor in PyExample, above.</span></span><br><span class="line">    .def(py::init([]() &#123; <span class="keyword">return</span> <span class="keyword">new</span> Example(); &#125;))</span><br><span class="line">    <span class="comment">// 第二种方式：提供两个工厂函数</span></span><br><span class="line">    .def(py::init([]() &#123; <span class="keyword">return</span> <span class="keyword">new</span> Example(); &#125; <span class="comment">/* no alias needed */</span>,</span><br><span class="line">                  []() &#123; <span class="keyword">return</span> <span class="keyword">new</span> PyExample(); &#125; <span class="comment">/* alias needed */</span>))</span><br><span class="line">    <span class="comment">// *Always* returns an alias instance (like py::init_alias&lt;&gt;())</span></span><br><span class="line">    .def(py::init([]() &#123; <span class="keyword">return</span> <span class="keyword">new</span> PyExample(); &#125;))</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>在<code>class_</code>的模板参数中指定所有的基类即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">py::class_ &lt;MyType, BaseType1, BaseType2, BaseType3&gt;(m, <span class="string">"MyType"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pybind11-class绑定&quot;&gt;&lt;a href=&quot;#Pybind11-class绑定&quot; class=&quot;headerlink&quot; title=&quot;Pybind11 class绑定&quot;&gt;&lt;/a&gt;Pybind11 class绑定&lt;/h1&gt;&lt;p&gt;最近工作需要用到Pybind</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="pybind11, c++, python" scheme="http://yoursite.com/tags/pybind11-c-python/"/>
    
  </entry>
  
  <entry>
    <title>Pybind11 Type Conversions</title>
    <link href="http://yoursite.com/2020/07/27/Pybind11-Type-Conversions/"/>
    <id>http://yoursite.com/2020/07/27/Pybind11-Type-Conversions/</id>
    <published>2020-07-27T02:17:43.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pybind11类型转换"><a href="#Pybind11类型转换" class="headerlink" title="Pybind11类型转换"></a>Pybind11类型转换</h1><p>Pybind11帮助我们方便的实现C++和Python之间的调用，无论是相互的接口暴露还是数据传递都要求我们正确的在C++和Python类型之间进行转换（<a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html" target="_blank" rel="noopener">官方文档</a>）。</p><h2 id="三种场景"><a href="#三种场景" class="headerlink" title="三种场景"></a>三种场景</h2><ol><li>C++原生类型暴露给python</li><li>Python原生类型暴露给C++</li><li>C++和Python原生类型间相互转换</li></ol><h2 id="C-原生类型暴露给Python"><a href="#C-原生类型暴露给Python" class="headerlink" title="C++原生类型暴露给Python"></a>C++原生类型暴露给Python</h2><p>使用<code>py::class_</code>将自定义的C++类型暴露给Python（<a href="https://pybind11.readthedocs.io/en/stable/classes.html" target="_blank" rel="noopener">参考这里</a>）。C++类型传递给Python时会在原生C++类型外加一层wrapper，从Python取回时只用去掉wrapper即可。</p><h2 id="Python原生类型暴露给C"><a href="#Python原生类型暴露给C" class="headerlink" title="Python原生类型暴露给C++"></a>Python原生类型暴露给C++</h2><p>在C++中取用Python的原生类型（例如：<code>tuple</code>、<code>list</code>），例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++中使用Python对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(py::<span class="built_in">list</span> my_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> item : my_list) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python中传入Python对象给C++:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这个例子里Python中的<code>list</code>类型没有进行任何转换，只是被封装进了C++的<code>py::list</code>类中。目前Pybind11支持以下类型(<a href="https://pybind11.readthedocs.io/en/stable/advanced/pycpp" target="_blank" rel="noopener">参考这里</a>)：<code>handle</code>, <code>object</code>, <code>bool_</code>, <code>int_</code>, <code>float_</code>, <code>str</code>, <code>bytes</code>, <code>tuple</code>, <code>list</code>, <code>dict</code>, <code>slice</code>, <code>none</code>, <code>capsule</code>, <code>iterable</code>, <code>iterator</code>, <code>function</code>, <code>buffer</code>, <code>array</code>, <code>array_t</code>。</p><h2 id="C-和Python原生类型间相互转换"><a href="#C-和Python原生类型间相互转换" class="headerlink" title="C++和Python原生类型间相互转换"></a>C++和Python原生类型间相互转换</h2><p>有些场景C++和Python都用的是各自的原生类型，Pybind11支持常见C++原生类型和Python原生类型间的相互转换，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> item : v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print_vector([1, 2, 3])</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>容易注意到Python中传入的为<code>list</code>类型，而C++中处理的类型为<code>const std::vector&lt;int&gt; &amp;</code>。Pybind11这种默认类型转换会在原生类型间拷贝数据，例如上面Python中的调用会首先将list中的数据拷贝到一个<code>std::vector&lt;int&gt;</code>中，然后进行C++中的调用。</p><p>NOTE: 默认的拷贝可能开销很大，可以通过手写<a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque" target="_blank" rel="noopener">opaque types</a>重载类型转换的wrapper来避免不必要的拷贝。opaque types还没有使用过，有机会单独挖坑写。</p><h2 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h2><p>Pybind11默认（<code>pybind11/pybind11.h</code>）支持<code>std::pair&lt;&gt;</code>，<code>std::tuple&lt;&gt;</code>和<code>list</code>, <code>set</code>, <code>dict</code>之间的自动转换。引入<code>pybind11/stl.h</code>可以新增<code>std::vector&lt;&gt;</code>, <code>std::deque&lt;&gt;</code>, <code>std::list&lt;&gt;</code>, <code>std::array&lt;&gt;</code>, <code>std::set&lt;&gt;</code>, <code>std::unordered_set&lt;&gt;</code>, <code>std::map&lt;&gt;</code>和<code>std::unordered_map&lt;&gt;</code>的与Python的自动转换。</p><h3 id="绑定STL容器"><a href="#绑定STL容器" class="headerlink" title="绑定STL容器"></a>绑定STL容器</h3><p><code>pybind11/stl_bind.h</code>可以帮助我们将STL容器作为原生对象暴露出来。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/stl_bind.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PYBIND11_MAKE_OPAQUE(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">PYBIND11_MAKE_OPAQUE(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">py::bind_vector&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m, <span class="string">"VectorInt"</span>);</span><br><span class="line">py::bind_map&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt;(m, <span class="string">"MapStringDouble"</span>);</span><br><span class="line"><span class="comment">// 或者同时设置绑定的作用域</span></span><br><span class="line">py::bind_vector&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m, <span class="string">"VectorInt"</span>, py::module_local(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pybind11类型转换&quot;&gt;&lt;a href=&quot;#Pybind11类型转换&quot; class=&quot;headerlink&quot; title=&quot;Pybind11类型转换&quot;&gt;&lt;/a&gt;Pybind11类型转换&lt;/h1&gt;&lt;p&gt;Pybind11帮助我们方便的实现C++和Python之间的</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="pybind11, c++, python" scheme="http://yoursite.com/tags/pybind11-c-python/"/>
    
  </entry>
  
  <entry>
    <title>Bonfire</title>
    <link href="http://yoursite.com/2020/07/26/Bonfire/"/>
    <id>http://yoursite.com/2020/07/26/Bonfire/</id>
    <published>2020-07-26T03:46:59.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bonfire"><a href="#Bonfire" class="headerlink" title="Bonfire"></a>Bonfire</h1><p>Cannot move my eyes away from the bonfire</p><p>It was his will</p><p>It is a dance of life and death</p><p>It would be ashes of bodies</p><p>It is not an illusion as long as it burns</p><p>But I had stared at it for too long</p><p>So I lit my hand</p><p>And walked into the dark</p><p>As my lights going dimmer and dimmer</p><p>How I wish it is a cool autumn</p><p>I would just fall down on the ground</p><p>And flare up the whole forest</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bonfire&quot;&gt;&lt;a href=&quot;#Bonfire&quot; class=&quot;headerlink&quot; title=&quot;Bonfire&quot;&gt;&lt;/a&gt;Bonfire&lt;/h1&gt;&lt;p&gt;Cannot move my eyes away from the bonfire&lt;/p&gt;
&lt;p&gt;I</summary>
      
    
    
    
    
    <category term="Mood" scheme="http://yoursite.com/tags/Mood/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow graph_matcher</title>
    <link href="http://yoursite.com/2020/07/20/Tensorflow-Graph-Matcher/"/>
    <id>http://yoursite.com/2020/07/20/Tensorflow-Graph-Matcher/</id>
    <published>2020-07-20T01:34:12.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TF-graph-matcher用法及源码探究"><a href="#TF-graph-matcher用法及源码探究" class="headerlink" title="TF graph_matcher用法及源码探究"></a>TF graph_matcher用法及源码探究</h1><p><code>graph_matcher</code>是<code>tensorflow.contrib</code>中量化模块（<code>quantize</code>）的一个子模块，用于在计算图中描述和匹配特定的模式。配合对模式匹配后的处理，可以在python层面实现计算图的pass。</p><h2 id="用法-以Conv-BN融合为例"><a href="#用法-以Conv-BN融合为例" class="headerlink" title="用法: 以Conv + BN融合为例"></a>用法: 以Conv + BN融合为例</h2><p>Conv+BN是CNN网络中常见的组合。如果我们观察两者的计算公式，可以发现两者可以融合为一个算子达到运行加速的效果（实质上，Conv计算上等价于MatMul，所以融合也适用于FC+BN等组合）。</p><h3 id="融合原理"><a href="#融合原理" class="headerlink" title="融合原理"></a>融合原理</h3><p>首先，分别观察Conv和BN的计算公式：</p><p>​    Conv的计算公式：$z = w * x + b$</p><p>​    BN的计算公式：$y = \frac{(z - \mu_B) * \gamma}{ \sigma_B} + \beta$</p><p>实际上，我们可以通过更新Conv的<code>weight</code>和<code>bias</code>直接在Conv中完成Conv + BN所需完成的计算。略去推导，直接给出新的<code>weight</code>和<code>bias</code>的计算公式如下：</p><p>​    $w^{\prime} = \frac{w * \gamma}{\sigma_B}$, $b^{\prime} = \frac{(b - \mu_B)\gamma}{\sigma_B} + \beta$</p><p>代入新的$w^{‘}$和$b^{‘}$，容易验证新的Conv计算等价于Conv + BN:</p><script type="math/tex; mode=display">\begin{align}z^{\prime} &= w^{\prime} * x + b^{\prime} \\          &= \frac{w * \gamma * x}{\sigma_B} +\frac{(b - \mu_B) * \gamma} {\sigma_B} + \beta \\          &=\frac{\gamma(w*x + b - \mu_B)}{\sigma_B} + \beta \\          &=\frac{(z - \mu_B) * \gamma}{\sigma_B} + \beta = y\end{align}</script><h3 id="graph-matcher实现"><a href="#graph-matcher实现" class="headerlink" title="graph_matcher实现"></a>graph_matcher实现</h3><p><code>tensorflow.contrib.quantize.python</code>中包含了Conv + BN融合的<a href="https://github.com/tensorflow/tensorflow/blob/590d6eef7e91a6a7392c8ffffb7b58f2e0c8bc6b/tensorflow/contrib/quantize/python/fold_batch_norms.py#L151-L205" target="_blank" rel="noopener">实现</a>，完整的代码较长，我们重点关注其中对Conv+BN模式描述的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_FindFusedBatchNorms</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""Finds all ops and tensors related to found FusedBatchNorms.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    graph: Graph to inspect.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    _FusedBatchNormMatches.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    input_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    weight_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    gamma_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    beta_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    mean_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    variance_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    </span><br><span class="line">    moving_average_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    bn_decay_pattern = graph_matcher.OpTypePattern(<span class="string">'*'</span>)</span><br><span class="line">    layer_pattern = graph_matcher.OpTypePattern(<span class="string">'Conv2D|DepthwiseConv2dNative|MatMul'</span>, inputs=[input_pattern, weight_pattern])</span><br><span class="line">    ...</span><br><span class="line">    layer_output_pattern = graph_matcher.OneofPattern([layer_pattern_with_identity, layer_pattern, batch_to_space_pattern])</span><br><span class="line">    ...</span><br><span class="line">    bn_matcher = graph_matcher.GraphMatcher(graph_matcher.OneofPattern([matmul_bn_output_reshape_pattern, batch_norm_pattern]))</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GetLayerMatch</span><span class="params">(match_result)</span>:</span></span><br><span class="line">        <span class="string">"""Populates a layer match object containing ops/tensors for folding BNs.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">        match_result: Matched result from graph matcher</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        layer_op: Matching conv/fc op prior to batch norm</span></span><br><span class="line"><span class="string">        BatchNormMatch: _BatchNormMatch containing all required batch norm parameters.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ...</span><br><span class="line">    layer_matches = []</span><br><span class="line">    matched_layer_set = set()</span><br><span class="line">    <span class="keyword">for</span> match_result <span class="keyword">in</span> bn_identity_matcher.match_graph(graph):</span><br><span class="line">        layer_op, layer_match = _GetLayerMatch(match_result)</span><br><span class="line">        <span class="keyword">if</span> layer_op <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> layer_op <span class="keyword">not</span> <span class="keyword">in</span> matched_layer_set:</span><br><span class="line">                matched_layer_set.add(layer_op)</span><br><span class="line">                layer_matches.append(layer_match)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> layer_matches</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_FoldFusedBatchNorms</span><span class="params">(graph, is_training, freeze_batch_norm_delay)</span>:</span></span><br><span class="line">    <span class="string">"""Finds fused batch norm layers and folds them into preceding layers.</span></span><br><span class="line"><span class="string">    Folding only affects the following layers: Conv2D, fully connected, depthwise convolution.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    graph: Graph to walk and modify.</span></span><br><span class="line"><span class="string">    is_training: Bool, true if training.</span></span><br><span class="line"><span class="string">    freeze_batch_norm_delay: How many steps to wait before freezing moving mean</span></span><br><span class="line"><span class="string">      and variance and using them for batch normalization.</span></span><br><span class="line"><span class="string">  Raises:</span></span><br><span class="line"><span class="string">  ValueError: When batch norm folding fails.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    <span class="keyword">for</span> match <span class="keyword">in</span> _FindFusedBatchNorms(graph):</span><br><span class="line">        scope, sep, _ = match.layer_op.name.rpartition(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">with</span> graph.as_default(), graph.name_scope(scope + sep):</span><br><span class="line">            <span class="keyword">with</span> graph.name_scope(scope + sep + <span class="string">'BatchNorm_Fold'</span> + sep):</span><br><span class="line">                <span class="comment"># new weights = old weights * gamma / sqrt(variance + epsilon)</span></span><br><span class="line">                <span class="comment"># new biases = -mean * gamma / sqrt(variance + epsilon) + beta</span></span><br><span class="line">                multiplier_tensor = match.gamma_tensor * math_ops.rsqrt(match.variance_tensor + match.bn_op.get_attr(<span class="string">'epsilon'</span>))</span><br><span class="line">                bias_tensor = math_ops.subtract(match.beta_tensor, match.mean_tensor * multiplier_tensor, name=<span class="string">'bias'</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>使用<code>GraphMatcher</code>进行pattern描述、匹配、替换主要分为以下几步：</p><ol><li>使用<code>OpTypePattern</code>及<code>OneofPattern</code>（语法糖）自底向上构建目标pattern</li><li>用目标pattern构造<code>GraphMatcher</code></li><li>向<code>GraphMatcher</code>的<code>match_graph</code>方法传入要匹配的图，获得<code>match_result</code></li><li>从<code>match_result</code>中取出需要复用的pattern中的节点，构造新的节点替换pattern</li></ol><h2 id="graph-matcher实现-1"><a href="#graph-matcher实现-1" class="headerlink" title="graph_matcher实现"></a>graph_matcher实现</h2><p>graph_matcher的<a href="https://github.com/rockchip-linux/tensorflow/blob/master/tensorflow/contrib/quantize/python/graph_matcher.py" target="_blank" rel="noopener">实现</a>主要包括三个部分：<code>Pattern</code>, <code>GraphMatcher</code>, <code>MatchResult</code>。</p><h3 id="Pattern实现"><a href="#Pattern实现" class="headerlink" title="Pattern实现"></a>Pattern实现</h3><p>Pattern作为一个抽象类，要求子类必须实现<code>match</code>方法。<code>match</code>方法接收两个参数：<code>op</code>；<code>tensor</code>。</p><p>Pattern类有两个子类：<code>OpTypePattern</code>类可以限定节点的类型、输入，可以描述一个类型树；<code>Oneof</code></p><p><code>Pattern</code>作为语法糖用于描述one-of关系，也就是匹配输入多个子模式之一即可。</p><p>NOTE: 当前实现了的模式中，<code>match</code>方法中的<code>tensor</code>只是占位用，没有实际使用到。</p><h4 id="OpTypePattern"><a href="#OpTypePattern" class="headerlink" title="OpTypePattern"></a>OpTypePattern</h4><p>构造函数（<code>def __init__(self, op_type, name=None, inputs=None, ordered_inputs=True)</code>）通过限定节点的类型、输入来描述一个类型树；对应的，<code>match</code>中也会递归地对输入节点调用<code>match</code>函数。NOTE: <code>OpType</code>的匹配是使用字符串来完成的。</p><h3 id="MatchResult"><a href="#MatchResult" class="headerlink" title="MatchResult"></a>MatchResult</h3><p>保存match的结果，可以从<code>Pattern</code>实例映射到对应的匹配到的<code>op</code>和<code>tensor</code>。</p><h3 id="GraphMatcher"><a href="#GraphMatcher" class="headerlink" title="GraphMatcher"></a>GraphMatcher</h3><p><code>GraphMatcher</code>中会保存一个pattern，提供方法来检验输入的<code>op</code>或者<code>graph</code>是否和<code>pattern</code>匹配，主要方法有：</p><ol><li>match_op</li><li>match_ops</li><li>match_graph</li></ol><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p><code>TensorFlow</code>中能够轻松的在python中操作图主要得益于图数据结构对python的暴露。当前MindSpore要在python中支持图pass(图中模式的匹配和替换)，可以对比两种思路：</p><ol><li>python向C++注册pass，python中对模式和要替换的目标进行描述，C++中运行pass<ol><li>优点：可以复用部分优化器部分的代码；执行效率较高</li><li>缺点：python pass中的pattern、target与C++通信较复杂</li></ol></li><li>C++向python暴露图接口，直接在python中完成改图<ol><li>优点：对图修改的逻辑全部包含在python中</li><li>缺点：效率较低，但此类任务通常较低频，性能要求不高</li></ol></li></ol><p>综合考虑，C++新增向python暴露图接口，直接在python中完成改图较合理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TF-graph-matcher用法及源码探究&quot;&gt;&lt;a href=&quot;#TF-graph-matcher用法及源码探究&quot; class=&quot;headerlink&quot; title=&quot;TF graph_matcher用法及源码探究&quot;&gt;&lt;/a&gt;TF graph_matcher用</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="TensorFlow, Deep Learning" scheme="http://yoursite.com/tags/TensorFlow-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SNN[5]: LCA</title>
    <link href="http://yoursite.com/2020/07/07/SNN-5-LCA/"/>
    <id>http://yoursite.com/2020/07/07/SNN-5-LCA/</id>
    <published>2020-07-07T02:25:56.000Z</published>
    <updated>2021-04-24T15:49:46.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SNN学习笔记5：LCA"><a href="#SNN学习笔记5：LCA" class="headerlink" title="SNN学习笔记5：LCA"></a>SNN学习笔记5：LCA</h1><h2 id="稀疏编码"><a href="#稀疏编码" class="headerlink" title="稀疏编码"></a>稀疏编码</h2><p>实验表明人脑对于外界刺激采取一种稀疏的内在表示，例如自然图像只需要用<a href="https://en.wikipedia.org/wiki/Sparse_dictionary_learning" target="_blank" rel="noopener">稀疏词典</a>中一个很小的子集及合适的对应系数来进行稀疏近似（sparse approximation）。</p><h3 id="稀疏近似"><a href="#稀疏近似" class="headerlink" title="稀疏近似"></a>稀疏近似</h3><p>稀疏近似的数学表述如下：</p><p>​    给定一个N维刺激<script type="math/tex">s \in \mathbb{R}^N</script>, 找到一个基于由M个向量<script type="math/tex">\{\phi_m\}</script>组成的词典$D$的表示。当词典<script type="math/tex">D</script>是overcomplete时（i.e M &gt; N），我们可以有无穷多种方式来选取词典中向量对应的稀疏<script type="math/tex">\{a_m\}</script> 来表示<script type="math/tex">s</script>: <script type="math/tex">s = \sum_{m = 1}^Ma_m\phi_m</script>。</p><p>在最优稀疏近似中，我们希望尽可能少的使用D中的向量，也就是<strong>系数不为0的向量尽可能的少</strong>：</p><script type="math/tex; mode=display">\mathop{min}_a ||a||_0    s.t.    s = \sum_{m = 1}^Ma_m\phi_m</script><p>上式中<script type="math/tex">||a||_0</script>表示<script type="math/tex">\ell^0</script> norm, 也就是 <script type="math/tex">a = [a_1, a_2, ..., a_M]</script>中非零元素的个数。需要注意的是，这个组合优化问题是NP-hard的。</p><h3 id="Basis-Pursuit目标"><a href="#Basis-Pursuit目标" class="headerlink" title="Basis Pursuit目标"></a>Basis Pursuit目标</h3><p>对<script type="math/tex">\ell_0</script>的优化是NP-hard的，BP目标函数尝试将优化目标改为最小化系数向量的<script type="math/tex">\ell_1</script> norm：</p><script type="math/tex; mode=display">\mathop{min}_a ||a||_1    s.t.    s = \sum_{m = 1}^Ma_m\phi_m</script><p>BP目标函数在信号<script type="math/tex">s</script>相对稀疏时也可以得到最优稀疏近似。</p><h3 id="BPDN：重建误差"><a href="#BPDN：重建误差" class="headerlink" title="BPDN：重建误差"></a>BPDN：重建误差</h3><p>实际操作中，由于<script type="math/tex">s</script>中存在噪音，我们不应该要求完美重建。BPDN（Basis Pursuit De-Noising）目标函数在BP的基础上引入了MSE重建误差来平衡正则项与重建精度：</p><script type="math/tex; mode=display">\mathop{min}_a (||s - \sum_{m = 1}^Ma_m\phi_m||_2^2 + \lambda||a||_1)</script><p>公式中的<script type="math/tex">\lambda</script>正是用来权衡重建误差与正则项的。</p><h4 id="MP算法"><a href="#MP算法" class="headerlink" title="MP算法"></a>MP算法</h4><p>在信号处理社区，常用MP(Matching Pursuit)算法来求解BPDN。MPs算法本质上是一种贪心算法，流程如下：</p><ol><li>将残差初始化为<script type="math/tex">s</script>: <script type="math/tex">r_0 = s</script></li><li>在第k次迭代，通过<script type="math/tex">\theta_k = argmax_m|\langle r_{k-1}, \phi_m\rangle|</script>找到词典M中的索引<script type="math/tex">\theta_k</script></li><li>更新残差：<script type="math/tex">r_k = r_{k - 1} - \phi_{\theta_k}d_k</script></li></ol><p>K次迭代后得到一个<script type="math/tex">s</script>的稀疏近似：<script type="math/tex">\hat{s} = \sum_{k = 1}^K \phi_{\theta_k}d_k</script>。</p><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><p><a href="https://ece.rice.edu/~eld1/papers/Rozell08.pdf" target="_blank" rel="noopener">LCA</a>(Locally Competitive Algorithm)是一种稀疏编码算法，相比MP算法，不仅考虑到了选取最稀疏表示的目标，也考虑了选取最能表征信号特性的向量的目标。同时，LCA对随时间变化的信号的处理进行了优化，LCA不用每一步都从头进行稀疏近似，而是基于上一步的表征向量进行更新。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>LCA中，词典中的每个向量<script type="math/tex">\phi_m \in D</script>都被关联到一个神经元。神经元中维护自己的膜电位<script type="math/tex">u_m(t)</script>，神经元的输入电流为输入与神经元的感受野的匹配度：<script type="math/tex">b_m(t) = \langle\phi_m, s(t)\rangle</script>。当神经元m的膜电位超过阈值<script type="math/tex">\lambda</script>时，输出一个激活信号<script type="math/tex">a_m = T_{\lambda}(u_m)</script>并向周边神经元n发射抑制信号<script type="math/tex">a_m G_{m, n}</script>其中<script type="math/tex">G_{m, n} = \langle \phi_m, \phi_n \rangle</script>。</p><p><strong>NOTE</strong>: 从抑制信号的公式中可以看出，一个神经元的激活越强，对周边神经元的抑制越强；一个神经元与周围的神经元越相似，对周围神经元的抑制越强。这种机制会导致匹配度最高的神经元得到最大的电流输入，然后抑制周边神经元得到输入及进行反向抑制，以此达到获取<strong>稀疏表示</strong>的效果（WTA：winner takes all）。</p><p>上面的膜电位变化机制可以用下面的常微分方程来描述：</p><script type="math/tex; mode=display">\dot{u}_m(t) = \frac{1}{\tau}[b_m(t) - u_m(t) - \sum_\limits{\substack{n \neq m} }G_{m, n}a_n(t)</script><h3 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h3><p>github上的一个<a href="https://github.com/ctn-waterloo/cogsci17-decide/blob/5e82b8cf466db5ce84270c866e9dc0c36daa52b6/cogsci17_decide/networks.py" target="_blank" rel="noopener">参考实现</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nengo</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCA</span><span class="params">(d, n_neurons, dt)</span>:</span></span><br><span class="line">    k = <span class="number">1.</span></span><br><span class="line">    beta = <span class="number">1.</span></span><br><span class="line">    tau_model = <span class="number">0.1</span></span><br><span class="line">    tau_actual = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    I = np.eye(d)</span><br><span class="line">    inhibit = <span class="number">1</span> - I</span><br><span class="line">    B = <span class="number">1.</span> / tau_model</span><br><span class="line">    A = (-k * I - beta * inhibit) / tau_model</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> nengo.Network(label=<span class="string">"LCA"</span>) <span class="keyword">as</span> net:</span><br><span class="line">        net.input = nengo.Node(size_in=d)</span><br><span class="line">        <span class="comment"># array of ensembles: d ensembles, each with n_neurons neurons</span></span><br><span class="line">        x = nengo.networks.EnsembleArray(</span><br><span class="line">            n_neurons, d,</span><br><span class="line">            eval_points=nengo.dists.Uniform(<span class="number">0.</span>, <span class="number">1.</span>),</span><br><span class="line">            intercepts=nengo.dists.Uniform(<span class="number">0.</span>, <span class="number">1.</span>),</span><br><span class="line">            encoders=nengo.dists.Choice([[<span class="number">1.</span>]]),</span><br><span class="line">            label=<span class="string">"state"</span>)</span><br><span class="line">        <span class="comment"># transform: linear transformation mapping the pre output to the post input</span></span><br><span class="line">        <span class="comment"># synapse: synapse model for filtering</span></span><br><span class="line">        nengo.Connection(x.output, x.input, transform=tau_actual * A + I, synapse=tau_actual)</span><br><span class="line">        nengo.Connection(net.input, x.input, transform=tau_actual*B, synapse=tau_actual)</span><br><span class="line">        net.output = x.output</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    dt = <span class="number">0.001</span></span><br><span class="line">    <span class="keyword">with</span> nengo.Network(seed=<span class="number">42</span>) <span class="keyword">as</span> model:</span><br><span class="line">        <span class="comment"># winner takes all</span></span><br><span class="line">        wta = LCA(<span class="number">3</span>, <span class="number">200</span>, dt)</span><br><span class="line">        stimulus = nengo.Node([<span class="number">0.8</span>, <span class="number">0.7</span>, <span class="number">0.6</span>])</span><br><span class="line">        nengo.Connection(stimulus, wta.input, synapse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        p_stimulus = nengo.Probe(stimulus, synapse=<span class="literal">None</span>)</span><br><span class="line">        p_output = nengo.Probe(wta.output, synapse=<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">with</span> nengo.Simulator(model, dt=dt) <span class="keyword">as</span> sim:</span><br><span class="line">        sim.run(<span class="number">1.</span>)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    plt.plot(sim.trange(), sim.data[p_output])</span><br><span class="line">    plt.title(<span class="string">"(a)LCA"</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"Time [s]"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"Decoded output"</span>)</span><br><span class="line">    plt.locator_params(axis=<span class="string">'y'</span>, nbins=<span class="number">5</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/lca.png" alt="LCA"></p><p>可以看到3个ensemble中只有得到最强输入的一个保留了下来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SNN学习笔记5：LCA&quot;&gt;&lt;a href=&quot;#SNN学习笔记5：LCA&quot; class=&quot;headerlink&quot; title=&quot;SNN学习笔记5：LCA&quot;&gt;&lt;/a&gt;SNN学习笔记5：LCA&lt;/h1&gt;&lt;h2 id=&quot;稀疏编码&quot;&gt;&lt;a href=&quot;#稀疏编码&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="SNN, Deep Learning" scheme="http://yoursite.com/tags/SNN-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SNN[4]: Nengo</title>
    <link href="http://yoursite.com/2020/07/06/SNN-4-Nengo/"/>
    <id>http://yoursite.com/2020/07/06/SNN-4-Nengo/</id>
    <published>2020-07-06T07:56:34.000Z</published>
    <updated>2021-04-24T15:49:36.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SNN学习笔记4：-Nengo"><a href="#SNN学习笔记4：-Nengo" class="headerlink" title="SNN学习笔记4： Nengo"></a>SNN学习笔记4： Nengo</h1><p><a href="https://www.nengo.ai/" target="_blank" rel="noopener">Nengo</a> 是一个用于神经建模框架，其扩展<a href="https://nengo.ai/nengo-dl/" target="_blank" rel="noopener">NengoDL</a>支持混用包含了生物细节的神经模型和现在流行的深度学习框架（例如：TensorFlow）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>nengo安装命令：<code>pip install nengo nengo-gui</code></p><p>测试是否安装成功可以尝试运行<code>nengo-gui</code>界面：<code>$: nengo</code></p><p>nengo-dl安装命令：</p><ol><li>安装依赖的tensorflow：<code>conda install tensorflow</code></li><li>安装nengo-dl: <code>pip install nengo-dl</code></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nengo有两种使用模式：GUI和Python解释器。Python解释器模式下，nengo的表现就是一个普通的Python库，因此下面仅介绍GUI模式的使用方式及限制。</p><h3 id="GUI模式"><a href="#GUI模式" class="headerlink" title="GUI模式"></a>GUI模式</h3><p>直接在命令行运行<code>$:nengo</code>即可在网页中运行图形界面。此时左侧会展示当前图的结构（方形表示<code>Nodes</code>，圆形表示<code>Ensembles</code>, 圆角矩形表示<code>Networks</code>），右侧展示对应的代码。</p><p>可以点击左上角的文件夹图标可以运行很多内建的例子，例如<code>/built-in examples/tutorial/15-lorenz.py</code>可以运行一个洛伦兹吸引子的例子，效果很酷。</p><p>需要注意的是，GUI模式下代码有如下限制：</p><ol><li>顶层网络必须叫<code>model</code></li><li>不能构建<code>Simulator对象</code></li><li>不能使用<code>Matplotlib</code>绘图</li></ol><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="/images/ecosystem.svg" alt="架构"></p><p>上图Nengo Core主要包含五个核心Nengo对象和一个基于Numpy的模拟器。五个对象如下：</p><ol><li>nengo.Network： 一个网络可以包含ensembles、nodes、connections和其它网络</li><li>nengo.Ensemble：一组神经元，用于表征一个向量<ol><li>nengo.ensemble.Neurons: 用于连接ensemble中特定神经元的接口</li></ol></li><li>Node：用于提供输入以及处理输出</li><li>Connection：连接两个对象 <strong>NOTE: 和TensorFlow等不同，连接作为一个独立的对象，方便进行独立的设置</strong><ol><li>nengo.connection.LearningRule：为连接制定学习规则</li></ol></li><li>Probe：用于将对象的数据在模拟器运行时取出</li></ol><h3 id="Nengo-DL-Demo-Relu-VS-Spiking-neurons"><a href="#Nengo-DL-Demo-Relu-VS-Spiking-neurons" class="headerlink" title="Nengo-DL Demo: Relu VS Spiking neurons"></a>Nengo-DL Demo: Relu VS Spiking neurons</h3><p>下面的例子会展示Relu作为激活神经元和脉冲神经元的差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> nengo</span><br><span class="line"><span class="keyword">from</span> nengo.utils.matplotlib <span class="keyword">import</span> rasterplot</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> nengo_dl</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> nengo.Network() <span class="keyword">as</span> net:</span><br><span class="line">    <span class="comment"># 输入节点，周期为1s的正弦波</span></span><br><span class="line">    a = nengo.Node(<span class="keyword">lambda</span> t: np.sin(<span class="number">2</span> * np.pi * t))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rate神经元，功能和Relu一致</span></span><br><span class="line">    b_rate = nengo.Ensemble(<span class="number">10</span>, <span class="number">1</span>, neuron_type=nengo.RectifiedLinear(), seed=<span class="number">2</span>)</span><br><span class="line">    nengo.Connection(a, b_rate)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># spiking神经元</span></span><br><span class="line">    b_spike = nengo.Ensemble(<span class="number">10</span>, <span class="number">1</span>, neuron_type=nengo.SpikingRectifiedLinear(), seed=<span class="number">2</span>)</span><br><span class="line">    nengo.Connection(a, b_spike)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟时取出输入输出数据</span></span><br><span class="line">    p_a = nengo.Probe(a)</span><br><span class="line">    p_rate = nengo.Probe(b_rate.neurons)</span><br><span class="line">    p_spike = nengo.Probe(b_spike.neurons)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> nengo_dl.Simulator(net) <span class="keyword">as</span> sim:</span><br><span class="line">    <span class="comment"># 运行模拟1S，上述Probe数据会被保存在sim.data字典中</span></span><br><span class="line">    sim.run_steps(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(sim.trange(), sim.data[p_a])</span><br><span class="line">plt.xlabel(<span class="string">"time"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"input value"</span>)</span><br><span class="line">plt.title(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(sim.trange(), sim.data[p_rate])</span><br><span class="line">plt.xlabel(<span class="string">"time"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"firing rate"</span>)</span><br><span class="line">plt.title(<span class="string">"b_rate"</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 时间栅格图，Spiking神经元的的脉冲事件出现与否以栅格形式展示</span></span><br><span class="line">rasterplot(sim.trange(), sim.data[p_spike])</span><br><span class="line">plt.xlabel(<span class="string">"time"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"neuron"</span>)</span><br><span class="line">plt.title(<span class="string">"b_spike"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上面代码运行的结果如下：</p><p><img src="/images/a.png" alt="a"></p><p><img src="/images/relu.png" alt="a"></p><p><img src="/images/raster.png" alt="a"></p><p>可以看到每个神经元的初始连接权重及bias不同，因此对输入信号的相应略有不同；spiking neurons会在电压超过0时产生脉冲发射事件，注意图二和图三中的颜色对应，我们还可以观察到电压值越高，对应的脉冲发射频率越高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SNN学习笔记4：-Nengo&quot;&gt;&lt;a href=&quot;#SNN学习笔记4：-Nengo&quot; class=&quot;headerlink&quot; title=&quot;SNN学习笔记4： Nengo&quot;&gt;&lt;/a&gt;SNN学习笔记4： Nengo&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://w</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="SNN, Deep Learning" scheme="http://yoursite.com/tags/SNN-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SNN[3]: Associative Learning</title>
    <link href="http://yoursite.com/2020/07/06/SNN-3-Synaptic-Plasticity/"/>
    <id>http://yoursite.com/2020/07/06/SNN-3-Synaptic-Plasticity/</id>
    <published>2020-07-06T03:25:03.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SNN学习笔记3：关联学习"><a href="#SNN学习笔记3：关联学习" class="headerlink" title="SNN学习笔记3：关联学习"></a>SNN学习笔记3：关联学习</h1><p>关联学习（Associative Learning）认为想法（神经元激活模式）和想法、想法和经历（外界刺激）会互相关联、互相强化。</p><p>关联在学习和认知中有着核心的地位，记忆实际上就是一种关联，很多认知功能的本质就是一层或多层的关联。</p><h2 id="赫布理论"><a href="#赫布理论" class="headerlink" title="赫布理论"></a>赫布理论</h2><p>突触（synaptic）用于连接多个神经元，其连接强度具有可以调整，这种可以调整的特性叫做突触可塑性（synaptic plasticity）。突触可塑性是记忆和学习的基础，赫布理论认为突触前的神经元对突触后神经元的反复刺激可以增加突触的传递效能，也就是强化了这两个神经元之间的连接。</p><p>赫布理论强调细胞A的激活导致了细胞B的激活以及两者之间连接的强化，这种先后/因果关系的理论也叫STDP(spike-timing-dependent plasticity)。</p><h2 id="STDP"><a href="#STDP" class="headerlink" title="STDP"></a>STDP</h2><p>STDP基于一个神经元的<strong>输入脉冲</strong>及<strong>输出脉冲</strong>间的相对时间来调整神经元间连接的强度。如果一个神经元的输入倾向于刚好出现在输出脉冲前，那么此神经元与输入神经元之间的连接倾向加强；如果一个神经元的输入倾向于刚好出现在输出脉冲之后，那么此神经元和输入神经元之间的连接倾向减弱。</p><p>通过上面的调整机制，可能是当前神经元激活的原因的输入会被强化；不是当前神经元激活原因的输入会被弱化。这个调整的过程最后会收敛到只有一部分连接保留下来，另一部分的连接强度降低到0，以此达到一种稀疏连接的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SNN学习笔记3：关联学习&quot;&gt;&lt;a href=&quot;#SNN学习笔记3：关联学习&quot; class=&quot;headerlink&quot; title=&quot;SNN学习笔记3：关联学习&quot;&gt;&lt;/a&gt;SNN学习笔记3：关联学习&lt;/h1&gt;&lt;p&gt;关联学习（Associative Learning）</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="SNN, Deep Learning" scheme="http://yoursite.com/tags/SNN-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SNN[2]: Neural Coding</title>
    <link href="http://yoursite.com/2020/07/05/SNN-2-Neural-Coding/"/>
    <id>http://yoursite.com/2020/07/05/SNN-2-Neural-Coding/</id>
    <published>2020-07-05T02:56:20.000Z</published>
    <updated>2021-04-24T15:10:52.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SNN学习笔记2：神经编码"><a href="#SNN学习笔记2：神经编码" class="headerlink" title="SNN学习笔记2：神经编码"></a>SNN学习笔记2：神经编码</h1><p>大脑中的感知细胞在受到光、声音等外界刺激时，其动作电位的激活序列会呈现出一定的时序模式。<a href="https://en.wikipedia.org/wiki/Neural_coding" target="_blank" rel="noopener">神经编码</a>认为大脑中的感知、认知等信息由神经元的激活表征，这些激活的各方面特征（时序 、强度等）不仅能够编码数字信号也能编码模拟信号。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="ISI"><a href="#ISI" class="headerlink" title="ISI"></a>ISI</h3><p>ISI(interspike intervals)，激活间间隙，表示两次激活中间间隔的时间的长度。虽然每次激活的持续时间、幅度和形状可能都有差异，但通常被处理为出现/不出现的点事件（point events）。</p><h3 id="神经编码"><a href="#神经编码" class="headerlink" title="神经编码"></a>神经编码</h3><p>神经编码（Neural Encoding）将外界输入刺激映射到神经元的反应，主要关注的是理解神经元如何对刺激作出反应，并建模来尝试<strong>预测</strong>神经元对其它刺激的反应。</p><h3 id="神经解码"><a href="#神经解码" class="headerlink" title="神经解码"></a>神经解码</h3><p>神经解码（Neural Decoding）关注的是编码的反向映射，也就是通过观察神经元的活动<strong>推导</strong>出对应的外界刺激。</p><h2 id="一些神经编码的理论"><a href="#一些神经编码的理论" class="headerlink" title="一些神经编码的理论"></a>一些神经编码的理论</h2><p>一系列的神经脉冲中包含了丰富的信息，不同编码理论侧重有所不同，在信息精度/浓度上也各有取舍。对不同功能的神经元，适用的编码也会不同。例如，对于控制肌肉收缩的运动细胞，基本只关心脉冲的发射频率（firing rate）。而对于处理复杂认知任务（例如，视觉、听觉）的神经细胞，每个脉冲出现的精确时间都包含了信息。</p><h3 id="频率编码（Rate-coding）"><a href="#频率编码（Rate-coding）" class="headerlink" title="频率编码（Rate coding）"></a>频率编码（Rate coding）</h3><p>频率编码模型将外界刺激的强度编码为脉冲的发射频率（firing rate），也就是外界的刺激越强，对应神经元的脉冲发射频率越高（通常是非线性变化）。频率编码假设外界刺激的绝大多数信息都包含在神经元的发射频率中，这是一种早期的编码方案，实验表明脉冲准确的时间中也包含了大量信息。</p><p>NOTE：目前发射频率没有一个公认的定义，常见的定义有：1）随时间平均 2）多次实验平均。</p><h4 id="频率编码：脉冲计数码率"><a href="#频率编码：脉冲计数码率" class="headerlink" title="频率编码：脉冲计数码率"></a>频率编码：脉冲计数码率</h4><p>脉冲计数码率（spike-count rate, a.k.a temporal average）由对一次实验中的脉冲数目进行计数，然后除以实验持续的时间得到。显然，这种平均只适合恒定或者变化较慢的外界刺激，对于变化较快的外界刺激意义不大。</p><h4 id="频率编码：时间相关发射率"><a href="#频率编码：时间相关发射率" class="headerlink" title="频率编码：时间相关发射率"></a>频率编码：时间相关发射率</h4><p>时间相关发射率（time-dependent firing rate）定义为<script type="math/tex">\frac{C_{t}^{t + \Delta t}spikes}{\Delta t}</script>,其中<script type="math/tex">C_t^{t + \Delta t}spikes</script>表示<script type="math/tex">t</script>到<script type="math/tex">\Delta t</script>之间的脉冲计数。和脉冲计数码率不同，时间相关发射率不仅可以处理常量刺激，也可以处理时间相关的刺激。</p><p>NOTE: 时间相关发射率依赖于有多个独立神经元，每个神经元接收同一种刺激的假设。</p><h3 id="时间编码（Temporal-coding）"><a href="#时间编码（Temporal-coding）" class="headerlink" title="时间编码（Temporal coding）"></a>时间编码（Temporal coding）</h3><p>与频率编码不同，在时间编码中，脉冲出现的准确时间或者发射频率的波动被认为是携带信息的。</p><h4 id="时间编码：二元编码"><a href="#时间编码：二元编码" class="headerlink" title="时间编码：二元编码"></a>时间编码：二元编码</h4><p>用二元符号来标记单位时间内是否有脉冲，1表示有脉冲，0表示没有。利用二元编码，我们可以区分频率编码中无法区分的序列，例如：0001110011和1110001100两者虽然频率一致，但是脉冲的时序显然不一样。</p><h4 id="时间编码：ISI"><a href="#时间编码：ISI" class="headerlink" title="时间编码：ISI"></a>时间编码：ISI</h4><p>ISI利用激活间的区间长度来编码激活序列。</p><h4 id="时间编码：稀疏编码"><a href="#时间编码：稀疏编码" class="headerlink" title="时间编码：稀疏编码"></a>时间编码：稀疏编码</h4><p>对神经元的每次强激活单独编码，通常用线性生成模型来描述（Linear Generative Model）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SNN学习笔记2：神经编码&quot;&gt;&lt;a href=&quot;#SNN学习笔记2：神经编码&quot; class=&quot;headerlink&quot; title=&quot;SNN学习笔记2：神经编码&quot;&gt;&lt;/a&gt;SNN学习笔记2：神经编码&lt;/h1&gt;&lt;p&gt;大脑中的感知细胞在受到光、声音等外界刺激时，其动作电</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="SNN, Deep Learning" scheme="http://yoursite.com/tags/SNN-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SNN[1]: LIF</title>
    <link href="http://yoursite.com/2020/07/03/SNN-1-LIF/"/>
    <id>http://yoursite.com/2020/07/03/SNN-1-LIF/</id>
    <published>2020-07-03T09:15:25.000Z</published>
    <updated>2021-04-24T15:10:40.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SNN学习笔记1：LIF"><a href="#SNN学习笔记1：LIF" class="headerlink" title="SNN学习笔记1：LIF"></a>SNN学习笔记1：LIF</h1><h2 id="什么是SNN？"><a href="#什么是SNN？" class="headerlink" title="什么是SNN？"></a>什么是SNN？</h2><p><a href="https://en.wikipedia.org/wiki/Spiking_neural_network" target="_blank" rel="noopener">SNN</a>（Spiking neural network，脉冲神经网络）号称是第三代神经网络, 与当前流行的神经网络的主要区别是将神经脉冲传播的动态过程纳入学习和推理中。SNN中的神经元不会在每次传播中都激活，而是只有当神经元的膜电位超过阈值时才激活，在激活时发射电脉冲（spikes，神经科学中常称作动作电位），这些电脉冲通过轴突传递给其它的神经元。</p><p>因此， 神经元的膜电位的变化的描述变得十分重要。下面介绍几种描述膜电位变化的模型。</p><h3 id="Integrate-and-fire"><a href="#Integrate-and-fire" class="headerlink" title="Integrate-and-fire"></a>Integrate-and-fire</h3><p>Integrate-and-fire是最早用来描述膜电位变化的模型（1907年！），神经元膜电位的变化由下面的公式表示:</p><script type="math/tex; mode=display">I(t) = C_m \frac{dV_m(t)}{dt}</script><p>$C_m$ 表示神经元的电容, 我们容易看出上式只是电容公式Q=CV两边同时对时间求导。</p><p>此模型有如下性质：当有电流输入时，膜电位将会升高。</p><h4 id="不应期"><a href="#不应期" class="headerlink" title="不应期"></a>不应期</h4><p>通过增加不应期（refractory period）<script type="math/tex">t_{ref}</script>可以使Integrate-and-fire模型更加精准。所谓不应期，就是在此期间神经元无法激活，这一现象在实际的神经元中已经被观察到，微观上可以由<a href="https://www.youtube.com/watch?v=Gsf9IB-wQdU" target="_blank" rel="noopener">钠钾离子通道的状态</a>来解释。</p><p>不应期限制了神经元激活的频率，激活频率与不应期<script type="math/tex">t_{ref}</script>的关系如下：</p><script type="math/tex; mode=display">f(I) = \frac{I}{C_mV_{th} + t_{ref}I}</script><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>一个显著的缺点是，上述模型没有实现时间相关记忆（time-dependent memory）,即如果这个模型收到一个远超阈值的信号时，会永远将此信号记在自己的膜电位中。</p><h3 id="LIF"><a href="#LIF" class="headerlink" title="LIF"></a>LIF</h3><p><a href="https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire" target="_blank" rel="noopener">LIF</a>(Leaky integrate-and-fire)通过增加“漏电（Leaky）”项解决了Integrate-and-fire模型中缺少时间相关记忆的问题。模型的公式如下：</p><script type="math/tex; mode=display">I(t) - \frac{V_m(t)}{R_m} = C_m \frac{dV_m(t)}{dt}</script><p>“漏电”项<script type="math/tex">\frac{V_m(t)}{R_m}</script>中的<script type="math/tex">R_m</script>表示膜电阻。</p><p>公式蕴含了下面这些有趣的性质：</p><ol><li>激活神经元的输入电流必须超过<script type="math/tex">I_{th} = \frac{V_{th}}{R_m}</script>, 否则漏电项会导致膜电位泄露</li><li>大电流输入时，模型趋近于Integrate-and-fire+不应期</li></ol><h2 id="LIF-Nengo实现"><a href="#LIF-Nengo实现" class="headerlink" title="LIF: Nengo实现"></a>LIF: Nengo实现</h2><p>Nengo是一个SNN相关的库，利用Nengo可以很容易实现上述LIF模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> nengo</span><br><span class="line"><span class="keyword">from</span> nengo.utils.matplotlib <span class="keyword">import</span> rasterplot</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> nengo.dists <span class="keyword">import</span> Uniform</span><br><span class="line"></span><br><span class="line">model = nengo.Network(label=<span class="string">"A Single Neuron"</span>)</span><br><span class="line"><span class="keyword">with</span> model:</span><br><span class="line">    neuron = nengo.Ensemble(<span class="number">1</span>, dimensions=<span class="number">1</span>, intercepts=Uniform(<span class="number">-.5</span>, <span class="number">-.5</span>), max_rates=Uniform(<span class="number">100</span>, <span class="number">100</span>), encoders=[[<span class="number">1</span>]])</span><br><span class="line">    <span class="comment"># input node</span></span><br><span class="line">    cos = nengo.Node(<span class="keyword">lambda</span> t: np.cos(<span class="number">8</span>*t))</span><br><span class="line">    nengo.Connection(cos, neuron)</span><br><span class="line">    cos_probe = nengo.Probe(cos)</span><br><span class="line">    <span class="comment"># 神经元原始脉冲输出</span></span><br><span class="line">    spikes = nengo.Probe(neuron.neurons)</span><br><span class="line">    <span class="comment"># 细胞体电压</span></span><br><span class="line">    voltage = nengo.Probe(neuron.neurons, <span class="string">"voltage"</span>)</span><br><span class="line">    <span class="comment"># spikes filtered by a 10ms post-synaptic filter</span></span><br><span class="line">    filtered = nengo.Probe(neuron, synapse=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> nengo.Simulator(model) <span class="keyword">as</span> sim:</span><br><span class="line">    sim.run(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># plot the decoded output of the ensemble</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(sim.trange(), sim.data[filtered])</span><br><span class="line">    plt.plot(sim.trange(), sim.data[cos_probe])</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot the spiking output of the ensemble</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    rasterplot(sim.trange(), sim.data[spikes])</span><br><span class="line">    plt.ylabel(<span class="string">"Neuron"</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot the soma voltages of the neurons</span></span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.plot(sim.trange(), sim.data[voltage][:,<span class="number">0</span>], <span class="string">'r'</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SNN学习笔记1：LIF&quot;&gt;&lt;a href=&quot;#SNN学习笔记1：LIF&quot; class=&quot;headerlink&quot; title=&quot;SNN学习笔记1：LIF&quot;&gt;&lt;/a&gt;SNN学习笔记1：LIF&lt;/h1&gt;&lt;h2 id=&quot;什么是SNN？&quot;&gt;&lt;a href=&quot;#什么是SNN</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="SNN, Deep Learning" scheme="http://yoursite.com/tags/SNN-Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>rvalue reference and emplace</title>
    <link href="http://yoursite.com/2020/07/03/rvalue-reference-and-emplace/"/>
    <id>http://yoursite.com/2020/07/03/rvalue-reference-and-emplace/</id>
    <published>2020-07-03T03:37:11.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="右值引用和emplace"><a href="#右值引用和emplace" class="headerlink" title="右值引用和emplace"></a>右值引用和emplace</h1><p>这篇文章初衷是好奇<code>push_back</code>和<code>emplace_back</code>的区别，了解之后发现绕不开右值引用，在此一并记录一下。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用（<code>rvalue reference</code>）是C++11中引入的新特性，显然是与C++11之前普通左值引用相对的一个概念。下面的右值引用的介绍很多参考自<a href="http://thbecker.net/articles/rvalue_references/section_02.html" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>一个粗略的定义如下：</p><p>左值是一个可以出现在赋值符号（<code>=</code>）左边或者右边的表达式, 可以理解为对一块内存的引用；</p><p>右值是一个只能出现在赋值符号右边的表达式， 注意右值不是对内存的引用，因此不能进行取地址操作。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">43</span>;</span><br><span class="line"><span class="comment">// a, b 均为左值</span></span><br><span class="line">a = b;</span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// a + b 为右值</span></span><br><span class="line"><span class="keyword">int</span> c = a  + b;</span><br><span class="line">a + b = <span class="number">42</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">// 不能对右值取地址</span></span><br><span class="line">a  = foo(); <span class="comment">// ok, foo() is a rvalue</span></span><br><span class="line"><span class="keyword">int</span>* p = &amp;foo(); <span class="comment">// invalid, 不能对右值取地址</span></span><br></pre></td></tr></table></figure><h3 id="为什么要右值引用？"><a href="#为什么要右值引用？" class="headerlink" title="为什么要右值引用？"></a>为什么要右值引用？</h3><h4 id="move语义"><a href="#move语义" class="headerlink" title="move语义"></a>move语义</h4><p>假设类X中包括一个指向资源的指针<code>m_pResource</code>，我们想实现一个接收<strong>临时对象</strong>作为参数的拷贝赋值操作符，其实现可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(<span class="keyword">const</span> X &amp;rhs) &#123;</span><br><span class="line">  <span class="comment">//1. 拷贝rhs.m_pResource</span></span><br><span class="line">  <span class="comment">//2. 析构rhs.m_pResource指向的资源</span></span><br><span class="line">  <span class="comment">//3. 将拷贝的资源赋给self.m_pResource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，上面对资源<code>m_pResource</code>的拷贝和析构十分低效，我们可以直接和临时实例交换指针（此所谓move语义）。另外，对于非临时对象的拷贝，我们可能不想析构其资源。因此我们需要一个类型来标识这样的临时对象，对它进行单独的处理，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::operator&#x3D;( &lt;Desired type&gt;rhs) &#123;</span><br><span class="line">  &#x2F;&#x2F;1. swap this-&gt;m_pResource and rhs.m_pResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实右值引用就是我们想要的类型，上面代码中的<code>&lt;Desired type&gt;</code>我们可以用<code>X&amp;&amp;</code>替代，表示是X的右值引用。</p><h2 id="emplace-back-or-push-back"><a href="#emplace-back-or-push-back" class="headerlink" title="emplace_back or push_back?"></a>emplace_back or push_back?</h2><h3 id="一个小实验"><a href="#一个小实验" class="headerlink" title="一个小实验"></a>一个小实验</h3><p>猜猜看下面的代码会进行几次复制操作？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> x, y;</span><br><span class="line">  Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">const</span> Point&amp; <span class="built_in">point</span>):x(<span class="built_in">point</span>.x), y(<span class="built_in">point</span>.y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; points;</span><br><span class="line">  points.push_back(Point(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  points.push_back(Point(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">  points.push_back(Point(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是六次，其中三次是将临时<code>Point</code>对象拷贝至容器，有一次是容器容量从1到2的拷贝，有两次是容器容量从2到4的拷贝。</p><h4 id="消除扩容拷贝"><a href="#消除扩容拷贝" class="headerlink" title="消除扩容拷贝"></a>消除扩容拷贝</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> x, y;</span><br><span class="line">  Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">const</span> Point&amp; <span class="built_in">point</span>):x(<span class="built_in">point</span>.x), y(<span class="built_in">point</span>.y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; points;</span><br><span class="line">  <span class="comment">// 预分配内存 <span class="doctag">NOTE:</span> 和std::vector&lt;Point&gt; points(3)的区别，reserve只分配内存不调用构造函数</span></span><br><span class="line">  points.reserve(<span class="number">3</span>);</span><br><span class="line">  points.push_back(Point(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  points.push_back(Point(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">  points.push_back(Point(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在只用进行三次插入容器时的拷贝</p><h4 id="move语义消除插入容器时的拷贝"><a href="#move语义消除插入容器时的拷贝" class="headerlink" title="move语义消除插入容器时的拷贝"></a>move语义消除插入容器时的拷贝</h4><p>直接将参数forward给容器，直接在容器中构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> x, y;</span><br><span class="line">  Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">const</span> Point&amp; <span class="built_in">point</span>):x(<span class="built_in">point</span>.x), y(<span class="built_in">point</span>.y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; points;</span><br><span class="line">  points.emplace_back(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  points.emplace_back(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  points.emplace_back(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在拷贝的次数为0次！</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>首先看看C++11中两者的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_back</span>( <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, Allocator&gt;::push_back( <span class="keyword">const</span> T&amp; value );</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, Allocator&gt;::push_back( T&amp;&amp; value );</span><br></pre></td></tr></table></figure><p>注意到接收右值的接口的差别，push_back只能接收Vector中存储类型的右值作为参数，而emplace可以接收变长模板作为参数，尝试为变长模板找到最合适的构造函数直接在容器中构建。</p><p>NOTE：实验中的例子，emplace_back的变长参数也可以接收<code>Point</code>对象，此时会先调用Point的默认构造函数然后调用复制构造函数。对应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> x, y;</span><br><span class="line">  Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">const</span> Point&amp; <span class="built_in">point</span>):x(<span class="built_in">point</span>.x), y(<span class="built_in">point</span>.y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; points;</span><br><span class="line">  points.reserve(<span class="number">3</span>);</span><br><span class="line">  points.emplace_back(Point(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  points.emplace_back(Point(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">  points.emplace_back(Point(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;右值引用和emplace&quot;&gt;&lt;a href=&quot;#右值引用和emplace&quot; class=&quot;headerlink&quot; title=&quot;右值引用和emplace&quot;&gt;&lt;/a&gt;右值引用和emplace&lt;/h1&gt;&lt;p&gt;这篇文章初衷是好奇&lt;code&gt;push_back&lt;/code</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>pybind11 install</title>
    <link href="http://yoursite.com/2020/07/02/pybind11-install/"/>
    <id>http://yoursite.com/2020/07/02/pybind11-install/</id>
    <published>2020-07-02T11:26:50.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pybind11-安装及简单使用"><a href="#Pybind11-安装及简单使用" class="headerlink" title="Pybind11 安装及简单使用"></a>Pybind11 安装及简单使用</h1><p>之前项目里用到了pybind11，效果强大&amp;很好用。但是由于那个项目整个工程直接包含了pybind11的头文件和构建脚本，因此无需自己动手折腾pybind11的环境和构建。最近自己想用pybind11做些POC的小实验，在此记录一些搭建环境的过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>依赖安装：<code>sudo apt-get install python-dev cmake</code></li><li>pybind11 python: <code>conda install pybind11</code></li><li>pybind11 安装：<ol><li>下载repo：<code>git clone https://github.com/pybind/pybind11.git</code></li><li><code>cd pybind11</code></li><li><code>mkdir build</code></li><li><code>cd build</code></li><li><code>cmake ..</code></li><li><code>make check -j8</code></li></ol></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>尝试编译官网的玩具样例，代码如下（保存到文件<code>toy.cc</code>）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">  m.doc() = <span class="string">"pybind11 example plugin"</span>;</span><br><span class="line">  m.def(<span class="string">"add"</span>, &amp;add, <span class="string">"A function which adds two numbers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ -O3 -Wall -shared -std&#x3D;c++11 -fPIC &#96;python3 -m pybind11 --includes&#96; toy.cc -o shared&#96;python3-config --extension-suffix&#96;</span><br></pre></td></tr></table></figure><p>NOTE: 上述命令初看很唬人，我们尝试运行一下<code>python3 -m pybind11 --includes</code>和<code>python3-config --extension-suffix</code>, 得到的结果如下：<code>-I/home/xxx/anaconda3/envs/mindspore/include/python3.7m -I/home/xxx/anaconda3/envs/mindspore/include</code>, <code>.cpython-37m-x86_64-linux-gnu.so</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pybind11-安装及简单使用&quot;&gt;&lt;a href=&quot;#Pybind11-安装及简单使用&quot; class=&quot;headerlink&quot; title=&quot;Pybind11 安装及简单使用&quot;&gt;&lt;/a&gt;Pybind11 安装及简单使用&lt;/h1&gt;&lt;p&gt;之前项目里用到了pybind</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="pybind11, c++, python" scheme="http://yoursite.com/tags/pybind11-c-python/"/>
    
  </entry>
  
  <entry>
    <title>expression template and CRTP</title>
    <link href="http://yoursite.com/2020/07/01/expression-template/"/>
    <id>http://yoursite.com/2020/07/01/expression-template/</id>
    <published>2020-07-01T00:52:02.000Z</published>
    <updated>2021-04-24T13:57:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式模板和静态多态"><a href="#表达式模板和静态多态" class="headerlink" title="表达式模板和静态多态"></a>表达式模板和静态多态</h1><p>表达式模板（<a href="https://www.en.wikipedia.org/wiki/Expression_templates" target="_blank" rel="noopener">expression template</a>）是一种模板元编程技术，在编译期间延迟计算的求值，并构造表达计算的结构（expression tree）。利用expression tree的变换，可以实现运行前的自动循环融合（loop fusion）等功能。</p><p>静态多态（也叫<a href="https://www.en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">CRTP</a>）用一个模板基类来在编译期完成多态的实际实现的分发(与运行时使用<code>virtual</code> <code>override</code>的多态机制相对, 因此叫静态多态)，不同类型的子类将自身类型作为基类的模板参数来继承，以此通知基类将对应类型的调用分发给自己。静态多态消除了动态多态的开销，可以提升运行时性能，经常和表达式模板一起使用。</p><h2 id="静态多态demo"><a href="#静态多态demo" class="headerlink" title="静态多态demo"></a>静态多态demo</h2><p>下面以一个简单demo展示上述静态多态的原理和用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;Say_();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> :</span> Animal&lt;Dog&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Say_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wang wang wang!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> :</span> Animal&lt;Cat&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Say_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"meow meow meow~"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">AddAnimal</span>(<span class="title">Animal</span>&lt;T&gt; <span class="title">animal</span>) &#123;</span></span><br><span class="line">    animal.Say();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Dog dog&#123;&#125;;</span><br><span class="line">  Cat cat&#123;&#125;;</span><br><span class="line">  Zoo zoo&#123;&#125;;</span><br><span class="line">  zoo.AddAnimal(dog);</span><br><span class="line">  zoo.AddAnimal(cat);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式模板demo"><a href="#表达式模板demo" class="headerlink" title="表达式模板demo"></a>表达式模板demo</h2><p><a href="https://www.en.wikipedia.org/wiki/Expression_templates" target="_blank" rel="noopener">wiki</a>上给出了一个表达式模板很好的例子，对vector加法进行循环融合。原理大致如下：</p><ol><li>将+法操作符封装为表达式求和类型VecSum的构造函数，因此在+法时不进行实际的求值，而是进行表达式树的构建</li><li>在对Vec进行赋值操作时进行表达式求值，此时对VecSum表达式中的<code>[]</code>操作符递归调用，直到完成实际的求和。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VecExpression</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;E <span class="keyword">const</span>&amp;&gt;(*<span class="keyword">this</span>)[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;E <span class="keyword">const</span>&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">size</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec</span> :</span> <span class="keyword">public</span> VecExpression&lt;Vec&gt; &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; elems;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> elems[i];&#125;</span><br><span class="line">  <span class="keyword">double</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) &#123; <span class="keyword">return</span> elems[i]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> elems.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line">  Vec(<span class="keyword">size_t</span> n) : elems(n) &#123;&#125;</span><br><span class="line">  Vec(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; init) : elems(init) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从VecExpression构建Vec, 此时对表达式求值</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">  Vec(VecExpression&lt;E&gt; <span class="keyword">const</span>&amp; expr) : elems(expr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != expr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      elems[i] = expr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : elems) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态多态</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VecSum</span> :</span> <span class="keyword">public</span> VecExpression&lt;VecSum&lt;E1, E2&gt;&gt; &#123;</span><br><span class="line">  E1 <span class="keyword">const</span>&amp; _u;</span><br><span class="line">  E2 <span class="keyword">const</span>&amp; _v;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  VecSum(E1 <span class="keyword">const</span> &amp;u, E2 <span class="keyword">const</span> &amp;v) : _u(u), _v(v) &#123;</span><br><span class="line">    assert(u.<span class="built_in">size</span>() == v.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// Vec的构造函数中被调用，此时求值</span></span><br><span class="line">  <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _u[i] + _v[i]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _v.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将VecSum的构造函数封装成+运算符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line">VecSum&lt;E1, E2&gt; <span class="keyword">operator</span>+(VecExpression&lt;E1&gt; <span class="keyword">const</span> &amp;u, VecExpression&lt;E2&gt; <span class="keyword">const</span> &amp;v) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> VecSum&lt;E1, E2&gt;(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> E1*&gt;(&amp;u), *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> E2*&gt;(&amp;v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vec v0 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  Vec v1 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  Vec v2 = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  Vec v3 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">  Vec sum = v0 + v1 + v2 + v3;</span><br><span class="line">  sum.dump();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; Vec; E2 &#x3D; Vec]</span><br><span class="line">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;Vec, Vec&gt;; E2 &#x3D; Vec]</span><br><span class="line">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;VecSum&lt;Vec, Vec&gt;, Vec&gt;; E2 &#x3D; Vec]</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表达式模板和静态多态&quot;&gt;&lt;a href=&quot;#表达式模板和静态多态&quot; class=&quot;headerlink&quot; title=&quot;表达式模板和静态多态&quot;&gt;&lt;/a&gt;表达式模板和静态多态&lt;/h1&gt;&lt;p&gt;表达式模板（&lt;a href=&quot;https://www.en.wikipedi</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
</feed>
