{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/a.png","path":"images/a.png","modified":0,"renderable":0},{"_id":"source/images/raster.png","path":"images/raster.png","modified":0,"renderable":0},{"_id":"source/images/relu.png","path":"images/relu.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"source/images/ecosystem.svg","path":"images/ecosystem.svg","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/lca.png","path":"images/lca.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1593485039402},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1593485039402},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1593485039402},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1593485039402},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1593485039402},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1593485039402},{"_id":"source/_posts/SNN-1-LIF.md","hash":"5f8c7f2a7b7e0420e61896934579c69f6b503563","modified":1593918574145},{"_id":"source/_posts/SNN-2-Neural-Coding.md","hash":"4691c43e4387f2f6395f5123a67d75663f96ff2f","modified":1594005057718},{"_id":"source/_posts/SNN-3-Synaptic-Plasticity.md","hash":"7596437eb40c3b066cc34c3682271a0042f5b844","modified":1594020378490},{"_id":"source/_posts/SNN-4-Nengo.md","hash":"37695135baba0b412b3b3ccbb6a9b1301a73d708","modified":1594087819447},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1593485023794},{"_id":"source/_posts/pybind11-install.md","hash":"31618a72022d587a04696eed9b0cc028b7fc5213","modified":1593691546617},{"_id":"source/images/a.png","hash":"2346bb730e41ece2567fae858b6b54c52d3cc97b","modified":1594087085359},{"_id":"source/images/raster.png","hash":"2a8862d4d802f6704c9666a86c6e587e8fccc2d2","modified":1594087054327},{"_id":"source/_posts/expression-template.md","hash":"3314fd17fc468825b6d2aa722e2c79f2c5c21ad9","modified":1593574708876},{"_id":"source/_posts/cpp-variadic-template.md","hash":"593a40ad9078eb35afaed8951053b6bbafa9c2e3","modified":1593519099004},{"_id":"source/_posts/rvalue-reference-and-emplace.md","hash":"5fdd5d227f20e55d842b74cbfd8b49db6f6cbb05","modified":1593765648139},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1593485039402},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1593485039402},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1593485039402},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1593485039402},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1593485039402},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1593485039402},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1593485039402},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1593485039402},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1593485039402},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1593485039402},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1593485039402},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1593485039402},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1593485039402},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1593485039402},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1593485039402},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1593485039402},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593485039402},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593485039402},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1593485039402},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1593485039402},{"_id":"source/images/relu.png","hash":"a56eb60a13434cc915a331ff69899c569b5e7f89","modified":1594087069395},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1593485039402},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1593485039402},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1593485039402},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1593485039402},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1593485039402},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1593485039402},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1593485039406},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1593485039410},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1593485039410},{"_id":"source/images/ecosystem.svg","hash":"41cbe4b5b85afaa1a9f4e40e272efaccda72d668","modified":1594026372011},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1593485039402},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1593485039402},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1593485039402},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1593485039402},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1593485039402},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1593485039406},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1593485039406},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1593485039406},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1593485039410},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1593485039410},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1593485039406},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1593485039410},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1593485039406},{"_id":"public/2020/07/06/SNN-3-Synaptic-Plasticity/index.html","hash":"2b08674043bad5bc3ef1c827c0b775912add7b2a","modified":1599462922974},{"_id":"public/2020/07/05/SNN-2-Neural-Coding/index.html","hash":"3ec090030a48424334b4adef2f5590b3da6fc17a","modified":1599462922974},{"_id":"public/2020/07/02/pybind11-install/index.html","hash":"3589f351c3081be67553a8628516af01593f5e5c","modified":1599462922974},{"_id":"public/2020/06/30/hello-world/index.html","hash":"558a78de80720f173d4551c51b819dc795d8b488","modified":1599462922974},{"_id":"public/archives/index.html","hash":"1ac69b4feb963e2426a6715324ca20d50fc80770","modified":1599462922974},{"_id":"public/archives/2020/index.html","hash":"865c717b680d284410f350e2a9dc9eb4f81ce059","modified":1599462922974},{"_id":"public/archives/2020/06/index.html","hash":"d9ee3560fe8a8dcaab499b4cef739673d6f76f19","modified":1599462922974},{"_id":"public/archives/2020/07/index.html","hash":"fddc2df0c12987b8f9450bf7ae547a8e2caef6d5","modified":1599462922974},{"_id":"public/categories/AI/index.html","hash":"5c75fd25f32fb509efffa7fd23ace4dcd9739cd6","modified":1599462922974},{"_id":"public/categories/编程/index.html","hash":"b578b6e2422ecac8922de20eed4fe6f1930ffb56","modified":1599462922974},{"_id":"public/tags/SNN-Deep-Learning/index.html","hash":"483813627cb66cb8f5a7cdd6335a09c795669bf7","modified":1599462922974},{"_id":"public/tags/pybind11-c-python/index.html","hash":"5a8102106c4edbdcc99f1f9085f6f0e81392b9db","modified":1599462922974},{"_id":"public/tags/c/index.html","hash":"012fa5f99f86d4de876a80a4ee6ee9b7786f46cf","modified":1599462922974},{"_id":"public/2020/07/06/SNN-4-Nengo/index.html","hash":"926980c4a5f4d0c947ffc8f6f9fef27cdf88ab58","modified":1599462922974},{"_id":"public/2020/07/03/SNN-1-LIF/index.html","hash":"d349c883663d4b869de6ba19ffa7273127d12cae","modified":1599462922974},{"_id":"public/2020/07/03/rvalue-reference-and-emplace/index.html","hash":"fff61871d42ddb8ad58f5e65976e59fa64eda76b","modified":1599462922974},{"_id":"public/2020/07/01/expression-template/index.html","hash":"ac4bddf2cf613c0a0daea67fe70095133d3e1787","modified":1599462922974},{"_id":"public/2020/06/30/cpp-variadic-template/index.html","hash":"b6bd02cdb82e889d29240cb8f24270b9c251ba8f","modified":1599462922974},{"_id":"public/index.html","hash":"d8bf36573c8e6bff541a55cc9ea99187d38f88f9","modified":1599462922974},{"_id":"public/images/a.png","hash":"2346bb730e41ece2567fae858b6b54c52d3cc97b","modified":1594088732648},{"_id":"public/images/raster.png","hash":"2a8862d4d802f6704c9666a86c6e587e8fccc2d2","modified":1594088732648},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1594088732648},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1594088732648},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1594088732648},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1594088732648},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1594088732648},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1594088732648},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1594088732648},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1594088732648},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1594088732648},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1594088732648},{"_id":"public/images/relu.png","hash":"a56eb60a13434cc915a331ff69899c569b5e7f89","modified":1594088732648},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1594088732648},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1594088732648},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1594088732648},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1594088732648},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1594088732648},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1594088732648},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1594088732648},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1594088732648},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1594088732648},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1594088732648},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1594088732648},{"_id":"public/images/ecosystem.svg","hash":"41cbe4b5b85afaa1a9f4e40e272efaccda72d668","modified":1594088732648},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1594088732648},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1594088732648},{"_id":"source/_posts/SNN-5-LCA.md","hash":"2db3014539538ba3ce86b88a179160faf473e7dd","modified":1594524501194},{"_id":"public/2020/07/07/SNN-5-LCA/index.html","hash":"3982738a6414654b9aa16933ba237ca647d44d1e","modified":1599462922974},{"_id":"source/images/lca.png","hash":"68f337a2396ddfab672575e90f6e8daa40ca1f46","modified":1594519560102},{"_id":"public/images/lca.png","hash":"68f337a2396ddfab672575e90f6e8daa40ca1f46","modified":1594524531930},{"_id":"source/_posts/Tensorflow-Graph-Matcher.md","hash":"4f01fd63c6d50834ad213a482657e93bb97564e8","modified":1595313263753},{"_id":"public/2020/07/20/Tensorflow-Graph-Matcher/index.html","hash":"066e52ed5470d01600e8766d60f0706f690a1c68","modified":1599462922974},{"_id":"public/archives/page/2/index.html","hash":"da590412f0b8b87e2c9f311cfe9f3eed01d66744","modified":1599462922974},{"_id":"public/archives/2020/page/2/index.html","hash":"4ca76e313b43417fbd9ce22a73f3d6fd0efb5452","modified":1599462922974},{"_id":"public/page/2/index.html","hash":"0b22cf396fbf8003de659df37bc98072fa52d71c","modified":1599462922974},{"_id":"public/tags/TensorFlow-Deep-Learning/index.html","hash":"a3d87621da71b8dd8f3366cc12973d56be954b3d","modified":1599462922974},{"_id":"source/_posts/Bonfire.md","hash":"10e98327df4252b066f9c8a7ef400a1038a79b60","modified":1595736848447},{"_id":"public/2020/07/26/Bonfire/index.html","hash":"290514c161b40de53fd95895f46b9617a0decd5e","modified":1599462922974},{"_id":"public/tags/Mood/index.html","hash":"32ca7e57a9ae5851acf0a8cf9062433f1f6c2c7f","modified":1599462922974},{"_id":"source/_posts/Pybind11-Type-Conversions.md","hash":"7695cc18b55282eaad98f7c5e6f604e3c9d5077f","modified":1595822488342},{"_id":"public/archives/2020/07/page/2/index.html","hash":"938a5e047f91068ac5e04658429450d2172ef168","modified":1599462922974},{"_id":"public/2020/07/27/Pybind11-Type-Conversions/index.html","hash":"b15013807edd729b7e8a66a6af8a48de9356475c","modified":1599462922974},{"_id":"source/_posts/Pybind11-classes.md","hash":"c322dc1e9c74077851572aa3a0b5f08c21546c98","modified":1595850713404},{"_id":"public/2020/07/27/Pybind11-classes/index.html","hash":"1b0eedb4d77a6b2bd5c36b369a409b29f7129270","modified":1599462922974},{"_id":"source/_posts/Python-Pass.md","hash":"e9c792183fd2a912373e737d0fa828f9e1606b23","modified":1597373525678},{"_id":"public/2020/08/09/Python-Pass/index.html","hash":"839fd838f9543eafe8035a5a40abfe6a9779f8d4","modified":1599462922974},{"_id":"public/archives/2020/08/index.html","hash":"fd2f18adec7dda94d9dd7809f2f07aaca340d20b","modified":1599462922974},{"_id":"public/tags/Mindspore-Python-Optimizer-C/index.html","hash":"3fb35d2f6089be56581503191a426a3816fdbc48","modified":1599462922974},{"_id":"source/_posts/C-Performance-Trick-OutOfLine-Pattern.md","hash":"a59fe18aaa9106ae102a53ace9144afa5b58b5ea","modified":1598184501480},{"_id":"public/tags/Performance-C/index.html","hash":"160df8e9accbe4267aedb3a2500d80d0d69a643a","modified":1599462922974},{"_id":"public/2020/08/14/C-Performance-Trick-OutOfLine-Pattern/index.html","hash":"3d17bd587a7485d80c90d9af15f7f8ee379d6b56","modified":1599462922974},{"_id":"source/_posts/two-list-system.md","hash":"680c1ec33f50e9c6a63ecb6ea7638e8d607b77ac","modified":1598185500391},{"_id":"public/2020/08/23/two-list-system/index.html","hash":"13e2f26fc8875bee0ccfbdbd318ef9621175f19d","modified":1599462922974},{"_id":"public/tags/mind-hack/index.html","hash":"a63233ba5cc1447aa4c7a04c14c7c381d4fbcfcf","modified":1599462922974},{"_id":"source/_posts/LLVM0.md","hash":"d02da110584364237b7120227db8d717b910e23e","modified":1599462918258},{"_id":"source/_posts/Taichi0.md","hash":"67d1be07cc0e6c2f3a6434bd1f86893c1aa52b03","modified":1599445763232},{"_id":"public/2020/09/07/LLVM0/index.html","hash":"79e9889001a429b3d31692225da52eee2fefb132","modified":1599462922974},{"_id":"public/2020/08/31/Taichi0/index.html","hash":"2a081d82bdd9e8e421b04f0069d51d3d0de0b7fa","modified":1599462922974},{"_id":"public/archives/2020/09/index.html","hash":"5007aca400aeda2b938151007452cae2a2d5f4c6","modified":1599462922974},{"_id":"public/tags/LLVM-compiler/index.html","hash":"7741c8c8b883d587d09d17bc41d0ce11022fabdb","modified":1599462922974},{"_id":"public/tags/太极-rendering/index.html","hash":"0f24419bffebd5148a30760c0172718e55d7dfbf","modified":1599462922974}],"Category":[{"name":"AI","_id":"ckcbb9ucm0002ys1dhihe1ujk"},{"name":"编程","_id":"ckcbb9ucu000jys1d7w05fhto"}],"Data":[],"Page":[],"Post":[{"title":"SNN[1]: LIF","date":"2020-07-03T09:15:25.000Z","mathjax":true,"_content":"\n# SNN学习笔记1：LIF\n\n## 什么是SNN？\n\n[SNN](https://en.wikipedia.org/wiki/Spiking_neural_network)（Spiking neural network，脉冲神经网络）号称是第三代神经网络, 与当前流行的神经网络的主要区别是将神经脉冲传播的动态过程纳入学习和推理中。SNN中的神经元不会在每次传播中都激活，而是只有当神经元的膜电位超过阈值时才激活，在激活时发射电脉冲（spikes，神经科学中常称作动作电位），这些电脉冲通过轴突传递给其它的神经元。\n\n因此， 神经元的膜电位的变化的描述变得十分重要。下面介绍几种描述膜电位变化的模型。\n\n### Integrate-and-fire\n\nIntegrate-and-fire是最早用来描述膜电位变化的模型（1907年！），神经元膜电位的变化由下面的公式表示:\n$$\nI(t) = C_m \\frac{dV_m(t)}{dt}\n$$\n$C_m$ 表示神经元的电容, 我们容易看出上式只是电容公式Q=CV两边同时对时间求导。\n\n此模型有如下性质：当有电流输入时，膜电位将会升高。\n\n#### 不应期\n\n通过增加不应期（refractory period）$t_{ref}$可以使Integrate-and-fire模型更加精准。所谓不应期，就是在此期间神经元无法激活，这一现象在实际的神经元中已经被观察到，微观上可以由[钠钾离子通道的状态](https://www.youtube.com/watch?v=Gsf9IB-wQdU)来解释。\n\n不应期限制了神经元激活的频率，激活频率与不应期$t_{ref}$的关系如下：\n$$\nf(I) = \\frac{I}{C_mV_{th} + t_{ref}I}\n$$\n\n#### 缺点\n\n一个显著的缺点是，上述模型没有实现时间相关记忆（time-dependent memory）,即如果这个模型收到一个远超阈值的信号时，会永远将此信号记在自己的膜电位中。\n\n### LIF\n\n[LIF](https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire)(Leaky integrate-and-fire)通过增加“漏电（Leaky）”项解决了Integrate-and-fire模型中缺少时间相关记忆的问题。模型的公式如下：\n$$\nI(t) - \\frac{V_m(t)}{R_m} = C_m \\frac{dV_m(t)}{dt}\n$$\n“漏电”项$\\frac{V_m(t)}{R_m}$中的$R_m$表示膜电阻。\n\n公式蕴含了下面这些有趣的性质：\n\n1. 激活神经元的输入电流必须超过$I_{th} = \\frac{V_{th}}{R_m}$, 否则漏电项会导致膜电位泄露\n2. 大电流输入时，模型趋近于Integrate-and-fire+不应期\n\n## LIF: Nengo实现\n\nNengo是一个SNN相关的库，利用Nengo可以很容易实现上述LIF模型。\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport nengo\nfrom nengo.utils.matplotlib import rasterplot\n\nfrom nengo.dists import Uniform\n\nmodel = nengo.Network(label=\"A Single Neuron\")\nwith model:\n    neuron = nengo.Ensemble(1, dimensions=1, intercepts=Uniform(-.5, -.5), max_rates=Uniform(100, 100), encoders=[[1]])\n    # input node\n    cos = nengo.Node(lambda t: np.cos(8*t))\n    nengo.Connection(cos, neuron)\n    cos_probe = nengo.Probe(cos)\n    # 神经元原始脉冲输出\n    spikes = nengo.Probe(neuron.neurons)\n    # 细胞体电压\n    voltage = nengo.Probe(neuron.neurons, \"voltage\")\n    # spikes filtered by a 10ms post-synaptic filter\n    filtered = nengo.Probe(neuron, synapse=0.01)\n\nwith nengo.Simulator(model) as sim:\n    sim.run(1)\n    # plot the decoded output of the ensemble\n    plt.figure()\n    plt.plot(sim.trange(), sim.data[filtered])\n    plt.plot(sim.trange(), sim.data[cos_probe])\n    plt.xlim(0, 1)\n\n    # plot the spiking output of the ensemble\n    plt.figure(figsize=(10, 8))\n    plt.subplot(221)\n    rasterplot(sim.trange(), sim.data[spikes])\n    plt.ylabel(\"Neuron\")\n    plt.xlim(0, 1)\n\n    # plot the soma voltages of the neurons\n    plt.subplot(222)\n    plt.plot(sim.trange(), sim.data[voltage][:,0], 'r')\n    plt.xlim(0, 1)\n    plt.show()\n```\n\n","source":"_posts/SNN-1-LIF.md","raw":"---\ntitle: 'SNN[1]: LIF'\ndate: 2020-07-03 17:15:25\ncategories: AI\ntags: SNN, Deep Learning\nmathjax:  true\n---\n\n# SNN学习笔记1：LIF\n\n## 什么是SNN？\n\n[SNN](https://en.wikipedia.org/wiki/Spiking_neural_network)（Spiking neural network，脉冲神经网络）号称是第三代神经网络, 与当前流行的神经网络的主要区别是将神经脉冲传播的动态过程纳入学习和推理中。SNN中的神经元不会在每次传播中都激活，而是只有当神经元的膜电位超过阈值时才激活，在激活时发射电脉冲（spikes，神经科学中常称作动作电位），这些电脉冲通过轴突传递给其它的神经元。\n\n因此， 神经元的膜电位的变化的描述变得十分重要。下面介绍几种描述膜电位变化的模型。\n\n### Integrate-and-fire\n\nIntegrate-and-fire是最早用来描述膜电位变化的模型（1907年！），神经元膜电位的变化由下面的公式表示:\n$$\nI(t) = C_m \\frac{dV_m(t)}{dt}\n$$\n$C_m$ 表示神经元的电容, 我们容易看出上式只是电容公式Q=CV两边同时对时间求导。\n\n此模型有如下性质：当有电流输入时，膜电位将会升高。\n\n#### 不应期\n\n通过增加不应期（refractory period）$t_{ref}$可以使Integrate-and-fire模型更加精准。所谓不应期，就是在此期间神经元无法激活，这一现象在实际的神经元中已经被观察到，微观上可以由[钠钾离子通道的状态](https://www.youtube.com/watch?v=Gsf9IB-wQdU)来解释。\n\n不应期限制了神经元激活的频率，激活频率与不应期$t_{ref}$的关系如下：\n$$\nf(I) = \\frac{I}{C_mV_{th} + t_{ref}I}\n$$\n\n#### 缺点\n\n一个显著的缺点是，上述模型没有实现时间相关记忆（time-dependent memory）,即如果这个模型收到一个远超阈值的信号时，会永远将此信号记在自己的膜电位中。\n\n### LIF\n\n[LIF](https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire)(Leaky integrate-and-fire)通过增加“漏电（Leaky）”项解决了Integrate-and-fire模型中缺少时间相关记忆的问题。模型的公式如下：\n$$\nI(t) - \\frac{V_m(t)}{R_m} = C_m \\frac{dV_m(t)}{dt}\n$$\n“漏电”项$\\frac{V_m(t)}{R_m}$中的$R_m$表示膜电阻。\n\n公式蕴含了下面这些有趣的性质：\n\n1. 激活神经元的输入电流必须超过$I_{th} = \\frac{V_{th}}{R_m}$, 否则漏电项会导致膜电位泄露\n2. 大电流输入时，模型趋近于Integrate-and-fire+不应期\n\n## LIF: Nengo实现\n\nNengo是一个SNN相关的库，利用Nengo可以很容易实现上述LIF模型。\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport nengo\nfrom nengo.utils.matplotlib import rasterplot\n\nfrom nengo.dists import Uniform\n\nmodel = nengo.Network(label=\"A Single Neuron\")\nwith model:\n    neuron = nengo.Ensemble(1, dimensions=1, intercepts=Uniform(-.5, -.5), max_rates=Uniform(100, 100), encoders=[[1]])\n    # input node\n    cos = nengo.Node(lambda t: np.cos(8*t))\n    nengo.Connection(cos, neuron)\n    cos_probe = nengo.Probe(cos)\n    # 神经元原始脉冲输出\n    spikes = nengo.Probe(neuron.neurons)\n    # 细胞体电压\n    voltage = nengo.Probe(neuron.neurons, \"voltage\")\n    # spikes filtered by a 10ms post-synaptic filter\n    filtered = nengo.Probe(neuron, synapse=0.01)\n\nwith nengo.Simulator(model) as sim:\n    sim.run(1)\n    # plot the decoded output of the ensemble\n    plt.figure()\n    plt.plot(sim.trange(), sim.data[filtered])\n    plt.plot(sim.trange(), sim.data[cos_probe])\n    plt.xlim(0, 1)\n\n    # plot the spiking output of the ensemble\n    plt.figure(figsize=(10, 8))\n    plt.subplot(221)\n    rasterplot(sim.trange(), sim.data[spikes])\n    plt.ylabel(\"Neuron\")\n    plt.xlim(0, 1)\n\n    # plot the soma voltages of the neurons\n    plt.subplot(222)\n    plt.plot(sim.trange(), sim.data[voltage][:,0], 'r')\n    plt.xlim(0, 1)\n    plt.show()\n```\n\n","slug":"SNN-1-LIF","published":1,"updated":"2020-07-05T03:09:34.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9uch0000ys1dhtq89m63","content":"<h1 id=\"SNN学习笔记1：LIF\"><a href=\"#SNN学习笔记1：LIF\" class=\"headerlink\" title=\"SNN学习笔记1：LIF\"></a>SNN学习笔记1：LIF</h1><h2 id=\"什么是SNN？\"><a href=\"#什么是SNN？\" class=\"headerlink\" title=\"什么是SNN？\"></a>什么是SNN？</h2><p><a href=\"https://en.wikipedia.org/wiki/Spiking_neural_network\" target=\"_blank\" rel=\"noopener\">SNN</a>（Spiking neural network，脉冲神经网络）号称是第三代神经网络, 与当前流行的神经网络的主要区别是将神经脉冲传播的动态过程纳入学习和推理中。SNN中的神经元不会在每次传播中都激活，而是只有当神经元的膜电位超过阈值时才激活，在激活时发射电脉冲（spikes，神经科学中常称作动作电位），这些电脉冲通过轴突传递给其它的神经元。</p>\n<p>因此， 神经元的膜电位的变化的描述变得十分重要。下面介绍几种描述膜电位变化的模型。</p>\n<h3 id=\"Integrate-and-fire\"><a href=\"#Integrate-and-fire\" class=\"headerlink\" title=\"Integrate-and-fire\"></a>Integrate-and-fire</h3><p>Integrate-and-fire是最早用来描述膜电位变化的模型（1907年！），神经元膜电位的变化由下面的公式表示:</p>\n<script type=\"math/tex; mode=display\">\nI(t) = C_m \\frac{dV_m(t)}{dt}</script><p>$C_m$ 表示神经元的电容, 我们容易看出上式只是电容公式Q=CV两边同时对时间求导。</p>\n<p>此模型有如下性质：当有电流输入时，膜电位将会升高。</p>\n<h4 id=\"不应期\"><a href=\"#不应期\" class=\"headerlink\" title=\"不应期\"></a>不应期</h4><p>通过增加不应期（refractory period）$t_{ref}$可以使Integrate-and-fire模型更加精准。所谓不应期，就是在此期间神经元无法激活，这一现象在实际的神经元中已经被观察到，微观上可以由<a href=\"https://www.youtube.com/watch?v=Gsf9IB-wQdU\" target=\"_blank\" rel=\"noopener\">钠钾离子通道的状态</a>来解释。</p>\n<p>不应期限制了神经元激活的频率，激活频率与不应期$t_{ref}$的关系如下：</p>\n<script type=\"math/tex; mode=display\">\nf(I) = \\frac{I}{C_mV_{th} + t_{ref}I}</script><h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>一个显著的缺点是，上述模型没有实现时间相关记忆（time-dependent memory）,即如果这个模型收到一个远超阈值的信号时，会永远将此信号记在自己的膜电位中。</p>\n<h3 id=\"LIF\"><a href=\"#LIF\" class=\"headerlink\" title=\"LIF\"></a>LIF</h3><p><a href=\"https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire\" target=\"_blank\" rel=\"noopener\">LIF</a>(Leaky integrate-and-fire)通过增加“漏电（Leaky）”项解决了Integrate-and-fire模型中缺少时间相关记忆的问题。模型的公式如下：</p>\n<script type=\"math/tex; mode=display\">\nI(t) - \\frac{V_m(t)}{R_m} = C_m \\frac{dV_m(t)}{dt}</script><p>“漏电”项$\\frac{V_m(t)}{R_m}$中的$R_m$表示膜电阻。</p>\n<p>公式蕴含了下面这些有趣的性质：</p>\n<ol>\n<li>激活神经元的输入电流必须超过$I_{th} = \\frac{V_{th}}{R_m}$, 否则漏电项会导致膜电位泄露</li>\n<li>大电流输入时，模型趋近于Integrate-and-fire+不应期</li>\n</ol>\n<h2 id=\"LIF-Nengo实现\"><a href=\"#LIF-Nengo实现\" class=\"headerlink\" title=\"LIF: Nengo实现\"></a>LIF: Nengo实现</h2><p>Nengo是一个SNN相关的库，利用Nengo可以很容易实现上述LIF模型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.utils.matplotlib <span class=\"keyword\">import</span> rasterplot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.dists <span class=\"keyword\">import</span> Uniform</span><br><span class=\"line\"></span><br><span class=\"line\">model = nengo.Network(label=<span class=\"string\">\"A Single Neuron\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">with</span> model:</span><br><span class=\"line\">    neuron = nengo.Ensemble(<span class=\"number\">1</span>, dimensions=<span class=\"number\">1</span>, intercepts=Uniform(<span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>), max_rates=Uniform(<span class=\"number\">100</span>, <span class=\"number\">100</span>), encoders=[[<span class=\"number\">1</span>]])</span><br><span class=\"line\">    <span class=\"comment\"># input node</span></span><br><span class=\"line\">    cos = nengo.Node(<span class=\"keyword\">lambda</span> t: np.cos(<span class=\"number\">8</span>*t))</span><br><span class=\"line\">    nengo.Connection(cos, neuron)</span><br><span class=\"line\">    cos_probe = nengo.Probe(cos)</span><br><span class=\"line\">    <span class=\"comment\"># 神经元原始脉冲输出</span></span><br><span class=\"line\">    spikes = nengo.Probe(neuron.neurons)</span><br><span class=\"line\">    <span class=\"comment\"># 细胞体电压</span></span><br><span class=\"line\">    voltage = nengo.Probe(neuron.neurons, <span class=\"string\">\"voltage\"</span>)</span><br><span class=\"line\">    <span class=\"comment\"># spikes filtered by a 10ms post-synaptic filter</span></span><br><span class=\"line\">    filtered = nengo.Probe(neuron, synapse=<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo.Simulator(model) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">    sim.run(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># plot the decoded output of the ensemble</span></span><br><span class=\"line\">    plt.figure()</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[filtered])</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[cos_probe])</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># plot the spiking output of the ensemble</span></span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">8</span>))</span><br><span class=\"line\">    plt.subplot(<span class=\"number\">221</span>)</span><br><span class=\"line\">    rasterplot(sim.trange(), sim.data[spikes])</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">\"Neuron\"</span>)</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># plot the soma voltages of the neurons</span></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">222</span>)</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[voltage][:,<span class=\"number\">0</span>], <span class=\"string\">'r'</span>)</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SNN学习笔记1：LIF\"><a href=\"#SNN学习笔记1：LIF\" class=\"headerlink\" title=\"SNN学习笔记1：LIF\"></a>SNN学习笔记1：LIF</h1><h2 id=\"什么是SNN？\"><a href=\"#什么是SNN？\" class=\"headerlink\" title=\"什么是SNN？\"></a>什么是SNN？</h2><p><a href=\"https://en.wikipedia.org/wiki/Spiking_neural_network\" target=\"_blank\" rel=\"noopener\">SNN</a>（Spiking neural network，脉冲神经网络）号称是第三代神经网络, 与当前流行的神经网络的主要区别是将神经脉冲传播的动态过程纳入学习和推理中。SNN中的神经元不会在每次传播中都激活，而是只有当神经元的膜电位超过阈值时才激活，在激活时发射电脉冲（spikes，神经科学中常称作动作电位），这些电脉冲通过轴突传递给其它的神经元。</p>\n<p>因此， 神经元的膜电位的变化的描述变得十分重要。下面介绍几种描述膜电位变化的模型。</p>\n<h3 id=\"Integrate-and-fire\"><a href=\"#Integrate-and-fire\" class=\"headerlink\" title=\"Integrate-and-fire\"></a>Integrate-and-fire</h3><p>Integrate-and-fire是最早用来描述膜电位变化的模型（1907年！），神经元膜电位的变化由下面的公式表示:</p>\n<script type=\"math/tex; mode=display\">\nI(t) = C_m \\frac{dV_m(t)}{dt}</script><p>$C_m$ 表示神经元的电容, 我们容易看出上式只是电容公式Q=CV两边同时对时间求导。</p>\n<p>此模型有如下性质：当有电流输入时，膜电位将会升高。</p>\n<h4 id=\"不应期\"><a href=\"#不应期\" class=\"headerlink\" title=\"不应期\"></a>不应期</h4><p>通过增加不应期（refractory period）$t_{ref}$可以使Integrate-and-fire模型更加精准。所谓不应期，就是在此期间神经元无法激活，这一现象在实际的神经元中已经被观察到，微观上可以由<a href=\"https://www.youtube.com/watch?v=Gsf9IB-wQdU\" target=\"_blank\" rel=\"noopener\">钠钾离子通道的状态</a>来解释。</p>\n<p>不应期限制了神经元激活的频率，激活频率与不应期$t_{ref}$的关系如下：</p>\n<script type=\"math/tex; mode=display\">\nf(I) = \\frac{I}{C_mV_{th} + t_{ref}I}</script><h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>一个显著的缺点是，上述模型没有实现时间相关记忆（time-dependent memory）,即如果这个模型收到一个远超阈值的信号时，会永远将此信号记在自己的膜电位中。</p>\n<h3 id=\"LIF\"><a href=\"#LIF\" class=\"headerlink\" title=\"LIF\"></a>LIF</h3><p><a href=\"https://en.wikipedia.org/wiki/Biological_neuron_model#Leaky_integrate-and-fire\" target=\"_blank\" rel=\"noopener\">LIF</a>(Leaky integrate-and-fire)通过增加“漏电（Leaky）”项解决了Integrate-and-fire模型中缺少时间相关记忆的问题。模型的公式如下：</p>\n<script type=\"math/tex; mode=display\">\nI(t) - \\frac{V_m(t)}{R_m} = C_m \\frac{dV_m(t)}{dt}</script><p>“漏电”项$\\frac{V_m(t)}{R_m}$中的$R_m$表示膜电阻。</p>\n<p>公式蕴含了下面这些有趣的性质：</p>\n<ol>\n<li>激活神经元的输入电流必须超过$I_{th} = \\frac{V_{th}}{R_m}$, 否则漏电项会导致膜电位泄露</li>\n<li>大电流输入时，模型趋近于Integrate-and-fire+不应期</li>\n</ol>\n<h2 id=\"LIF-Nengo实现\"><a href=\"#LIF-Nengo实现\" class=\"headerlink\" title=\"LIF: Nengo实现\"></a>LIF: Nengo实现</h2><p>Nengo是一个SNN相关的库，利用Nengo可以很容易实现上述LIF模型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.utils.matplotlib <span class=\"keyword\">import</span> rasterplot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.dists <span class=\"keyword\">import</span> Uniform</span><br><span class=\"line\"></span><br><span class=\"line\">model = nengo.Network(label=<span class=\"string\">\"A Single Neuron\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">with</span> model:</span><br><span class=\"line\">    neuron = nengo.Ensemble(<span class=\"number\">1</span>, dimensions=<span class=\"number\">1</span>, intercepts=Uniform(<span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>), max_rates=Uniform(<span class=\"number\">100</span>, <span class=\"number\">100</span>), encoders=[[<span class=\"number\">1</span>]])</span><br><span class=\"line\">    <span class=\"comment\"># input node</span></span><br><span class=\"line\">    cos = nengo.Node(<span class=\"keyword\">lambda</span> t: np.cos(<span class=\"number\">8</span>*t))</span><br><span class=\"line\">    nengo.Connection(cos, neuron)</span><br><span class=\"line\">    cos_probe = nengo.Probe(cos)</span><br><span class=\"line\">    <span class=\"comment\"># 神经元原始脉冲输出</span></span><br><span class=\"line\">    spikes = nengo.Probe(neuron.neurons)</span><br><span class=\"line\">    <span class=\"comment\"># 细胞体电压</span></span><br><span class=\"line\">    voltage = nengo.Probe(neuron.neurons, <span class=\"string\">\"voltage\"</span>)</span><br><span class=\"line\">    <span class=\"comment\"># spikes filtered by a 10ms post-synaptic filter</span></span><br><span class=\"line\">    filtered = nengo.Probe(neuron, synapse=<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo.Simulator(model) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">    sim.run(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># plot the decoded output of the ensemble</span></span><br><span class=\"line\">    plt.figure()</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[filtered])</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[cos_probe])</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># plot the spiking output of the ensemble</span></span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">8</span>))</span><br><span class=\"line\">    plt.subplot(<span class=\"number\">221</span>)</span><br><span class=\"line\">    rasterplot(sim.trange(), sim.data[spikes])</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">\"Neuron\"</span>)</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># plot the soma voltages of the neurons</span></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">222</span>)</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[voltage][:,<span class=\"number\">0</span>], <span class=\"string\">'r'</span>)</span><br><span class=\"line\">    plt.xlim(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\n"},{"title":"SNN[2]: Neural Coding","date":"2020-07-05T02:56:20.000Z","mathjax":true,"_content":"\n# SNN学习笔记2：神经编码\n\n大脑中的感知细胞在受到光、声音等外界刺激时，其动作电位的激活序列会呈现出一定的时序模式。[神经编码](https://en.wikipedia.org/wiki/Neural_coding)认为大脑中的感知、认知等信息由神经元的激活表征，这些激活的各方面特征（时序 、强度等）不仅能够编码数字信号也能编码模拟信号。\n\n## 一些概念\n\n### ISI\n\nISI(interspike intervals)，激活间间隙，表示两次激活中间间隔的时间的长度。虽然每次激活的持续时间、幅度和形状可能都有差异，但通常被处理为出现/不出现的点事件（point events）。\n\n### 神经编码\n\n神经编码（Neural Encoding）将外界输入刺激映射到神经元的反应，主要关注的是理解神经元如何对刺激作出反应，并建模来尝试**预测**神经元对其它刺激的反应。\n\n### 神经解码\n\n神经解码（Neural Decoding）关注的是编码的反向映射，也就是通过观察神经元的活动**推导**出对应的外界刺激。\n\n## 一些神经编码的理论\n\n一系列的神经脉冲中包含了丰富的信息，不同编码理论侧重有所不同，在信息精度/浓度上也各有取舍。对不同功能的神经元，适用的编码也会不同。例如，对于控制肌肉收缩的运动细胞，基本只关心脉冲的发射频率（firing rate）。而对于处理复杂认知任务（例如，视觉、听觉）的神经细胞，每个脉冲出现的精确时间都包含了信息。\n\n### 频率编码（Rate coding）\n\n频率编码模型将外界刺激的强度编码为脉冲的发射频率（firing rate），也就是外界的刺激越强，对应神经元的脉冲发射频率越高（通常是非线性变化）。频率编码假设外界刺激的绝大多数信息都包含在神经元的发射频率中，这是一种早期的编码方案，实验表明脉冲准确的时间中也包含了大量信息。\n\nNOTE：目前发射频率没有一个公认的定义，常见的定义有：1）随时间平均 2）多次实验平均。\n\n#### 频率编码：脉冲计数码率\n\n脉冲计数码率（spike-count rate, a.k.a temporal average）由对一次实验中的脉冲数目进行计数，然后除以实验持续的时间得到。显然，这种平均只适合恒定或者变化较慢的外界刺激，对于变化较快的外界刺激意义不大。\n\n#### 频率编码：时间相关发射率\n\n时间相关发射率（time-dependent firing rate）定义为 $\\frac{C_{t}^{t + \\Delta t}spikes}{\\Delta t}$,其中$C_t^{t + \\Delta t}spikes$表示$t$到$\\Delta t$之间的脉冲计数。和脉冲计数码率不同，时间相关发射率不仅可以处理常量刺激，也可以处理时间相关的刺激。\n\nNOTE: 时间相关发射率依赖于有多个独立神经元，每个神经元接收同一种刺激的假设。\n\n### 时间编码（Temporal coding）\n\n与频率编码不同，在时间编码中，脉冲出现的准确时间或者发射频率的波动被认为是携带信息的。\n\n#### 时间编码：二元编码\n\n用二元符号来标记单位时间内是否有脉冲，1表示有脉冲，0表示没有。利用二元编码，我们可以区分频率编码中无法区分的序列，例如：0001110011和1110001100两者虽然频率一致，但是脉冲的时序显然不一样。\n\n#### 时间编码：ISI\n\nISI利用激活间的区间长度来编码激活序列。\n\n#### 时间编码：稀疏编码\n\n对神经元的每次强激活单独编码，通常用线性生成模型来描述（Linear Generative Model）。","source":"_posts/SNN-2-Neural-Coding.md","raw":"---\ntitle: 'SNN[2]: Neural Coding'\ndate: 2020-07-05 10:56:20\ncategories: AI\ntags: SNN, Deep Learning\nmathjax: true\n---\n\n# SNN学习笔记2：神经编码\n\n大脑中的感知细胞在受到光、声音等外界刺激时，其动作电位的激活序列会呈现出一定的时序模式。[神经编码](https://en.wikipedia.org/wiki/Neural_coding)认为大脑中的感知、认知等信息由神经元的激活表征，这些激活的各方面特征（时序 、强度等）不仅能够编码数字信号也能编码模拟信号。\n\n## 一些概念\n\n### ISI\n\nISI(interspike intervals)，激活间间隙，表示两次激活中间间隔的时间的长度。虽然每次激活的持续时间、幅度和形状可能都有差异，但通常被处理为出现/不出现的点事件（point events）。\n\n### 神经编码\n\n神经编码（Neural Encoding）将外界输入刺激映射到神经元的反应，主要关注的是理解神经元如何对刺激作出反应，并建模来尝试**预测**神经元对其它刺激的反应。\n\n### 神经解码\n\n神经解码（Neural Decoding）关注的是编码的反向映射，也就是通过观察神经元的活动**推导**出对应的外界刺激。\n\n## 一些神经编码的理论\n\n一系列的神经脉冲中包含了丰富的信息，不同编码理论侧重有所不同，在信息精度/浓度上也各有取舍。对不同功能的神经元，适用的编码也会不同。例如，对于控制肌肉收缩的运动细胞，基本只关心脉冲的发射频率（firing rate）。而对于处理复杂认知任务（例如，视觉、听觉）的神经细胞，每个脉冲出现的精确时间都包含了信息。\n\n### 频率编码（Rate coding）\n\n频率编码模型将外界刺激的强度编码为脉冲的发射频率（firing rate），也就是外界的刺激越强，对应神经元的脉冲发射频率越高（通常是非线性变化）。频率编码假设外界刺激的绝大多数信息都包含在神经元的发射频率中，这是一种早期的编码方案，实验表明脉冲准确的时间中也包含了大量信息。\n\nNOTE：目前发射频率没有一个公认的定义，常见的定义有：1）随时间平均 2）多次实验平均。\n\n#### 频率编码：脉冲计数码率\n\n脉冲计数码率（spike-count rate, a.k.a temporal average）由对一次实验中的脉冲数目进行计数，然后除以实验持续的时间得到。显然，这种平均只适合恒定或者变化较慢的外界刺激，对于变化较快的外界刺激意义不大。\n\n#### 频率编码：时间相关发射率\n\n时间相关发射率（time-dependent firing rate）定义为 $\\frac{C_{t}^{t + \\Delta t}spikes}{\\Delta t}$,其中$C_t^{t + \\Delta t}spikes$表示$t$到$\\Delta t$之间的脉冲计数。和脉冲计数码率不同，时间相关发射率不仅可以处理常量刺激，也可以处理时间相关的刺激。\n\nNOTE: 时间相关发射率依赖于有多个独立神经元，每个神经元接收同一种刺激的假设。\n\n### 时间编码（Temporal coding）\n\n与频率编码不同，在时间编码中，脉冲出现的准确时间或者发射频率的波动被认为是携带信息的。\n\n#### 时间编码：二元编码\n\n用二元符号来标记单位时间内是否有脉冲，1表示有脉冲，0表示没有。利用二元编码，我们可以区分频率编码中无法区分的序列，例如：0001110011和1110001100两者虽然频率一致，但是脉冲的时序显然不一样。\n\n#### 时间编码：ISI\n\nISI利用激活间的区间长度来编码激活序列。\n\n#### 时间编码：稀疏编码\n\n对神经元的每次强激活单独编码，通常用线性生成模型来描述（Linear Generative Model）。","slug":"SNN-2-Neural-Coding","published":1,"updated":"2020-07-06T03:10:57.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9ucl0001ys1df2db6hs0","content":"<h1 id=\"SNN学习笔记2：神经编码\"><a href=\"#SNN学习笔记2：神经编码\" class=\"headerlink\" title=\"SNN学习笔记2：神经编码\"></a>SNN学习笔记2：神经编码</h1><p>大脑中的感知细胞在受到光、声音等外界刺激时，其动作电位的激活序列会呈现出一定的时序模式。<a href=\"https://en.wikipedia.org/wiki/Neural_coding\" target=\"_blank\" rel=\"noopener\">神经编码</a>认为大脑中的感知、认知等信息由神经元的激活表征，这些激活的各方面特征（时序 、强度等）不仅能够编码数字信号也能编码模拟信号。</p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"ISI\"><a href=\"#ISI\" class=\"headerlink\" title=\"ISI\"></a>ISI</h3><p>ISI(interspike intervals)，激活间间隙，表示两次激活中间间隔的时间的长度。虽然每次激活的持续时间、幅度和形状可能都有差异，但通常被处理为出现/不出现的点事件（point events）。</p>\n<h3 id=\"神经编码\"><a href=\"#神经编码\" class=\"headerlink\" title=\"神经编码\"></a>神经编码</h3><p>神经编码（Neural Encoding）将外界输入刺激映射到神经元的反应，主要关注的是理解神经元如何对刺激作出反应，并建模来尝试<strong>预测</strong>神经元对其它刺激的反应。</p>\n<h3 id=\"神经解码\"><a href=\"#神经解码\" class=\"headerlink\" title=\"神经解码\"></a>神经解码</h3><p>神经解码（Neural Decoding）关注的是编码的反向映射，也就是通过观察神经元的活动<strong>推导</strong>出对应的外界刺激。</p>\n<h2 id=\"一些神经编码的理论\"><a href=\"#一些神经编码的理论\" class=\"headerlink\" title=\"一些神经编码的理论\"></a>一些神经编码的理论</h2><p>一系列的神经脉冲中包含了丰富的信息，不同编码理论侧重有所不同，在信息精度/浓度上也各有取舍。对不同功能的神经元，适用的编码也会不同。例如，对于控制肌肉收缩的运动细胞，基本只关心脉冲的发射频率（firing rate）。而对于处理复杂认知任务（例如，视觉、听觉）的神经细胞，每个脉冲出现的精确时间都包含了信息。</p>\n<h3 id=\"频率编码（Rate-coding）\"><a href=\"#频率编码（Rate-coding）\" class=\"headerlink\" title=\"频率编码（Rate coding）\"></a>频率编码（Rate coding）</h3><p>频率编码模型将外界刺激的强度编码为脉冲的发射频率（firing rate），也就是外界的刺激越强，对应神经元的脉冲发射频率越高（通常是非线性变化）。频率编码假设外界刺激的绝大多数信息都包含在神经元的发射频率中，这是一种早期的编码方案，实验表明脉冲准确的时间中也包含了大量信息。</p>\n<p>NOTE：目前发射频率没有一个公认的定义，常见的定义有：1）随时间平均 2）多次实验平均。</p>\n<h4 id=\"频率编码：脉冲计数码率\"><a href=\"#频率编码：脉冲计数码率\" class=\"headerlink\" title=\"频率编码：脉冲计数码率\"></a>频率编码：脉冲计数码率</h4><p>脉冲计数码率（spike-count rate, a.k.a temporal average）由对一次实验中的脉冲数目进行计数，然后除以实验持续的时间得到。显然，这种平均只适合恒定或者变化较慢的外界刺激，对于变化较快的外界刺激意义不大。</p>\n<h4 id=\"频率编码：时间相关发射率\"><a href=\"#频率编码：时间相关发射率\" class=\"headerlink\" title=\"频率编码：时间相关发射率\"></a>频率编码：时间相关发射率</h4><p>时间相关发射率（time-dependent firing rate）定义为 $\\frac{C_{t}^{t + \\Delta t}spikes}{\\Delta t}$,其中$C_t^{t + \\Delta t}spikes$表示$t$到$\\Delta t$之间的脉冲计数。和脉冲计数码率不同，时间相关发射率不仅可以处理常量刺激，也可以处理时间相关的刺激。</p>\n<p>NOTE: 时间相关发射率依赖于有多个独立神经元，每个神经元接收同一种刺激的假设。</p>\n<h3 id=\"时间编码（Temporal-coding）\"><a href=\"#时间编码（Temporal-coding）\" class=\"headerlink\" title=\"时间编码（Temporal coding）\"></a>时间编码（Temporal coding）</h3><p>与频率编码不同，在时间编码中，脉冲出现的准确时间或者发射频率的波动被认为是携带信息的。</p>\n<h4 id=\"时间编码：二元编码\"><a href=\"#时间编码：二元编码\" class=\"headerlink\" title=\"时间编码：二元编码\"></a>时间编码：二元编码</h4><p>用二元符号来标记单位时间内是否有脉冲，1表示有脉冲，0表示没有。利用二元编码，我们可以区分频率编码中无法区分的序列，例如：0001110011和1110001100两者虽然频率一致，但是脉冲的时序显然不一样。</p>\n<h4 id=\"时间编码：ISI\"><a href=\"#时间编码：ISI\" class=\"headerlink\" title=\"时间编码：ISI\"></a>时间编码：ISI</h4><p>ISI利用激活间的区间长度来编码激活序列。</p>\n<h4 id=\"时间编码：稀疏编码\"><a href=\"#时间编码：稀疏编码\" class=\"headerlink\" title=\"时间编码：稀疏编码\"></a>时间编码：稀疏编码</h4><p>对神经元的每次强激活单独编码，通常用线性生成模型来描述（Linear Generative Model）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SNN学习笔记2：神经编码\"><a href=\"#SNN学习笔记2：神经编码\" class=\"headerlink\" title=\"SNN学习笔记2：神经编码\"></a>SNN学习笔记2：神经编码</h1><p>大脑中的感知细胞在受到光、声音等外界刺激时，其动作电位的激活序列会呈现出一定的时序模式。<a href=\"https://en.wikipedia.org/wiki/Neural_coding\" target=\"_blank\" rel=\"noopener\">神经编码</a>认为大脑中的感知、认知等信息由神经元的激活表征，这些激活的各方面特征（时序 、强度等）不仅能够编码数字信号也能编码模拟信号。</p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"ISI\"><a href=\"#ISI\" class=\"headerlink\" title=\"ISI\"></a>ISI</h3><p>ISI(interspike intervals)，激活间间隙，表示两次激活中间间隔的时间的长度。虽然每次激活的持续时间、幅度和形状可能都有差异，但通常被处理为出现/不出现的点事件（point events）。</p>\n<h3 id=\"神经编码\"><a href=\"#神经编码\" class=\"headerlink\" title=\"神经编码\"></a>神经编码</h3><p>神经编码（Neural Encoding）将外界输入刺激映射到神经元的反应，主要关注的是理解神经元如何对刺激作出反应，并建模来尝试<strong>预测</strong>神经元对其它刺激的反应。</p>\n<h3 id=\"神经解码\"><a href=\"#神经解码\" class=\"headerlink\" title=\"神经解码\"></a>神经解码</h3><p>神经解码（Neural Decoding）关注的是编码的反向映射，也就是通过观察神经元的活动<strong>推导</strong>出对应的外界刺激。</p>\n<h2 id=\"一些神经编码的理论\"><a href=\"#一些神经编码的理论\" class=\"headerlink\" title=\"一些神经编码的理论\"></a>一些神经编码的理论</h2><p>一系列的神经脉冲中包含了丰富的信息，不同编码理论侧重有所不同，在信息精度/浓度上也各有取舍。对不同功能的神经元，适用的编码也会不同。例如，对于控制肌肉收缩的运动细胞，基本只关心脉冲的发射频率（firing rate）。而对于处理复杂认知任务（例如，视觉、听觉）的神经细胞，每个脉冲出现的精确时间都包含了信息。</p>\n<h3 id=\"频率编码（Rate-coding）\"><a href=\"#频率编码（Rate-coding）\" class=\"headerlink\" title=\"频率编码（Rate coding）\"></a>频率编码（Rate coding）</h3><p>频率编码模型将外界刺激的强度编码为脉冲的发射频率（firing rate），也就是外界的刺激越强，对应神经元的脉冲发射频率越高（通常是非线性变化）。频率编码假设外界刺激的绝大多数信息都包含在神经元的发射频率中，这是一种早期的编码方案，实验表明脉冲准确的时间中也包含了大量信息。</p>\n<p>NOTE：目前发射频率没有一个公认的定义，常见的定义有：1）随时间平均 2）多次实验平均。</p>\n<h4 id=\"频率编码：脉冲计数码率\"><a href=\"#频率编码：脉冲计数码率\" class=\"headerlink\" title=\"频率编码：脉冲计数码率\"></a>频率编码：脉冲计数码率</h4><p>脉冲计数码率（spike-count rate, a.k.a temporal average）由对一次实验中的脉冲数目进行计数，然后除以实验持续的时间得到。显然，这种平均只适合恒定或者变化较慢的外界刺激，对于变化较快的外界刺激意义不大。</p>\n<h4 id=\"频率编码：时间相关发射率\"><a href=\"#频率编码：时间相关发射率\" class=\"headerlink\" title=\"频率编码：时间相关发射率\"></a>频率编码：时间相关发射率</h4><p>时间相关发射率（time-dependent firing rate）定义为 $\\frac{C_{t}^{t + \\Delta t}spikes}{\\Delta t}$,其中$C_t^{t + \\Delta t}spikes$表示$t$到$\\Delta t$之间的脉冲计数。和脉冲计数码率不同，时间相关发射率不仅可以处理常量刺激，也可以处理时间相关的刺激。</p>\n<p>NOTE: 时间相关发射率依赖于有多个独立神经元，每个神经元接收同一种刺激的假设。</p>\n<h3 id=\"时间编码（Temporal-coding）\"><a href=\"#时间编码（Temporal-coding）\" class=\"headerlink\" title=\"时间编码（Temporal coding）\"></a>时间编码（Temporal coding）</h3><p>与频率编码不同，在时间编码中，脉冲出现的准确时间或者发射频率的波动被认为是携带信息的。</p>\n<h4 id=\"时间编码：二元编码\"><a href=\"#时间编码：二元编码\" class=\"headerlink\" title=\"时间编码：二元编码\"></a>时间编码：二元编码</h4><p>用二元符号来标记单位时间内是否有脉冲，1表示有脉冲，0表示没有。利用二元编码，我们可以区分频率编码中无法区分的序列，例如：0001110011和1110001100两者虽然频率一致，但是脉冲的时序显然不一样。</p>\n<h4 id=\"时间编码：ISI\"><a href=\"#时间编码：ISI\" class=\"headerlink\" title=\"时间编码：ISI\"></a>时间编码：ISI</h4><p>ISI利用激活间的区间长度来编码激活序列。</p>\n<h4 id=\"时间编码：稀疏编码\"><a href=\"#时间编码：稀疏编码\" class=\"headerlink\" title=\"时间编码：稀疏编码\"></a>时间编码：稀疏编码</h4><p>对神经元的每次强激活单独编码，通常用线性生成模型来描述（Linear Generative Model）。</p>\n"},{"title":"SNN[3]: Associative Learning","date":"2020-07-06T03:25:03.000Z","mathjax":true,"_content":"\n# SNN学习笔记3：关联学习\n\n关联学习（Associative Learning）认为想法（神经元激活模式）和想法、想法和经历（外界刺激）会互相关联、互相强化。\n\n关联在学习和认知中有着核心的地位，记忆实际上就是一种关联，很多认知功能的本质就是一层或多层的关联。\n\n## 赫布理论\n\n突触（synaptic）用于连接多个神经元，其连接强度具有可以调整，这种可以调整的特性叫做突触可塑性（synaptic plasticity）。突触可塑性是记忆和学习的基础，赫布理论认为突触前的神经元对突触后神经元的反复刺激可以增加突触的传递效能，也就是强化了这两个神经元之间的连接。\n\n赫布理论强调细胞A的激活导致了细胞B的激活以及两者之间连接的强化，这种先后/因果关系的理论也叫STDP(spike-timing-dependent plasticity)。\n\n## STDP\n\nSTDP基于一个神经元的**输入脉冲**及**输出脉冲**间的相对时间来调整神经元间连接的强度。如果一个神经元的输入倾向于刚好出现在输出脉冲前，那么此神经元与输入神经元之间的连接倾向加强；如果一个神经元的输入倾向于刚好出现在输出脉冲之后，那么此神经元和输入神经元之间的连接倾向减弱。\n\n通过上面的调整机制，可能是当前神经元激活的原因的输入会被强化；不是当前神经元激活原因的输入会被弱化。这个调整的过程最后会收敛到只有一部分连接保留下来，另一部分的连接强度降低到0，以此达到一种稀疏连接的效果。","source":"_posts/SNN-3-Synaptic-Plasticity.md","raw":"---\ntitle: 'SNN[3]: Associative Learning'\ndate: 2020-07-06 11:25:03\ncategories: AI\ntags: SNN, Deep Learning\nmathjax: true\n---\n\n# SNN学习笔记3：关联学习\n\n关联学习（Associative Learning）认为想法（神经元激活模式）和想法、想法和经历（外界刺激）会互相关联、互相强化。\n\n关联在学习和认知中有着核心的地位，记忆实际上就是一种关联，很多认知功能的本质就是一层或多层的关联。\n\n## 赫布理论\n\n突触（synaptic）用于连接多个神经元，其连接强度具有可以调整，这种可以调整的特性叫做突触可塑性（synaptic plasticity）。突触可塑性是记忆和学习的基础，赫布理论认为突触前的神经元对突触后神经元的反复刺激可以增加突触的传递效能，也就是强化了这两个神经元之间的连接。\n\n赫布理论强调细胞A的激活导致了细胞B的激活以及两者之间连接的强化，这种先后/因果关系的理论也叫STDP(spike-timing-dependent plasticity)。\n\n## STDP\n\nSTDP基于一个神经元的**输入脉冲**及**输出脉冲**间的相对时间来调整神经元间连接的强度。如果一个神经元的输入倾向于刚好出现在输出脉冲前，那么此神经元与输入神经元之间的连接倾向加强；如果一个神经元的输入倾向于刚好出现在输出脉冲之后，那么此神经元和输入神经元之间的连接倾向减弱。\n\n通过上面的调整机制，可能是当前神经元激活的原因的输入会被强化；不是当前神经元激活原因的输入会被弱化。这个调整的过程最后会收敛到只有一部分连接保留下来，另一部分的连接强度降低到0，以此达到一种稀疏连接的效果。","slug":"SNN-3-Synaptic-Plasticity","published":1,"updated":"2020-07-06T07:26:18.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9uco0004ys1dbqpog38p","content":"<h1 id=\"SNN学习笔记3：关联学习\"><a href=\"#SNN学习笔记3：关联学习\" class=\"headerlink\" title=\"SNN学习笔记3：关联学习\"></a>SNN学习笔记3：关联学习</h1><p>关联学习（Associative Learning）认为想法（神经元激活模式）和想法、想法和经历（外界刺激）会互相关联、互相强化。</p>\n<p>关联在学习和认知中有着核心的地位，记忆实际上就是一种关联，很多认知功能的本质就是一层或多层的关联。</p>\n<h2 id=\"赫布理论\"><a href=\"#赫布理论\" class=\"headerlink\" title=\"赫布理论\"></a>赫布理论</h2><p>突触（synaptic）用于连接多个神经元，其连接强度具有可以调整，这种可以调整的特性叫做突触可塑性（synaptic plasticity）。突触可塑性是记忆和学习的基础，赫布理论认为突触前的神经元对突触后神经元的反复刺激可以增加突触的传递效能，也就是强化了这两个神经元之间的连接。</p>\n<p>赫布理论强调细胞A的激活导致了细胞B的激活以及两者之间连接的强化，这种先后/因果关系的理论也叫STDP(spike-timing-dependent plasticity)。</p>\n<h2 id=\"STDP\"><a href=\"#STDP\" class=\"headerlink\" title=\"STDP\"></a>STDP</h2><p>STDP基于一个神经元的<strong>输入脉冲</strong>及<strong>输出脉冲</strong>间的相对时间来调整神经元间连接的强度。如果一个神经元的输入倾向于刚好出现在输出脉冲前，那么此神经元与输入神经元之间的连接倾向加强；如果一个神经元的输入倾向于刚好出现在输出脉冲之后，那么此神经元和输入神经元之间的连接倾向减弱。</p>\n<p>通过上面的调整机制，可能是当前神经元激活的原因的输入会被强化；不是当前神经元激活原因的输入会被弱化。这个调整的过程最后会收敛到只有一部分连接保留下来，另一部分的连接强度降低到0，以此达到一种稀疏连接的效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SNN学习笔记3：关联学习\"><a href=\"#SNN学习笔记3：关联学习\" class=\"headerlink\" title=\"SNN学习笔记3：关联学习\"></a>SNN学习笔记3：关联学习</h1><p>关联学习（Associative Learning）认为想法（神经元激活模式）和想法、想法和经历（外界刺激）会互相关联、互相强化。</p>\n<p>关联在学习和认知中有着核心的地位，记忆实际上就是一种关联，很多认知功能的本质就是一层或多层的关联。</p>\n<h2 id=\"赫布理论\"><a href=\"#赫布理论\" class=\"headerlink\" title=\"赫布理论\"></a>赫布理论</h2><p>突触（synaptic）用于连接多个神经元，其连接强度具有可以调整，这种可以调整的特性叫做突触可塑性（synaptic plasticity）。突触可塑性是记忆和学习的基础，赫布理论认为突触前的神经元对突触后神经元的反复刺激可以增加突触的传递效能，也就是强化了这两个神经元之间的连接。</p>\n<p>赫布理论强调细胞A的激活导致了细胞B的激活以及两者之间连接的强化，这种先后/因果关系的理论也叫STDP(spike-timing-dependent plasticity)。</p>\n<h2 id=\"STDP\"><a href=\"#STDP\" class=\"headerlink\" title=\"STDP\"></a>STDP</h2><p>STDP基于一个神经元的<strong>输入脉冲</strong>及<strong>输出脉冲</strong>间的相对时间来调整神经元间连接的强度。如果一个神经元的输入倾向于刚好出现在输出脉冲前，那么此神经元与输入神经元之间的连接倾向加强；如果一个神经元的输入倾向于刚好出现在输出脉冲之后，那么此神经元和输入神经元之间的连接倾向减弱。</p>\n<p>通过上面的调整机制，可能是当前神经元激活的原因的输入会被强化；不是当前神经元激活原因的输入会被弱化。这个调整的过程最后会收敛到只有一部分连接保留下来，另一部分的连接强度降低到0，以此达到一种稀疏连接的效果。</p>\n"},{"title":"SNN[4]: Nengo","date":"2020-07-06T07:56:34.000Z","mathjax":true,"_content":"\n# SNN学习笔记4： Nengo\n\n[Nengo](https://www.nengo.ai/) 是一个用于神经建模框架，其扩展[NengoDL](https://nengo.ai/nengo-dl/)支持混用包含了生物细节的神经模型和现在流行的深度学习框架（例如：TensorFlow）。\n\n## 安装\n\nnengo安装命令：`pip install nengo nengo-gui`\n\n测试是否安装成功可以尝试运行`nengo-gui`界面：`$: nengo`\n\nnengo-dl安装命令：\n\n1. 安装依赖的tensorflow：`conda install tensorflow`\n2. 安装nengo-dl: `pip install nengo-dl`\n\n## 使用\n\nnengo有两种使用模式：GUI和Python解释器。Python解释器模式下，nengo的表现就是一个普通的Python库，因此下面仅介绍GUI模式的使用方式及限制。\n\n### GUI模式\n\n直接在命令行运行`$:nengo`即可在网页中运行图形界面。此时左侧会展示当前图的结构（方形表示`Nodes`，圆形表示`Ensembles`, 圆角矩形表示`Networks`），右侧展示对应的代码。\n\n可以点击左上角的文件夹图标可以运行很多内建的例子，例如`/built-in examples/tutorial/15-lorenz.py`可以运行一个洛伦兹吸引子的例子，效果很酷。\n\n需要注意的是，GUI模式下代码有如下限制：\n\n1. 顶层网络必须叫`model`\n2. 不能构建`Simulator对象`\n3. 不能使用`Matplotlib`绘图\n\n### 核心概念\n\n![架构](../images/ecosystem.svg)\n\n上图Nengo Core主要包含五个核心Nengo对象和一个基于Numpy的模拟器。五个对象如下：\n\n1. nengo.Network： 一个网络可以包含ensembles、nodes、connections和其它网络\n2. nengo.Ensemble：一组神经元，用于表征一个向量\n   1. nengo.ensemble.Neurons: 用于连接ensemble中特定神经元的接口\n3. Node：用于提供输入以及处理输出\n4. Connection：连接两个对象 **NOTE: 和TensorFlow等不同，连接作为一个独立的对象，方便进行独立的设置**\n   1. nengo.connection.LearningRule：为连接制定学习规则\n5. Probe：用于将对象的数据在模拟器运行时取出\n\n### Nengo-DL Demo: Relu VS Spiking neurons\n\n下面的例子会展示Relu作为激活神经元和脉冲神经元的差异。\n\n```python\nimport matplotlib.pyplot as plt\nimport nengo\nfrom nengo.utils.matplotlib import rasterplot\nimport numpy as np\nimport nengo_dl\n\nwith nengo.Network() as net:\n    # 输入节点，周期为1s的正弦波\n    a = nengo.Node(lambda t: np.sin(2 * np.pi * t))\n\n    # rate神经元，功能和Relu一致\n    b_rate = nengo.Ensemble(10, 1, neuron_type=nengo.RectifiedLinear(), seed=2)\n    nengo.Connection(a, b_rate)\n\n    # spiking神经元\n    b_spike = nengo.Ensemble(10, 1, neuron_type=nengo.SpikingRectifiedLinear(), seed=2)\n    nengo.Connection(a, b_spike)\n\n    # 模拟时取出输入输出数据\n    p_a = nengo.Probe(a)\n    p_rate = nengo.Probe(b_rate.neurons)\n    p_spike = nengo.Probe(b_spike.neurons)\n\nwith nengo_dl.Simulator(net) as sim:\n    # 运行模拟1S，上述Probe数据会被保存在sim.data字典中\n    sim.run_steps(1000)\n\nplt.figure()\nplt.plot(sim.trange(), sim.data[p_a])\nplt.xlabel(\"time\")\nplt.ylabel(\"input value\")\nplt.title(\"a\")\n\nplt.figure()\nplt.plot(sim.trange(), sim.data[p_rate])\nplt.xlabel(\"time\")\nplt.ylabel(\"firing rate\")\nplt.title(\"b_rate\")\n\nplt.figure()\n# 时间栅格图，Spiking神经元的的脉冲事件出现与否以栅格形式展示\nrasterplot(sim.trange(), sim.data[p_spike])\nplt.xlabel(\"time\")\nplt.ylabel(\"neuron\")\nplt.title(\"b_spike\")\nplt.show()\n```\n\n上面代码运行的结果如下：\n\n![a](../images/a.png)\n\n![a](../images/relu.png)\n\n![a](../images/raster.png)\n\n可以看到每个神经元的初始连接权重及bias不同，因此对输入信号的相应略有不同；spiking neurons会在电压超过0时产生脉冲发射事件，注意图二和图三中的颜色对应，我们还可以观察到电压值越高，对应的脉冲发射频率越高。","source":"_posts/SNN-4-Nengo.md","raw":"---\ntitle: 'SNN[4]: Nengo'\ndate: 2020-07-06 15:56:34\ncategories: AI\ntags: SNN, Deep Learning\nmathjax: true\n---\n\n# SNN学习笔记4： Nengo\n\n[Nengo](https://www.nengo.ai/) 是一个用于神经建模框架，其扩展[NengoDL](https://nengo.ai/nengo-dl/)支持混用包含了生物细节的神经模型和现在流行的深度学习框架（例如：TensorFlow）。\n\n## 安装\n\nnengo安装命令：`pip install nengo nengo-gui`\n\n测试是否安装成功可以尝试运行`nengo-gui`界面：`$: nengo`\n\nnengo-dl安装命令：\n\n1. 安装依赖的tensorflow：`conda install tensorflow`\n2. 安装nengo-dl: `pip install nengo-dl`\n\n## 使用\n\nnengo有两种使用模式：GUI和Python解释器。Python解释器模式下，nengo的表现就是一个普通的Python库，因此下面仅介绍GUI模式的使用方式及限制。\n\n### GUI模式\n\n直接在命令行运行`$:nengo`即可在网页中运行图形界面。此时左侧会展示当前图的结构（方形表示`Nodes`，圆形表示`Ensembles`, 圆角矩形表示`Networks`），右侧展示对应的代码。\n\n可以点击左上角的文件夹图标可以运行很多内建的例子，例如`/built-in examples/tutorial/15-lorenz.py`可以运行一个洛伦兹吸引子的例子，效果很酷。\n\n需要注意的是，GUI模式下代码有如下限制：\n\n1. 顶层网络必须叫`model`\n2. 不能构建`Simulator对象`\n3. 不能使用`Matplotlib`绘图\n\n### 核心概念\n\n![架构](../images/ecosystem.svg)\n\n上图Nengo Core主要包含五个核心Nengo对象和一个基于Numpy的模拟器。五个对象如下：\n\n1. nengo.Network： 一个网络可以包含ensembles、nodes、connections和其它网络\n2. nengo.Ensemble：一组神经元，用于表征一个向量\n   1. nengo.ensemble.Neurons: 用于连接ensemble中特定神经元的接口\n3. Node：用于提供输入以及处理输出\n4. Connection：连接两个对象 **NOTE: 和TensorFlow等不同，连接作为一个独立的对象，方便进行独立的设置**\n   1. nengo.connection.LearningRule：为连接制定学习规则\n5. Probe：用于将对象的数据在模拟器运行时取出\n\n### Nengo-DL Demo: Relu VS Spiking neurons\n\n下面的例子会展示Relu作为激活神经元和脉冲神经元的差异。\n\n```python\nimport matplotlib.pyplot as plt\nimport nengo\nfrom nengo.utils.matplotlib import rasterplot\nimport numpy as np\nimport nengo_dl\n\nwith nengo.Network() as net:\n    # 输入节点，周期为1s的正弦波\n    a = nengo.Node(lambda t: np.sin(2 * np.pi * t))\n\n    # rate神经元，功能和Relu一致\n    b_rate = nengo.Ensemble(10, 1, neuron_type=nengo.RectifiedLinear(), seed=2)\n    nengo.Connection(a, b_rate)\n\n    # spiking神经元\n    b_spike = nengo.Ensemble(10, 1, neuron_type=nengo.SpikingRectifiedLinear(), seed=2)\n    nengo.Connection(a, b_spike)\n\n    # 模拟时取出输入输出数据\n    p_a = nengo.Probe(a)\n    p_rate = nengo.Probe(b_rate.neurons)\n    p_spike = nengo.Probe(b_spike.neurons)\n\nwith nengo_dl.Simulator(net) as sim:\n    # 运行模拟1S，上述Probe数据会被保存在sim.data字典中\n    sim.run_steps(1000)\n\nplt.figure()\nplt.plot(sim.trange(), sim.data[p_a])\nplt.xlabel(\"time\")\nplt.ylabel(\"input value\")\nplt.title(\"a\")\n\nplt.figure()\nplt.plot(sim.trange(), sim.data[p_rate])\nplt.xlabel(\"time\")\nplt.ylabel(\"firing rate\")\nplt.title(\"b_rate\")\n\nplt.figure()\n# 时间栅格图，Spiking神经元的的脉冲事件出现与否以栅格形式展示\nrasterplot(sim.trange(), sim.data[p_spike])\nplt.xlabel(\"time\")\nplt.ylabel(\"neuron\")\nplt.title(\"b_spike\")\nplt.show()\n```\n\n上面代码运行的结果如下：\n\n![a](../images/a.png)\n\n![a](../images/relu.png)\n\n![a](../images/raster.png)\n\n可以看到每个神经元的初始连接权重及bias不同，因此对输入信号的相应略有不同；spiking neurons会在电压超过0时产生脉冲发射事件，注意图二和图三中的颜色对应，我们还可以观察到电压值越高，对应的脉冲发射频率越高。","slug":"SNN-4-Nengo","published":1,"updated":"2020-07-07T02:10:19.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9uco0005ys1d8i39bbjv","content":"<h1 id=\"SNN学习笔记4：-Nengo\"><a href=\"#SNN学习笔记4：-Nengo\" class=\"headerlink\" title=\"SNN学习笔记4： Nengo\"></a>SNN学习笔记4： Nengo</h1><p><a href=\"https://www.nengo.ai/\" target=\"_blank\" rel=\"noopener\">Nengo</a> 是一个用于神经建模框架，其扩展<a href=\"https://nengo.ai/nengo-dl/\" target=\"_blank\" rel=\"noopener\">NengoDL</a>支持混用包含了生物细节的神经模型和现在流行的深度学习框架（例如：TensorFlow）。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>nengo安装命令：<code>pip install nengo nengo-gui</code></p>\n<p>测试是否安装成功可以尝试运行<code>nengo-gui</code>界面：<code>$: nengo</code></p>\n<p>nengo-dl安装命令：</p>\n<ol>\n<li>安装依赖的tensorflow：<code>conda install tensorflow</code></li>\n<li>安装nengo-dl: <code>pip install nengo-dl</code></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>nengo有两种使用模式：GUI和Python解释器。Python解释器模式下，nengo的表现就是一个普通的Python库，因此下面仅介绍GUI模式的使用方式及限制。</p>\n<h3 id=\"GUI模式\"><a href=\"#GUI模式\" class=\"headerlink\" title=\"GUI模式\"></a>GUI模式</h3><p>直接在命令行运行<code>$:nengo</code>即可在网页中运行图形界面。此时左侧会展示当前图的结构（方形表示<code>Nodes</code>，圆形表示<code>Ensembles</code>, 圆角矩形表示<code>Networks</code>），右侧展示对应的代码。</p>\n<p>可以点击左上角的文件夹图标可以运行很多内建的例子，例如<code>/built-in examples/tutorial/15-lorenz.py</code>可以运行一个洛伦兹吸引子的例子，效果很酷。</p>\n<p>需要注意的是，GUI模式下代码有如下限制：</p>\n<ol>\n<li>顶层网络必须叫<code>model</code></li>\n<li>不能构建<code>Simulator对象</code></li>\n<li>不能使用<code>Matplotlib</code>绘图</li>\n</ol>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><p><img src=\"../images/ecosystem.svg\" alt=\"架构\"></p>\n<p>上图Nengo Core主要包含五个核心Nengo对象和一个基于Numpy的模拟器。五个对象如下：</p>\n<ol>\n<li>nengo.Network： 一个网络可以包含ensembles、nodes、connections和其它网络</li>\n<li>nengo.Ensemble：一组神经元，用于表征一个向量<ol>\n<li>nengo.ensemble.Neurons: 用于连接ensemble中特定神经元的接口</li>\n</ol>\n</li>\n<li>Node：用于提供输入以及处理输出</li>\n<li>Connection：连接两个对象 <strong>NOTE: 和TensorFlow等不同，连接作为一个独立的对象，方便进行独立的设置</strong><ol>\n<li>nengo.connection.LearningRule：为连接制定学习规则</li>\n</ol>\n</li>\n<li>Probe：用于将对象的数据在模拟器运行时取出</li>\n</ol>\n<h3 id=\"Nengo-DL-Demo-Relu-VS-Spiking-neurons\"><a href=\"#Nengo-DL-Demo-Relu-VS-Spiking-neurons\" class=\"headerlink\" title=\"Nengo-DL Demo: Relu VS Spiking neurons\"></a>Nengo-DL Demo: Relu VS Spiking neurons</h3><p>下面的例子会展示Relu作为激活神经元和脉冲神经元的差异。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.utils.matplotlib <span class=\"keyword\">import</span> rasterplot</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo_dl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo.Network() <span class=\"keyword\">as</span> net:</span><br><span class=\"line\">    <span class=\"comment\"># 输入节点，周期为1s的正弦波</span></span><br><span class=\"line\">    a = nengo.Node(<span class=\"keyword\">lambda</span> t: np.sin(<span class=\"number\">2</span> * np.pi * t))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># rate神经元，功能和Relu一致</span></span><br><span class=\"line\">    b_rate = nengo.Ensemble(<span class=\"number\">10</span>, <span class=\"number\">1</span>, neuron_type=nengo.RectifiedLinear(), seed=<span class=\"number\">2</span>)</span><br><span class=\"line\">    nengo.Connection(a, b_rate)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># spiking神经元</span></span><br><span class=\"line\">    b_spike = nengo.Ensemble(<span class=\"number\">10</span>, <span class=\"number\">1</span>, neuron_type=nengo.SpikingRectifiedLinear(), seed=<span class=\"number\">2</span>)</span><br><span class=\"line\">    nengo.Connection(a, b_spike)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 模拟时取出输入输出数据</span></span><br><span class=\"line\">    p_a = nengo.Probe(a)</span><br><span class=\"line\">    p_rate = nengo.Probe(b_rate.neurons)</span><br><span class=\"line\">    p_spike = nengo.Probe(b_spike.neurons)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo_dl.Simulator(net) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">    <span class=\"comment\"># 运行模拟1S，上述Probe数据会被保存在sim.data字典中</span></span><br><span class=\"line\">    sim.run_steps(<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\">plt.plot(sim.trange(), sim.data[p_a])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"input value\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\">plt.plot(sim.trange(), sim.data[p_rate])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"firing rate\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"b_rate\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\"><span class=\"comment\"># 时间栅格图，Spiking神经元的的脉冲事件出现与否以栅格形式展示</span></span><br><span class=\"line\">rasterplot(sim.trange(), sim.data[p_spike])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"neuron\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"b_spike\"</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p>上面代码运行的结果如下：</p>\n<p><img src=\"../images/a.png\" alt=\"a\"></p>\n<p><img src=\"../images/relu.png\" alt=\"a\"></p>\n<p><img src=\"../images/raster.png\" alt=\"a\"></p>\n<p>可以看到每个神经元的初始连接权重及bias不同，因此对输入信号的相应略有不同；spiking neurons会在电压超过0时产生脉冲发射事件，注意图二和图三中的颜色对应，我们还可以观察到电压值越高，对应的脉冲发射频率越高。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SNN学习笔记4：-Nengo\"><a href=\"#SNN学习笔记4：-Nengo\" class=\"headerlink\" title=\"SNN学习笔记4： Nengo\"></a>SNN学习笔记4： Nengo</h1><p><a href=\"https://www.nengo.ai/\" target=\"_blank\" rel=\"noopener\">Nengo</a> 是一个用于神经建模框架，其扩展<a href=\"https://nengo.ai/nengo-dl/\" target=\"_blank\" rel=\"noopener\">NengoDL</a>支持混用包含了生物细节的神经模型和现在流行的深度学习框架（例如：TensorFlow）。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>nengo安装命令：<code>pip install nengo nengo-gui</code></p>\n<p>测试是否安装成功可以尝试运行<code>nengo-gui</code>界面：<code>$: nengo</code></p>\n<p>nengo-dl安装命令：</p>\n<ol>\n<li>安装依赖的tensorflow：<code>conda install tensorflow</code></li>\n<li>安装nengo-dl: <code>pip install nengo-dl</code></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>nengo有两种使用模式：GUI和Python解释器。Python解释器模式下，nengo的表现就是一个普通的Python库，因此下面仅介绍GUI模式的使用方式及限制。</p>\n<h3 id=\"GUI模式\"><a href=\"#GUI模式\" class=\"headerlink\" title=\"GUI模式\"></a>GUI模式</h3><p>直接在命令行运行<code>$:nengo</code>即可在网页中运行图形界面。此时左侧会展示当前图的结构（方形表示<code>Nodes</code>，圆形表示<code>Ensembles</code>, 圆角矩形表示<code>Networks</code>），右侧展示对应的代码。</p>\n<p>可以点击左上角的文件夹图标可以运行很多内建的例子，例如<code>/built-in examples/tutorial/15-lorenz.py</code>可以运行一个洛伦兹吸引子的例子，效果很酷。</p>\n<p>需要注意的是，GUI模式下代码有如下限制：</p>\n<ol>\n<li>顶层网络必须叫<code>model</code></li>\n<li>不能构建<code>Simulator对象</code></li>\n<li>不能使用<code>Matplotlib</code>绘图</li>\n</ol>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><p><img src=\"../images/ecosystem.svg\" alt=\"架构\"></p>\n<p>上图Nengo Core主要包含五个核心Nengo对象和一个基于Numpy的模拟器。五个对象如下：</p>\n<ol>\n<li>nengo.Network： 一个网络可以包含ensembles、nodes、connections和其它网络</li>\n<li>nengo.Ensemble：一组神经元，用于表征一个向量<ol>\n<li>nengo.ensemble.Neurons: 用于连接ensemble中特定神经元的接口</li>\n</ol>\n</li>\n<li>Node：用于提供输入以及处理输出</li>\n<li>Connection：连接两个对象 <strong>NOTE: 和TensorFlow等不同，连接作为一个独立的对象，方便进行独立的设置</strong><ol>\n<li>nengo.connection.LearningRule：为连接制定学习规则</li>\n</ol>\n</li>\n<li>Probe：用于将对象的数据在模拟器运行时取出</li>\n</ol>\n<h3 id=\"Nengo-DL-Demo-Relu-VS-Spiking-neurons\"><a href=\"#Nengo-DL-Demo-Relu-VS-Spiking-neurons\" class=\"headerlink\" title=\"Nengo-DL Demo: Relu VS Spiking neurons\"></a>Nengo-DL Demo: Relu VS Spiking neurons</h3><p>下面的例子会展示Relu作为激活神经元和脉冲神经元的差异。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">from</span> nengo.utils.matplotlib <span class=\"keyword\">import</span> rasterplot</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> nengo_dl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo.Network() <span class=\"keyword\">as</span> net:</span><br><span class=\"line\">    <span class=\"comment\"># 输入节点，周期为1s的正弦波</span></span><br><span class=\"line\">    a = nengo.Node(<span class=\"keyword\">lambda</span> t: np.sin(<span class=\"number\">2</span> * np.pi * t))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># rate神经元，功能和Relu一致</span></span><br><span class=\"line\">    b_rate = nengo.Ensemble(<span class=\"number\">10</span>, <span class=\"number\">1</span>, neuron_type=nengo.RectifiedLinear(), seed=<span class=\"number\">2</span>)</span><br><span class=\"line\">    nengo.Connection(a, b_rate)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># spiking神经元</span></span><br><span class=\"line\">    b_spike = nengo.Ensemble(<span class=\"number\">10</span>, <span class=\"number\">1</span>, neuron_type=nengo.SpikingRectifiedLinear(), seed=<span class=\"number\">2</span>)</span><br><span class=\"line\">    nengo.Connection(a, b_spike)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 模拟时取出输入输出数据</span></span><br><span class=\"line\">    p_a = nengo.Probe(a)</span><br><span class=\"line\">    p_rate = nengo.Probe(b_rate.neurons)</span><br><span class=\"line\">    p_spike = nengo.Probe(b_spike.neurons)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> nengo_dl.Simulator(net) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">    <span class=\"comment\"># 运行模拟1S，上述Probe数据会被保存在sim.data字典中</span></span><br><span class=\"line\">    sim.run_steps(<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\">plt.plot(sim.trange(), sim.data[p_a])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"input value\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\">plt.plot(sim.trange(), sim.data[p_rate])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"firing rate\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"b_rate\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.figure()</span><br><span class=\"line\"><span class=\"comment\"># 时间栅格图，Spiking神经元的的脉冲事件出现与否以栅格形式展示</span></span><br><span class=\"line\">rasterplot(sim.trange(), sim.data[p_spike])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"time\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"neuron\"</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">\"b_spike\"</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p>上面代码运行的结果如下：</p>\n<p><img src=\"../images/a.png\" alt=\"a\"></p>\n<p><img src=\"../images/relu.png\" alt=\"a\"></p>\n<p><img src=\"../images/raster.png\" alt=\"a\"></p>\n<p>可以看到每个神经元的初始连接权重及bias不同，因此对输入信号的相应略有不同；spiking neurons会在电压超过0时产生脉冲发射事件，注意图二和图三中的颜色对应，我们还可以观察到电压值越高，对应的脉冲发射频率越高。</p>\n"},{"title":"pybind11 install","date":"2020-07-02T11:26:50.000Z","_content":"\n# Pybind11 安装及简单使用\n\n之前项目里用到了pybind11，效果强大&很好用。但是由于那个项目整个工程直接包含了pybind11的头文件和构建脚本，因此无需自己动手折腾pybind11的环境和构建。最近自己想用pybind11做些POC的小实验，在此记录一些搭建环境的过程。\n\n## 安装\n\n1. 依赖安装：`sudo apt-get install python-dev cmake`\n2. pybind11 python: `conda install pybind11`\n3. pybind11 安装：\n   1. 下载repo：`git clone https://github.com/pybind/pybind11.git`\n   2. `cd pybind11`\n   3. `mkdir build`\n   4. `cd build`\n   5. `cmake ..`\n   6. `make check -j8`\n\n## 使用\n\n尝试编译官网的玩具样例，代码如下（保存到文件`toy.cc`）:\n\n```c++\n#include <pybind11/pybind11.h>\n\nint add(int i, int j) {\n  return i + j;\n}\n\nPYBIND11_MODULE(example, m) {\n  m.doc() = \"pybind11 example plugin\";\n  m.def(\"add\", &add, \"A function which adds two numbers\");\n}\n```\n\n编译命令：\n\n```\nc++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` toy.cc -o shared`python3-config --extension-suffix`\n```\n\nNOTE: 上述命令初看很唬人，我们尝试运行一下`python3 -m pybind11 --includes`和`python3-config --extension-suffix`, 得到的结果如下：`-I/home/xxx/anaconda3/envs/mindspore/include/python3.7m -I/home/xxx/anaconda3/envs/mindspore/include`, `.cpython-37m-x86_64-linux-gnu.so`。","source":"_posts/pybind11-install.md","raw":"---\ntitle: pybind11 install\ndate: 2020-07-02 19:26:50\ncategories: 编程\ntags: pybind11, c++, python\n---\n\n# Pybind11 安装及简单使用\n\n之前项目里用到了pybind11，效果强大&很好用。但是由于那个项目整个工程直接包含了pybind11的头文件和构建脚本，因此无需自己动手折腾pybind11的环境和构建。最近自己想用pybind11做些POC的小实验，在此记录一些搭建环境的过程。\n\n## 安装\n\n1. 依赖安装：`sudo apt-get install python-dev cmake`\n2. pybind11 python: `conda install pybind11`\n3. pybind11 安装：\n   1. 下载repo：`git clone https://github.com/pybind/pybind11.git`\n   2. `cd pybind11`\n   3. `mkdir build`\n   4. `cd build`\n   5. `cmake ..`\n   6. `make check -j8`\n\n## 使用\n\n尝试编译官网的玩具样例，代码如下（保存到文件`toy.cc`）:\n\n```c++\n#include <pybind11/pybind11.h>\n\nint add(int i, int j) {\n  return i + j;\n}\n\nPYBIND11_MODULE(example, m) {\n  m.doc() = \"pybind11 example plugin\";\n  m.def(\"add\", &add, \"A function which adds two numbers\");\n}\n```\n\n编译命令：\n\n```\nc++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` toy.cc -o shared`python3-config --extension-suffix`\n```\n\nNOTE: 上述命令初看很唬人，我们尝试运行一下`python3 -m pybind11 --includes`和`python3-config --extension-suffix`, 得到的结果如下：`-I/home/xxx/anaconda3/envs/mindspore/include/python3.7m -I/home/xxx/anaconda3/envs/mindspore/include`, `.cpython-37m-x86_64-linux-gnu.so`。","slug":"pybind11-install","published":1,"updated":"2020-07-02T12:05:46.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9ucp0006ys1d39py6uhg","content":"<h1 id=\"Pybind11-安装及简单使用\"><a href=\"#Pybind11-安装及简单使用\" class=\"headerlink\" title=\"Pybind11 安装及简单使用\"></a>Pybind11 安装及简单使用</h1><p>之前项目里用到了pybind11，效果强大&amp;很好用。但是由于那个项目整个工程直接包含了pybind11的头文件和构建脚本，因此无需自己动手折腾pybind11的环境和构建。最近自己想用pybind11做些POC的小实验，在此记录一些搭建环境的过程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li>依赖安装：<code>sudo apt-get install python-dev cmake</code></li>\n<li>pybind11 python: <code>conda install pybind11</code></li>\n<li>pybind11 安装：<ol>\n<li>下载repo：<code>git clone https://github.com/pybind/pybind11.git</code></li>\n<li><code>cd pybind11</code></li>\n<li><code>mkdir build</code></li>\n<li><code>cd build</code></li>\n<li><code>cmake ..</code></li>\n<li><code>make check -j8</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>尝试编译官网的玩具样例，代码如下（保存到文件<code>toy.cc</code>）:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  m.doc() = <span class=\"string\">\"pybind11 example plugin\"</span>;</span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c++ -O3 -Wall -shared -std&#x3D;c++11 -fPIC &#96;python3 -m pybind11 --includes&#96; toy.cc -o shared&#96;python3-config --extension-suffix&#96;</span><br></pre></td></tr></table></figure>\n<p>NOTE: 上述命令初看很唬人，我们尝试运行一下<code>python3 -m pybind11 --includes</code>和<code>python3-config --extension-suffix</code>, 得到的结果如下：<code>-I/home/xxx/anaconda3/envs/mindspore/include/python3.7m -I/home/xxx/anaconda3/envs/mindspore/include</code>, <code>.cpython-37m-x86_64-linux-gnu.so</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pybind11-安装及简单使用\"><a href=\"#Pybind11-安装及简单使用\" class=\"headerlink\" title=\"Pybind11 安装及简单使用\"></a>Pybind11 安装及简单使用</h1><p>之前项目里用到了pybind11，效果强大&amp;很好用。但是由于那个项目整个工程直接包含了pybind11的头文件和构建脚本，因此无需自己动手折腾pybind11的环境和构建。最近自己想用pybind11做些POC的小实验，在此记录一些搭建环境的过程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li>依赖安装：<code>sudo apt-get install python-dev cmake</code></li>\n<li>pybind11 python: <code>conda install pybind11</code></li>\n<li>pybind11 安装：<ol>\n<li>下载repo：<code>git clone https://github.com/pybind/pybind11.git</code></li>\n<li><code>cd pybind11</code></li>\n<li><code>mkdir build</code></li>\n<li><code>cd build</code></li>\n<li><code>cmake ..</code></li>\n<li><code>make check -j8</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>尝试编译官网的玩具样例，代码如下（保存到文件<code>toy.cc</code>）:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  m.doc() = <span class=\"string\">\"pybind11 example plugin\"</span>;</span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c++ -O3 -Wall -shared -std&#x3D;c++11 -fPIC &#96;python3 -m pybind11 --includes&#96; toy.cc -o shared&#96;python3-config --extension-suffix&#96;</span><br></pre></td></tr></table></figure>\n<p>NOTE: 上述命令初看很唬人，我们尝试运行一下<code>python3 -m pybind11 --includes</code>和<code>python3-config --extension-suffix</code>, 得到的结果如下：<code>-I/home/xxx/anaconda3/envs/mindspore/include/python3.7m -I/home/xxx/anaconda3/envs/mindspore/include</code>, <code>.cpython-37m-x86_64-linux-gnu.so</code>。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-06-30T02:43:43.794Z","updated":"2020-06-30T02:43:43.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9ucr000ays1dhj7q9322","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"expression template and CRTP","date":"2020-07-01T00:52:02.000Z","_content":"\n# 表达式模板和静态多态\n\n表达式模板（[expression template](https://www.en.wikipedia.org/wiki/Expression_templates)）是一种模板元编程技术，在编译期间延迟计算的求值，并构造表达计算的结构（expression tree）。利用expression tree的变换，可以实现运行前的自动循环融合（loop fusion）等功能。\n\n静态多态（也叫[CRTP](https://www.en.wikipedia.org/wiki/Curiously_recurring_template_pattern)）用一个模板基类来在编译期完成多态的实际实现的分发(与运行时使用`virtual` `override`的多态机制相对, 因此叫静态多态)，不同类型的子类将自身类型作为基类的模板参数来继承，以此通知基类将对应类型的调用分发给自己。静态多态消除了动态多态的开销，可以提升运行时性能，经常和表达式模板一起使用。\n\n## 静态多态demo\n\n下面以一个简单demo展示上述静态多态的原理和用法：\n\n```c++\n#include <iostream>\n#include <vector>\n\ntemplate <class T>\nstruct Animal {\n  void Say() {\n    static_cast<T*>(this)->Say_();\n  }\n};\n\nstruct Dog : Animal<Dog> {\n  void Say_() {\n    std::cout << \"wang wang wang!\" << std::endl;\n  }\n};\n\nstruct Cat : Animal<Cat> {\n  void Say_() {\n    std::cout << \"meow meow meow~\" << std::endl;\n  }\n};\n\nclass Zoo {\n public:\n  template <class T>\n  void AddAnimal(Animal<T> animal) {\n    animal.Say();\n  }\n};\n\nint main() {\n  Dog dog{};\n  Cat cat{};\n  Zoo zoo{};\n  zoo.AddAnimal(dog);\n  zoo.AddAnimal(cat);\n  return 0;\n}\n```\n\n## 表达式模板demo\n\n[wiki](https://www.en.wikipedia.org/wiki/Expression_templates)上给出了一个表达式模板很好的例子，对vector加法进行循环融合。原理大致如下：\n\n1. 将+法操作符封装为表达式求和类型VecSum的构造函数，因此在+法时不进行实际的求值，而是进行表达式树的构建\n2. 在对Vec进行赋值操作时进行表达式求值，此时对VecSum表达式中的`[]`操作符递归调用，直到完成实际的求和。\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <vector>\n#include <assert.h>\n\ntemplate <typename E>\nclass VecExpression {\n  public:\n    double operator[](size_t i) const {\n      return static_cast<E const&>(*this)[i];\n    }\n    size_t size() const {return static_cast<E const&>(*this).size();}\n};\n\nclass Vec : public VecExpression<Vec> {\n  std::vector<double> elems;\n\n public:\n  double operator[](size_t i) const { return elems[i];}\n  double &operator[](size_t i) { return elems[i]; }\n  size_t size() const { return elems.size();}\n\n  Vec(size_t n) : elems(n) {}\n  Vec(std::initializer_list<double> init) : elems(init) {};\n\n  // 从VecExpression构建Vec, 此时对表达式求值\n  template <typename E>\n  Vec(VecExpression<E> const& expr) : elems(expr.size()) {\n    for (size_t i = 0; i != expr.size(); i++) {\n      elems[i] = expr[i];\n    }\n  }  \n\n  void dump() {\n    for (auto &elem : elems) {\n      std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n  }\n};\n\n// 静态多态\ntemplate <typename E1, typename E2>\nclass VecSum : public VecExpression<VecSum<E1, E2>> {\n  E1 const& _u;\n  E2 const& _v;\n\n public:\n  VecSum(E1 const &u, E2 const &v) : _u(u), _v(v) {\n    assert(u.size() == v.size());\n  }\n // Vec的构造函数中被调用，此时求值\n  double operator[](size_t i) const { return _u[i] + _v[i]; }\n  size_t size() const { return _v.size(); }\n};\n\n// 将VecSum的构造函数封装成+运算符\ntemplate <typename E1, typename E2>\nVecSum<E1, E2> operator+(VecExpression<E1> const &u, VecExpression<E2> const &v) {\n  std::cout << __PRETTY_FUNCTION__ << std::endl;\n  return VecSum<E1, E2>(*static_cast<const E1*>(&u), *static_cast<const E2*>(&v));\n}\n\nint main() {\n  Vec v0 = {1, 1, 1};\n  Vec v1 = {2, 2, 2};\n  Vec v2 = {3, 3, 3};\n  Vec v3 = {4, 5, 6};\n\n  Vec sum = v0 + v1 + v2 + v3;\n  sum.dump();\n  return 0;\n}\n```\n\n输出如下：\n\n```\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = Vec; E2 = Vec]\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = VecSum<Vec, Vec>; E2 = Vec]\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = VecSum<VecSum<Vec, Vec>, Vec>; E2 = Vec]\n10 11 12 \n\n```\n\n\n\n","source":"_posts/expression-template.md","raw":"---\ntitle: expression template and CRTP\ndate: 2020-07-01 08:52:02\ncategory: 编程\ntags: c++\n---\n\n# 表达式模板和静态多态\n\n表达式模板（[expression template](https://www.en.wikipedia.org/wiki/Expression_templates)）是一种模板元编程技术，在编译期间延迟计算的求值，并构造表达计算的结构（expression tree）。利用expression tree的变换，可以实现运行前的自动循环融合（loop fusion）等功能。\n\n静态多态（也叫[CRTP](https://www.en.wikipedia.org/wiki/Curiously_recurring_template_pattern)）用一个模板基类来在编译期完成多态的实际实现的分发(与运行时使用`virtual` `override`的多态机制相对, 因此叫静态多态)，不同类型的子类将自身类型作为基类的模板参数来继承，以此通知基类将对应类型的调用分发给自己。静态多态消除了动态多态的开销，可以提升运行时性能，经常和表达式模板一起使用。\n\n## 静态多态demo\n\n下面以一个简单demo展示上述静态多态的原理和用法：\n\n```c++\n#include <iostream>\n#include <vector>\n\ntemplate <class T>\nstruct Animal {\n  void Say() {\n    static_cast<T*>(this)->Say_();\n  }\n};\n\nstruct Dog : Animal<Dog> {\n  void Say_() {\n    std::cout << \"wang wang wang!\" << std::endl;\n  }\n};\n\nstruct Cat : Animal<Cat> {\n  void Say_() {\n    std::cout << \"meow meow meow~\" << std::endl;\n  }\n};\n\nclass Zoo {\n public:\n  template <class T>\n  void AddAnimal(Animal<T> animal) {\n    animal.Say();\n  }\n};\n\nint main() {\n  Dog dog{};\n  Cat cat{};\n  Zoo zoo{};\n  zoo.AddAnimal(dog);\n  zoo.AddAnimal(cat);\n  return 0;\n}\n```\n\n## 表达式模板demo\n\n[wiki](https://www.en.wikipedia.org/wiki/Expression_templates)上给出了一个表达式模板很好的例子，对vector加法进行循环融合。原理大致如下：\n\n1. 将+法操作符封装为表达式求和类型VecSum的构造函数，因此在+法时不进行实际的求值，而是进行表达式树的构建\n2. 在对Vec进行赋值操作时进行表达式求值，此时对VecSum表达式中的`[]`操作符递归调用，直到完成实际的求和。\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <vector>\n#include <assert.h>\n\ntemplate <typename E>\nclass VecExpression {\n  public:\n    double operator[](size_t i) const {\n      return static_cast<E const&>(*this)[i];\n    }\n    size_t size() const {return static_cast<E const&>(*this).size();}\n};\n\nclass Vec : public VecExpression<Vec> {\n  std::vector<double> elems;\n\n public:\n  double operator[](size_t i) const { return elems[i];}\n  double &operator[](size_t i) { return elems[i]; }\n  size_t size() const { return elems.size();}\n\n  Vec(size_t n) : elems(n) {}\n  Vec(std::initializer_list<double> init) : elems(init) {};\n\n  // 从VecExpression构建Vec, 此时对表达式求值\n  template <typename E>\n  Vec(VecExpression<E> const& expr) : elems(expr.size()) {\n    for (size_t i = 0; i != expr.size(); i++) {\n      elems[i] = expr[i];\n    }\n  }  \n\n  void dump() {\n    for (auto &elem : elems) {\n      std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n  }\n};\n\n// 静态多态\ntemplate <typename E1, typename E2>\nclass VecSum : public VecExpression<VecSum<E1, E2>> {\n  E1 const& _u;\n  E2 const& _v;\n\n public:\n  VecSum(E1 const &u, E2 const &v) : _u(u), _v(v) {\n    assert(u.size() == v.size());\n  }\n // Vec的构造函数中被调用，此时求值\n  double operator[](size_t i) const { return _u[i] + _v[i]; }\n  size_t size() const { return _v.size(); }\n};\n\n// 将VecSum的构造函数封装成+运算符\ntemplate <typename E1, typename E2>\nVecSum<E1, E2> operator+(VecExpression<E1> const &u, VecExpression<E2> const &v) {\n  std::cout << __PRETTY_FUNCTION__ << std::endl;\n  return VecSum<E1, E2>(*static_cast<const E1*>(&u), *static_cast<const E2*>(&v));\n}\n\nint main() {\n  Vec v0 = {1, 1, 1};\n  Vec v1 = {2, 2, 2};\n  Vec v2 = {3, 3, 3};\n  Vec v3 = {4, 5, 6};\n\n  Vec sum = v0 + v1 + v2 + v3;\n  sum.dump();\n  return 0;\n}\n```\n\n输出如下：\n\n```\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = Vec; E2 = Vec]\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = VecSum<Vec, Vec>; E2 = Vec]\nVecSum<E1, E2> operator+(const VecExpression<E>&, const VecExpression<E2>&) [with E1 = VecSum<VecSum<Vec, Vec>, Vec>; E2 = Vec]\n10 11 12 \n\n```\n\n\n\n","slug":"expression-template","published":1,"updated":"2020-07-01T03:38:28.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9ucs000cys1d6rvned7p","content":"<h1 id=\"表达式模板和静态多态\"><a href=\"#表达式模板和静态多态\" class=\"headerlink\" title=\"表达式模板和静态多态\"></a>表达式模板和静态多态</h1><p>表达式模板（<a href=\"https://www.en.wikipedia.org/wiki/Expression_templates\" target=\"_blank\" rel=\"noopener\">expression template</a>）是一种模板元编程技术，在编译期间延迟计算的求值，并构造表达计算的结构（expression tree）。利用expression tree的变换，可以实现运行前的自动循环融合（loop fusion）等功能。</p>\n<p>静态多态（也叫<a href=\"https://www.en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" target=\"_blank\" rel=\"noopener\">CRTP</a>）用一个模板基类来在编译期完成多态的实际实现的分发(与运行时使用<code>virtual</code> <code>override</code>的多态机制相对, 因此叫静态多态)，不同类型的子类将自身类型作为基类的模板参数来继承，以此通知基类将对应类型的调用分发给自己。静态多态消除了动态多态的开销，可以提升运行时性能，经常和表达式模板一起使用。</p>\n<h2 id=\"静态多态demo\"><a href=\"#静态多态demo\" class=\"headerlink\" title=\"静态多态demo\"></a>静态多态demo</h2><p>下面以一个简单demo展示上述静态多态的原理和用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static_cast</span>&lt;T*&gt;(<span class=\"keyword\">this</span>)-&gt;Say_();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dog</span> :</span> Animal&lt;Dog&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"wang wang wang!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cat</span> :</span> Animal&lt;Cat&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"meow meow meow~\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zoo</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">AddAnimal</span>(<span class=\"title\">Animal</span>&lt;T&gt; <span class=\"title\">animal</span>) &#123;</span></span><br><span class=\"line\">    animal.Say();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Dog dog&#123;&#125;;</span><br><span class=\"line\">  Cat cat&#123;&#125;;</span><br><span class=\"line\">  Zoo zoo&#123;&#125;;</span><br><span class=\"line\">  zoo.AddAnimal(dog);</span><br><span class=\"line\">  zoo.AddAnimal(cat);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表达式模板demo\"><a href=\"#表达式模板demo\" class=\"headerlink\" title=\"表达式模板demo\"></a>表达式模板demo</h2><p><a href=\"https://www.en.wikipedia.org/wiki/Expression_templates\" target=\"_blank\" rel=\"noopener\">wiki</a>上给出了一个表达式模板很好的例子，对vector加法进行循环融合。原理大致如下：</p>\n<ol>\n<li>将+法操作符封装为表达式求和类型VecSum的构造函数，因此在+法时不进行实际的求值，而是进行表达式树的构建</li>\n<li>在对Vec进行赋值操作时进行表达式求值，此时对VecSum表达式中的<code>[]</code>操作符递归调用，直到完成实际的求和。</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VecExpression</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;E <span class=\"keyword\">const</span>&amp;&gt;(*<span class=\"keyword\">this</span>)[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;E <span class=\"keyword\">const</span>&amp;&gt;(*<span class=\"keyword\">this</span>).<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vec</span> :</span> <span class=\"keyword\">public</span> VecExpression&lt;Vec&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; elems;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> elems[i];&#125;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> &amp;<span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) &#123; <span class=\"keyword\">return</span> elems[i]; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> elems.<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vec(<span class=\"keyword\">size_t</span> n) : elems(n) &#123;&#125;</span><br><span class=\"line\">  Vec(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">double</span>&gt; init) : elems(init) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从VecExpression构建Vec, 此时对表达式求值</span></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E&gt;</span><br><span class=\"line\">  Vec(VecExpression&lt;E&gt; <span class=\"keyword\">const</span>&amp; expr) : elems(expr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != expr.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">      elems[i] = expr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;elem : elems) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态多态</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E1, <span class=\"keyword\">typename</span> E2&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VecSum</span> :</span> <span class=\"keyword\">public</span> VecExpression&lt;VecSum&lt;E1, E2&gt;&gt; &#123;</span><br><span class=\"line\">  E1 <span class=\"keyword\">const</span>&amp; _u;</span><br><span class=\"line\">  E2 <span class=\"keyword\">const</span>&amp; _v;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  VecSum(E1 <span class=\"keyword\">const</span> &amp;u, E2 <span class=\"keyword\">const</span> &amp;v) : _u(u), _v(v) &#123;</span><br><span class=\"line\">    assert(u.<span class=\"built_in\">size</span>() == v.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// Vec的构造函数中被调用，此时求值</span></span><br><span class=\"line\">  <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> _u[i] + _v[i]; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> _v.<span class=\"built_in\">size</span>(); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将VecSum的构造函数封装成+运算符</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E1, <span class=\"keyword\">typename</span> E2&gt;</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; <span class=\"keyword\">operator</span>+(VecExpression&lt;E1&gt; <span class=\"keyword\">const</span> &amp;u, VecExpression&lt;E2&gt; <span class=\"keyword\">const</span> &amp;v) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> VecSum&lt;E1, E2&gt;(*<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> E1*&gt;(&amp;u), *<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> E2*&gt;(&amp;v));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Vec v0 = &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">  Vec v1 = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  Vec v2 = &#123;<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">  Vec v3 = &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vec sum = v0 + v1 + v2 + v3;</span><br><span class=\"line\">  sum.dump();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; Vec; E2 &#x3D; Vec]</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;Vec, Vec&gt;; E2 &#x3D; Vec]</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;VecSum&lt;Vec, Vec&gt;, Vec&gt;; E2 &#x3D; Vec]</span><br><span class=\"line\">10 11 12</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"表达式模板和静态多态\"><a href=\"#表达式模板和静态多态\" class=\"headerlink\" title=\"表达式模板和静态多态\"></a>表达式模板和静态多态</h1><p>表达式模板（<a href=\"https://www.en.wikipedia.org/wiki/Expression_templates\" target=\"_blank\" rel=\"noopener\">expression template</a>）是一种模板元编程技术，在编译期间延迟计算的求值，并构造表达计算的结构（expression tree）。利用expression tree的变换，可以实现运行前的自动循环融合（loop fusion）等功能。</p>\n<p>静态多态（也叫<a href=\"https://www.en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" target=\"_blank\" rel=\"noopener\">CRTP</a>）用一个模板基类来在编译期完成多态的实际实现的分发(与运行时使用<code>virtual</code> <code>override</code>的多态机制相对, 因此叫静态多态)，不同类型的子类将自身类型作为基类的模板参数来继承，以此通知基类将对应类型的调用分发给自己。静态多态消除了动态多态的开销，可以提升运行时性能，经常和表达式模板一起使用。</p>\n<h2 id=\"静态多态demo\"><a href=\"#静态多态demo\" class=\"headerlink\" title=\"静态多态demo\"></a>静态多态demo</h2><p>下面以一个简单demo展示上述静态多态的原理和用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static_cast</span>&lt;T*&gt;(<span class=\"keyword\">this</span>)-&gt;Say_();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dog</span> :</span> Animal&lt;Dog&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"wang wang wang!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cat</span> :</span> Animal&lt;Cat&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Say_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"meow meow meow~\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zoo</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">AddAnimal</span>(<span class=\"title\">Animal</span>&lt;T&gt; <span class=\"title\">animal</span>) &#123;</span></span><br><span class=\"line\">    animal.Say();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Dog dog&#123;&#125;;</span><br><span class=\"line\">  Cat cat&#123;&#125;;</span><br><span class=\"line\">  Zoo zoo&#123;&#125;;</span><br><span class=\"line\">  zoo.AddAnimal(dog);</span><br><span class=\"line\">  zoo.AddAnimal(cat);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表达式模板demo\"><a href=\"#表达式模板demo\" class=\"headerlink\" title=\"表达式模板demo\"></a>表达式模板demo</h2><p><a href=\"https://www.en.wikipedia.org/wiki/Expression_templates\" target=\"_blank\" rel=\"noopener\">wiki</a>上给出了一个表达式模板很好的例子，对vector加法进行循环融合。原理大致如下：</p>\n<ol>\n<li>将+法操作符封装为表达式求和类型VecSum的构造函数，因此在+法时不进行实际的求值，而是进行表达式树的构建</li>\n<li>在对Vec进行赋值操作时进行表达式求值，此时对VecSum表达式中的<code>[]</code>操作符递归调用，直到完成实际的求和。</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VecExpression</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;E <span class=\"keyword\">const</span>&amp;&gt;(*<span class=\"keyword\">this</span>)[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;E <span class=\"keyword\">const</span>&amp;&gt;(*<span class=\"keyword\">this</span>).<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vec</span> :</span> <span class=\"keyword\">public</span> VecExpression&lt;Vec&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; elems;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> elems[i];&#125;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> &amp;<span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) &#123; <span class=\"keyword\">return</span> elems[i]; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> elems.<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vec(<span class=\"keyword\">size_t</span> n) : elems(n) &#123;&#125;</span><br><span class=\"line\">  Vec(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">double</span>&gt; init) : elems(init) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从VecExpression构建Vec, 此时对表达式求值</span></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E&gt;</span><br><span class=\"line\">  Vec(VecExpression&lt;E&gt; <span class=\"keyword\">const</span>&amp; expr) : elems(expr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != expr.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">      elems[i] = expr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;elem : elems) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态多态</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E1, <span class=\"keyword\">typename</span> E2&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VecSum</span> :</span> <span class=\"keyword\">public</span> VecExpression&lt;VecSum&lt;E1, E2&gt;&gt; &#123;</span><br><span class=\"line\">  E1 <span class=\"keyword\">const</span>&amp; _u;</span><br><span class=\"line\">  E2 <span class=\"keyword\">const</span>&amp; _v;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  VecSum(E1 <span class=\"keyword\">const</span> &amp;u, E2 <span class=\"keyword\">const</span> &amp;v) : _u(u), _v(v) &#123;</span><br><span class=\"line\">    assert(u.<span class=\"built_in\">size</span>() == v.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// Vec的构造函数中被调用，此时求值</span></span><br><span class=\"line\">  <span class=\"keyword\">double</span> <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> i) <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> _u[i] + _v[i]; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> _v.<span class=\"built_in\">size</span>(); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将VecSum的构造函数封装成+运算符</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> E1, <span class=\"keyword\">typename</span> E2&gt;</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; <span class=\"keyword\">operator</span>+(VecExpression&lt;E1&gt; <span class=\"keyword\">const</span> &amp;u, VecExpression&lt;E2&gt; <span class=\"keyword\">const</span> &amp;v) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> VecSum&lt;E1, E2&gt;(*<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> E1*&gt;(&amp;u), *<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> E2*&gt;(&amp;v));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Vec v0 = &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">  Vec v1 = &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  Vec v2 = &#123;<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">  Vec v3 = &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vec sum = v0 + v1 + v2 + v3;</span><br><span class=\"line\">  sum.dump();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; Vec; E2 &#x3D; Vec]</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;Vec, Vec&gt;; E2 &#x3D; Vec]</span><br><span class=\"line\">VecSum&lt;E1, E2&gt; operator+(const VecExpression&lt;E&gt;&amp;, const VecExpression&lt;E2&gt;&amp;) [with E1 &#x3D; VecSum&lt;VecSum&lt;Vec, Vec&gt;, Vec&gt;; E2 &#x3D; Vec]</span><br><span class=\"line\">10 11 12</span><br></pre></td></tr></table></figure>\n"},{"title":"cpp variadic template","date":"2020-06-30T08:49:10.000Z","_content":"\n# C++变长模板使用\n\nC++11开始支持支持变长模板（variadic template），模板参数可以为任意多个, 变长模板参数用省略号来标识(...)。\n\n变长模板参数通常以递归的形式打开（因此需要定义一个没有变长参数的base case模板），下面借用一个[例子](https://www.raymii.org/s/snippets/Cpp_variadic_template_recursive_example.html)来说明:\n\n```c++\n#include <iostream>\n\ntemplate <typename Arg>\nvoid Foo(Arg arg) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n}\n\ntemplate <typename First, typename... Args>\nvoid Foo(First first, Args... args) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  Foo(first);\n  Foo(args...);\n}\n\nint main() {\n  std::string one = \"one\";\n  const char* two = \"two\";\n  Foo(one);\n  std::cout << std::endl;\n  Foo(one, two);\n  return 0;\n}\n```\n\n上面代码的输出如下：\n\n```\nvoid Foo(Arg) [with Arg = std::__cxx11::basic_string<char>]\n\nvoid Foo(First, Args ...) [with First = std::__cxx11::basic_string<char>; Args = {const char*}]\nvoid Foo(Arg) [with Arg = std::__cxx11::basic_string<char>]\nvoid Foo(Arg) [with Arg = const char*]\n```\n\n## 求和\n\n下面尝试使用变长模板来实现一个求和的函数。\n\n```c++\n#include <iostream>\n\ntemplate <typename Arg>\nArg Sum(Arg arg) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  return arg;\n}\n\ntemplate <typename First, typename... Args>\nFirst Sum(First first, Args... args) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  return first + Sum(args...);\n}\n\nint main() {\n  std::cout << Sum(1, 2, 3, 4, 5) << std::endl;\n  return 0;\n}\n```\n\n得到的结果如下：\n\n```c++\nFirst Sum(First, Args ...) [with First = int; Args = {int, int, int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int, int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int}]\nArg Sum(Arg) [with Arg = int]\n15\n```\n\n","source":"_posts/cpp-variadic-template.md","raw":"---\ntitle: cpp variadic template\ndate: 2020-06-30 16:49:10\ncategories: 编程\ntags:\n- c++\n---\n\n# C++变长模板使用\n\nC++11开始支持支持变长模板（variadic template），模板参数可以为任意多个, 变长模板参数用省略号来标识(...)。\n\n变长模板参数通常以递归的形式打开（因此需要定义一个没有变长参数的base case模板），下面借用一个[例子](https://www.raymii.org/s/snippets/Cpp_variadic_template_recursive_example.html)来说明:\n\n```c++\n#include <iostream>\n\ntemplate <typename Arg>\nvoid Foo(Arg arg) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n}\n\ntemplate <typename First, typename... Args>\nvoid Foo(First first, Args... args) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  Foo(first);\n  Foo(args...);\n}\n\nint main() {\n  std::string one = \"one\";\n  const char* two = \"two\";\n  Foo(one);\n  std::cout << std::endl;\n  Foo(one, two);\n  return 0;\n}\n```\n\n上面代码的输出如下：\n\n```\nvoid Foo(Arg) [with Arg = std::__cxx11::basic_string<char>]\n\nvoid Foo(First, Args ...) [with First = std::__cxx11::basic_string<char>; Args = {const char*}]\nvoid Foo(Arg) [with Arg = std::__cxx11::basic_string<char>]\nvoid Foo(Arg) [with Arg = const char*]\n```\n\n## 求和\n\n下面尝试使用变长模板来实现一个求和的函数。\n\n```c++\n#include <iostream>\n\ntemplate <typename Arg>\nArg Sum(Arg arg) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  return arg;\n}\n\ntemplate <typename First, typename... Args>\nFirst Sum(First first, Args... args) {\n  std::cout << __PRETTY_FUNCTION__ << \"\\n\";\n  return first + Sum(args...);\n}\n\nint main() {\n  std::cout << Sum(1, 2, 3, 4, 5) << std::endl;\n  return 0;\n}\n```\n\n得到的结果如下：\n\n```c++\nFirst Sum(First, Args ...) [with First = int; Args = {int, int, int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int, int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int, int}]\nFirst Sum(First, Args ...) [with First = int; Args = {int}]\nArg Sum(Arg) [with Arg = int]\n15\n```\n\n","slug":"cpp-variadic-template","published":1,"updated":"2020-06-30T12:11:39.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9uct000hys1df0rjd77e","content":"<h1 id=\"C-变长模板使用\"><a href=\"#C-变长模板使用\" class=\"headerlink\" title=\"C++变长模板使用\"></a>C++变长模板使用</h1><p>C++11开始支持支持变长模板（variadic template），模板参数可以为任意多个, 变长模板参数用省略号来标识(…)。</p>\n<p>变长模板参数通常以递归的形式打开（因此需要定义一个没有变长参数的base case模板），下面借用一个<a href=\"https://www.raymii.org/s/snippets/Cpp_variadic_template_recursive_example.html\" target=\"_blank\" rel=\"noopener\">例子</a>来说明:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Arg&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(Arg arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> First, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(First first, Args... args)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  Foo(first);</span><br><span class=\"line\">  Foo(args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> one = <span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* two = <span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">  Foo(one);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  Foo(one, two);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Foo(Arg) [with Arg &#x3D; std::__cxx11::basic_string&lt;char&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">void Foo(First, Args ...) [with First &#x3D; std::__cxx11::basic_string&lt;char&gt;; Args &#x3D; &#123;const char*&#125;]</span><br><span class=\"line\">void Foo(Arg) [with Arg &#x3D; std::__cxx11::basic_string&lt;char&gt;]</span><br><span class=\"line\">void Foo(Arg) [with Arg &#x3D; const char*]</span><br></pre></td></tr></table></figure>\n<h2 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h2><p>下面尝试使用变长模板来实现一个求和的函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Arg&gt;</span><br><span class=\"line\"><span class=\"function\">Arg <span class=\"title\">Sum</span><span class=\"params\">(Arg arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> First, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">First <span class=\"title\">Sum</span><span class=\"params\">(First first, Args... args)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> first + Sum(args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; Sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到的结果如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int, int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int&#125;]</span><br><span class=\"line\">Arg Sum(Arg) [with Arg = int]</span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-变长模板使用\"><a href=\"#C-变长模板使用\" class=\"headerlink\" title=\"C++变长模板使用\"></a>C++变长模板使用</h1><p>C++11开始支持支持变长模板（variadic template），模板参数可以为任意多个, 变长模板参数用省略号来标识(…)。</p>\n<p>变长模板参数通常以递归的形式打开（因此需要定义一个没有变长参数的base case模板），下面借用一个<a href=\"https://www.raymii.org/s/snippets/Cpp_variadic_template_recursive_example.html\" target=\"_blank\" rel=\"noopener\">例子</a>来说明:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Arg&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(Arg arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> First, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(First first, Args... args)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  Foo(first);</span><br><span class=\"line\">  Foo(args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> one = <span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* two = <span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">  Foo(one);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  Foo(one, two);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Foo(Arg) [with Arg &#x3D; std::__cxx11::basic_string&lt;char&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">void Foo(First, Args ...) [with First &#x3D; std::__cxx11::basic_string&lt;char&gt;; Args &#x3D; &#123;const char*&#125;]</span><br><span class=\"line\">void Foo(Arg) [with Arg &#x3D; std::__cxx11::basic_string&lt;char&gt;]</span><br><span class=\"line\">void Foo(Arg) [with Arg &#x3D; const char*]</span><br></pre></td></tr></table></figure>\n<h2 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h2><p>下面尝试使用变长模板来实现一个求和的函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Arg&gt;</span><br><span class=\"line\"><span class=\"function\">Arg <span class=\"title\">Sum</span><span class=\"params\">(Arg arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> First, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">First <span class=\"title\">Sum</span><span class=\"params\">(First first, Args... args)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> first + Sum(args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; Sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到的结果如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int, int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int, int&#125;]</span><br><span class=\"line\">First Sum(First, Args ...) [with First = int; Args = &#123;int&#125;]</span><br><span class=\"line\">Arg Sum(Arg) [with Arg = int]</span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n"},{"title":"rvalue reference and emplace","date":"2020-07-03T03:37:11.000Z","_content":"\n# 右值引用和emplace\n\n这篇文章初衷是好奇`push_back`和`emplace_back`的区别，了解之后发现绕不开右值引用，在此一并记录一下。\n\n## 右值引用\n\n右值引用（`rvalue reference`）是C++11中引入的新特性，显然是与C++11之前普通左值引用相对的一个概念。下面的右值引用的介绍很多参考自[这篇文章](http://thbecker.net/articles/rvalue_references/section_02.html)。\n\n### 左值与右值\n\n一个粗略的定义如下：\n\n左值是一个可以出现在赋值符号（`=`）左边或者右边的表达式, 可以理解为对一块内存的引用；\n\n右值是一个只能出现在赋值符号右边的表达式， 注意右值不是对内存的引用，因此不能进行取地址操作。\n\n如：\n\n```c++\nint a = 42;\nint b = 43;\n// a, b 均为左值\na = b;\nb = a;\n// a + b 为右值\nint c = a  + b;\na + b = 42; // error!\n// 不能对右值取地址\na  = foo(); // ok, foo() is a rvalue\nint* p = &foo(); // invalid, 不能对右值取地址\n```\n\n### 为什么要右值引用？\n\n#### move语义\n\n假设类X中包括一个指向资源的指针`m_pResource`，我们想实现一个接收**临时对象**作为参数的拷贝赋值操作符，其实现可能如下：\n\n```c++\nX& X::operator=(const X &rhs) {\n  //1. 拷贝rhs.m_pResource\n  //2. 析构rhs.m_pResource指向的资源\n  //3. 将拷贝的资源赋给self.m_pResource\n}\n```\n\n不难看出，上面对资源`m_pResource`的拷贝和析构十分低效，我们可以直接和临时实例交换指针（此所谓move语义）。另外，对于非临时对象的拷贝，我们可能不想析构其资源。因此我们需要一个类型来标识这样的临时对象，对它进行单独的处理，例如：\n\n```\nX& X::operator=( <Desired type>rhs) {\n  //1. swap this->m_pResource and rhs.m_pResource\n}\n```\n\n其实右值引用就是我们想要的类型，上面代码中的`<Desired type>`我们可以用`X&&`替代，表示是X的右值引用。\n\n## emplace_back or push_back?\n\n### 一个小实验\n\n猜猜看下面的代码会进行几次复制操作？\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.push_back(Point(1, 2));\n  points.push_back(Point(3, 4));\n  points.push_back(Point(5, 6));\n  return 0;\n}\n```\n\n答案是六次，其中三次是将临时`Point`对象拷贝至容器，有一次是容器容量从1到2的拷贝，有两次是容器容量从2到4的拷贝。\n\n#### 消除扩容拷贝\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  // 预分配内存 NOTE: 和std::vector<Point> points(3)的区别，reserve只分配内存不调用构造函数\n  points.reserve(3);\n  points.push_back(Point(1, 2));\n  points.push_back(Point(3, 4));\n  points.push_back(Point(5, 6));\n  return 0;\n}\n```\n\n现在只用进行三次插入容器时的拷贝\n\n#### move语义消除插入容器时的拷贝\n\n直接将参数forward给容器，直接在容器中构造。\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.emplace_back(1, 2);\n  points.emplace_back(3, 4);\n  points.emplace_back(5, 6);\n  return 0;\n}\n```\n\n现在拷贝的次数为0次！\n\n### 接口\n\n首先看看C++11中两者的接口：\n\n```c++\ntemplate< class... Args >\nvoid emplace_back( Args&&... args );\n\nvoid std::vector<T, Allocator>::push_back( const T& value );\nvoid std::vector<T, Allocator>::push_back( T&& value );\n```\n\n注意到接收右值的接口的差别，push_back只能接收Vector中存储类型的右值作为参数，而emplace可以接收变长模板作为参数，尝试为变长模板找到最合适的构造函数直接在容器中构建。\n\nNOTE：实验中的例子，emplace_back的变长参数也可以接收`Point`对象，此时会先调用Point的默认构造函数然后调用复制构造函数。对应代码如下：\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.reserve(3);\n  points.emplace_back(Point(1, 2));\n  points.emplace_back(Point(3, 4));\n  points.emplace_back(Point(5, 6));\n  return 0;\n}\n\n```\n\n\n\n","source":"_posts/rvalue-reference-and-emplace.md","raw":"---\ntitle: rvalue reference and emplace\ndate: 2020-07-03 11:37:11\ncategories: 编程\ntags: c++\n---\n\n# 右值引用和emplace\n\n这篇文章初衷是好奇`push_back`和`emplace_back`的区别，了解之后发现绕不开右值引用，在此一并记录一下。\n\n## 右值引用\n\n右值引用（`rvalue reference`）是C++11中引入的新特性，显然是与C++11之前普通左值引用相对的一个概念。下面的右值引用的介绍很多参考自[这篇文章](http://thbecker.net/articles/rvalue_references/section_02.html)。\n\n### 左值与右值\n\n一个粗略的定义如下：\n\n左值是一个可以出现在赋值符号（`=`）左边或者右边的表达式, 可以理解为对一块内存的引用；\n\n右值是一个只能出现在赋值符号右边的表达式， 注意右值不是对内存的引用，因此不能进行取地址操作。\n\n如：\n\n```c++\nint a = 42;\nint b = 43;\n// a, b 均为左值\na = b;\nb = a;\n// a + b 为右值\nint c = a  + b;\na + b = 42; // error!\n// 不能对右值取地址\na  = foo(); // ok, foo() is a rvalue\nint* p = &foo(); // invalid, 不能对右值取地址\n```\n\n### 为什么要右值引用？\n\n#### move语义\n\n假设类X中包括一个指向资源的指针`m_pResource`，我们想实现一个接收**临时对象**作为参数的拷贝赋值操作符，其实现可能如下：\n\n```c++\nX& X::operator=(const X &rhs) {\n  //1. 拷贝rhs.m_pResource\n  //2. 析构rhs.m_pResource指向的资源\n  //3. 将拷贝的资源赋给self.m_pResource\n}\n```\n\n不难看出，上面对资源`m_pResource`的拷贝和析构十分低效，我们可以直接和临时实例交换指针（此所谓move语义）。另外，对于非临时对象的拷贝，我们可能不想析构其资源。因此我们需要一个类型来标识这样的临时对象，对它进行单独的处理，例如：\n\n```\nX& X::operator=( <Desired type>rhs) {\n  //1. swap this->m_pResource and rhs.m_pResource\n}\n```\n\n其实右值引用就是我们想要的类型，上面代码中的`<Desired type>`我们可以用`X&&`替代，表示是X的右值引用。\n\n## emplace_back or push_back?\n\n### 一个小实验\n\n猜猜看下面的代码会进行几次复制操作？\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.push_back(Point(1, 2));\n  points.push_back(Point(3, 4));\n  points.push_back(Point(5, 6));\n  return 0;\n}\n```\n\n答案是六次，其中三次是将临时`Point`对象拷贝至容器，有一次是容器容量从1到2的拷贝，有两次是容器容量从2到4的拷贝。\n\n#### 消除扩容拷贝\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  // 预分配内存 NOTE: 和std::vector<Point> points(3)的区别，reserve只分配内存不调用构造函数\n  points.reserve(3);\n  points.push_back(Point(1, 2));\n  points.push_back(Point(3, 4));\n  points.push_back(Point(5, 6));\n  return 0;\n}\n```\n\n现在只用进行三次插入容器时的拷贝\n\n#### move语义消除插入容器时的拷贝\n\n直接将参数forward给容器，直接在容器中构造。\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.emplace_back(1, 2);\n  points.emplace_back(3, 4);\n  points.emplace_back(5, 6);\n  return 0;\n}\n```\n\n现在拷贝的次数为0次！\n\n### 接口\n\n首先看看C++11中两者的接口：\n\n```c++\ntemplate< class... Args >\nvoid emplace_back( Args&&... args );\n\nvoid std::vector<T, Allocator>::push_back( const T& value );\nvoid std::vector<T, Allocator>::push_back( T&& value );\n```\n\n注意到接收右值的接口的差别，push_back只能接收Vector中存储类型的右值作为参数，而emplace可以接收变长模板作为参数，尝试为变长模板找到最合适的构造函数直接在容器中构建。\n\nNOTE：实验中的例子，emplace_back的变长参数也可以接收`Point`对象，此时会先调用Point的默认构造函数然后调用复制构造函数。对应代码如下：\n\n```c++\n#include <iostream>\n#include <vector>\n\nstruct Point {\n  float x, y;\n  Point(float x, float y):x(x), y(y){}\n\n  Point(const Point& point):x(point.x), y(point.y) {\n    std::cout << \"copying!\" << std::endl;\n  }\n};\n\nint main() {\n  std::vector<Point> points;\n  points.reserve(3);\n  points.emplace_back(Point(1, 2));\n  points.emplace_back(Point(3, 4));\n  points.emplace_back(Point(5, 6));\n  return 0;\n}\n\n```\n\n\n\n","slug":"rvalue-reference-and-emplace","published":1,"updated":"2020-07-03T08:40:48.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbb9ud4000yys1d2plc2s6p","content":"<h1 id=\"右值引用和emplace\"><a href=\"#右值引用和emplace\" class=\"headerlink\" title=\"右值引用和emplace\"></a>右值引用和emplace</h1><p>这篇文章初衷是好奇<code>push_back</code>和<code>emplace_back</code>的区别，了解之后发现绕不开右值引用，在此一并记录一下。</p>\n<h2 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h2><p>右值引用（<code>rvalue reference</code>）是C++11中引入的新特性，显然是与C++11之前普通左值引用相对的一个概念。下面的右值引用的介绍很多参考自<a href=\"http://thbecker.net/articles/rvalue_references/section_02.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h3><p>一个粗略的定义如下：</p>\n<p>左值是一个可以出现在赋值符号（<code>=</code>）左边或者右边的表达式, 可以理解为对一块内存的引用；</p>\n<p>右值是一个只能出现在赋值符号右边的表达式， 注意右值不是对内存的引用，因此不能进行取地址操作。</p>\n<p>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">43</span>;</span><br><span class=\"line\"><span class=\"comment\">// a, b 均为左值</span></span><br><span class=\"line\">a = b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\"><span class=\"comment\">// a + b 为右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a  + b;</span><br><span class=\"line\">a + b = <span class=\"number\">42</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\"><span class=\"comment\">// 不能对右值取地址</span></span><br><span class=\"line\">a  = foo(); <span class=\"comment\">// ok, foo() is a rvalue</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;foo(); <span class=\"comment\">// invalid, 不能对右值取地址</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要右值引用？\"><a href=\"#为什么要右值引用？\" class=\"headerlink\" title=\"为什么要右值引用？\"></a>为什么要右值引用？</h3><h4 id=\"move语义\"><a href=\"#move语义\" class=\"headerlink\" title=\"move语义\"></a>move语义</h4><p>假设类X中包括一个指向资源的指针<code>m_pResource</code>，我们想实现一个接收<strong>临时对象</strong>作为参数的拷贝赋值操作符，其实现可能如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X&amp; X::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> X &amp;rhs) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//1. 拷贝rhs.m_pResource</span></span><br><span class=\"line\">  <span class=\"comment\">//2. 析构rhs.m_pResource指向的资源</span></span><br><span class=\"line\">  <span class=\"comment\">//3. 将拷贝的资源赋给self.m_pResource</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不难看出，上面对资源<code>m_pResource</code>的拷贝和析构十分低效，我们可以直接和临时实例交换指针（此所谓move语义）。另外，对于非临时对象的拷贝，我们可能不想析构其资源。因此我们需要一个类型来标识这样的临时对象，对它进行单独的处理，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X&amp; X::operator&#x3D;( &lt;Desired type&gt;rhs) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;1. swap this-&gt;m_pResource and rhs.m_pResource</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实右值引用就是我们想要的类型，上面代码中的<code>&lt;Desired type&gt;</code>我们可以用<code>X&amp;&amp;</code>替代，表示是X的右值引用。</p>\n<h2 id=\"emplace-back-or-push-back\"><a href=\"#emplace-back-or-push-back\" class=\"headerlink\" title=\"emplace_back or push_back?\"></a>emplace_back or push_back?</h2><h3 id=\"一个小实验\"><a href=\"#一个小实验\" class=\"headerlink\" title=\"一个小实验\"></a>一个小实验</h3><p>猜猜看下面的代码会进行几次复制操作？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是六次，其中三次是将临时<code>Point</code>对象拷贝至容器，有一次是容器容量从1到2的拷贝，有两次是容器容量从2到4的拷贝。</p>\n<h4 id=\"消除扩容拷贝\"><a href=\"#消除扩容拷贝\" class=\"headerlink\" title=\"消除扩容拷贝\"></a>消除扩容拷贝</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  <span class=\"comment\">// 预分配内存 <span class=\"doctag\">NOTE:</span> 和std::vector&lt;Point&gt; points(3)的区别，reserve只分配内存不调用构造函数</span></span><br><span class=\"line\">  points.reserve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在只用进行三次插入容器时的拷贝</p>\n<h4 id=\"move语义消除插入容器时的拷贝\"><a href=\"#move语义消除插入容器时的拷贝\" class=\"headerlink\" title=\"move语义消除插入容器时的拷贝\"></a>move语义消除插入容器时的拷贝</h4><p>直接将参数forward给容器，直接在容器中构造。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在拷贝的次数为0次！</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>首先看看C++11中两者的接口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">Args</span> &gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">emplace_back</span>( <span class=\"title\">Args</span>&amp;&amp;... <span class=\"title\">args</span> );</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, Allocator&gt;::push_back( <span class=\"keyword\">const</span> T&amp; value );</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, Allocator&gt;::push_back( T&amp;&amp; value );</span><br></pre></td></tr></table></figure>\n<p>注意到接收右值的接口的差别，push_back只能接收Vector中存储类型的右值作为参数，而emplace可以接收变长模板作为参数，尝试为变长模板找到最合适的构造函数直接在容器中构建。</p>\n<p>NOTE：实验中的例子，emplace_back的变长参数也可以接收<code>Point</code>对象，此时会先调用Point的默认构造函数然后调用复制构造函数。对应代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.reserve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"右值引用和emplace\"><a href=\"#右值引用和emplace\" class=\"headerlink\" title=\"右值引用和emplace\"></a>右值引用和emplace</h1><p>这篇文章初衷是好奇<code>push_back</code>和<code>emplace_back</code>的区别，了解之后发现绕不开右值引用，在此一并记录一下。</p>\n<h2 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h2><p>右值引用（<code>rvalue reference</code>）是C++11中引入的新特性，显然是与C++11之前普通左值引用相对的一个概念。下面的右值引用的介绍很多参考自<a href=\"http://thbecker.net/articles/rvalue_references/section_02.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h3><p>一个粗略的定义如下：</p>\n<p>左值是一个可以出现在赋值符号（<code>=</code>）左边或者右边的表达式, 可以理解为对一块内存的引用；</p>\n<p>右值是一个只能出现在赋值符号右边的表达式， 注意右值不是对内存的引用，因此不能进行取地址操作。</p>\n<p>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">43</span>;</span><br><span class=\"line\"><span class=\"comment\">// a, b 均为左值</span></span><br><span class=\"line\">a = b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\"><span class=\"comment\">// a + b 为右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a  + b;</span><br><span class=\"line\">a + b = <span class=\"number\">42</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\"><span class=\"comment\">// 不能对右值取地址</span></span><br><span class=\"line\">a  = foo(); <span class=\"comment\">// ok, foo() is a rvalue</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;foo(); <span class=\"comment\">// invalid, 不能对右值取地址</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要右值引用？\"><a href=\"#为什么要右值引用？\" class=\"headerlink\" title=\"为什么要右值引用？\"></a>为什么要右值引用？</h3><h4 id=\"move语义\"><a href=\"#move语义\" class=\"headerlink\" title=\"move语义\"></a>move语义</h4><p>假设类X中包括一个指向资源的指针<code>m_pResource</code>，我们想实现一个接收<strong>临时对象</strong>作为参数的拷贝赋值操作符，其实现可能如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X&amp; X::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> X &amp;rhs) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//1. 拷贝rhs.m_pResource</span></span><br><span class=\"line\">  <span class=\"comment\">//2. 析构rhs.m_pResource指向的资源</span></span><br><span class=\"line\">  <span class=\"comment\">//3. 将拷贝的资源赋给self.m_pResource</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不难看出，上面对资源<code>m_pResource</code>的拷贝和析构十分低效，我们可以直接和临时实例交换指针（此所谓move语义）。另外，对于非临时对象的拷贝，我们可能不想析构其资源。因此我们需要一个类型来标识这样的临时对象，对它进行单独的处理，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X&amp; X::operator&#x3D;( &lt;Desired type&gt;rhs) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F;1. swap this-&gt;m_pResource and rhs.m_pResource</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实右值引用就是我们想要的类型，上面代码中的<code>&lt;Desired type&gt;</code>我们可以用<code>X&amp;&amp;</code>替代，表示是X的右值引用。</p>\n<h2 id=\"emplace-back-or-push-back\"><a href=\"#emplace-back-or-push-back\" class=\"headerlink\" title=\"emplace_back or push_back?\"></a>emplace_back or push_back?</h2><h3 id=\"一个小实验\"><a href=\"#一个小实验\" class=\"headerlink\" title=\"一个小实验\"></a>一个小实验</h3><p>猜猜看下面的代码会进行几次复制操作？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是六次，其中三次是将临时<code>Point</code>对象拷贝至容器，有一次是容器容量从1到2的拷贝，有两次是容器容量从2到4的拷贝。</p>\n<h4 id=\"消除扩容拷贝\"><a href=\"#消除扩容拷贝\" class=\"headerlink\" title=\"消除扩容拷贝\"></a>消除扩容拷贝</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  <span class=\"comment\">// 预分配内存 <span class=\"doctag\">NOTE:</span> 和std::vector&lt;Point&gt; points(3)的区别，reserve只分配内存不调用构造函数</span></span><br><span class=\"line\">  points.reserve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.push_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在只用进行三次插入容器时的拷贝</p>\n<h4 id=\"move语义消除插入容器时的拷贝\"><a href=\"#move语义消除插入容器时的拷贝\" class=\"headerlink\" title=\"move语义消除插入容器时的拷贝\"></a>move语义消除插入容器时的拷贝</h4><p>直接将参数forward给容器，直接在容器中构造。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  points.emplace_back(<span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在拷贝的次数为0次！</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>首先看看C++11中两者的接口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">Args</span> &gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">emplace_back</span>( <span class=\"title\">Args</span>&amp;&amp;... <span class=\"title\">args</span> );</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, Allocator&gt;::push_back( <span class=\"keyword\">const</span> T&amp; value );</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, Allocator&gt;::push_back( T&amp;&amp; value );</span><br></pre></td></tr></table></figure>\n<p>注意到接收右值的接口的差别，push_back只能接收Vector中存储类型的右值作为参数，而emplace可以接收变长模板作为参数，尝试为变长模板找到最合适的构造函数直接在容器中构建。</p>\n<p>NOTE：实验中的例子，emplace_back的变长参数也可以接收<code>Point</code>对象，此时会先调用Point的默认构造函数然后调用复制构造函数。对应代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y):x(x), y(y)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">const</span> Point&amp; <span class=\"built_in\">point</span>):x(<span class=\"built_in\">point</span>.x), y(<span class=\"built_in\">point</span>.y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copying!\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Point&gt; points;</span><br><span class=\"line\">  points.reserve(<span class=\"number\">3</span>);</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">  points.emplace_back(Point(<span class=\"number\">5</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"SNN[5]: LCA","date":"2020-07-07T02:25:56.000Z","mathjax":true,"_content":"\n# SNN学习笔记5：LCA\n\n## 稀疏编码\n\n实验表明人脑对于外界刺激采取一种稀疏的内在表示，例如自然图像只需要用[稀疏词典](https://en.wikipedia.org/wiki/Sparse_dictionary_learning)中一个很小的子集及合适的对应系数来进行稀疏近似（sparse approximation）。\n\n### 稀疏近似\n\n稀疏近似的数学表述如下：\n\n​\t给定一个N维刺激$s \\in \\mathbb{R}^N$, 找到一个基于由M个向量$\\{\\phi_m\\}$组成的词典$D$的表示。当词典$D$是overcomplete时（i.e M > N），我们可以有无穷多种方式来选取词典中向量对应的稀疏$\\{a_m\\}$ 来表示$s$: $s = \\sum_{m = 1}^Ma_m\\phi_m$。\n\n在最优稀疏近似中，我们希望尽可能少的使用D中的向量，也就是**系数不为0的向量尽可能的少**：\n$$\n\\mathop{min}_a ||a||_0    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m\n$$\n上式中$||a||_0$表示$\\ell^0$ norm, 也就是 $a = [a_1, a_2, ..., a_M]$中非零元素的个数。需要注意的是，这个组合优化问题是NP-hard的。\n\n### Basis Pursuit目标\n\n对$\\ell_0$的优化是NP-hard的，BP目标函数尝试将优化目标改为最小化系数向量的$\\ell_1$ norm：\n$$\n\\mathop{min}_a ||a||_1    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m\n$$\nBP目标函数在信号$s$相对稀疏时也可以得到最优稀疏近似。\n\n### BPDN：重建误差\n\n实际操作中，由于$s$中存在噪音，我们不应该要求完美重建。BPDN（Basis Pursuit De-Noising）目标函数在BP的基础上引入了MSE重建误差来平衡正则项与重建精度：\n$$\n\\mathop{min}_a (||s - \\sum_{m = 1}^Ma_m\\phi_m||_2^2 + \\lambda||a||_1)\n$$\n公式中的$\\lambda$正是用来权衡重建误差与正则项的。\n\n#### MP算法\n\n在信号处理社区，常用MP(Matching Pursuit)算法来求解BPDN。MPs算法本质上是一种贪心算法，流程如下：\n\n1. 将残差初始化为$s$: $r_0 = s$\n2. 在第k次迭代，通过$\\theta_k = argmax_m|\\langle r_{k-1}, \\phi_m\\rangle|$找到词典M中的索引$\\theta_k$\n3. 更新残差：$r_k = r_{k - 1} - \\phi_{\\theta_k}d_k$\n\nK次迭代后得到一个$s$的稀疏近似：$\\hat{s} = \\sum_{k = 1}^K \\phi_{\\theta_k}d_k$。\n\n## LCA\n\n[LCA](https://ece.rice.edu/~eld1/papers/Rozell08.pdf)(Locally Competitive Algorithm)是一种稀疏编码算法，相比MP算法，不仅考虑到了选取最稀疏表示的目标，也考虑了选取最能表征信号特性的向量的目标。同时，LCA对随时间变化的信号的处理进行了优化，LCA不用每一步都从头进行稀疏近似，而是基于上一步的表征向量进行更新。\n\n### 框架\n\nLCA中，词典中的每个向量$\\phi_m \\in D$都被关联到一个神经元。神经元中维护自己的膜电位$u_m(t)$，神经元的输入电流为输入与神经元的感受野的匹配度：$b_m(t) = \\langle\\phi_m, s(t)\\rangle$。当神经元m的膜电位超过阈值$\\lambda $时，输出一个激活信号$a_m = T_\\lambda(u_m)$并向周边神经元n发射抑制信号$a_mG_{m, n}$其中$ G_{m, n} = \\langle \\phi_m, \\phi_n \\rangle$。\n\nNOTE: 从抑制信号的公式中可以看出，一个神经元的激活越强，对周边神经元的抑制越强；一个神经元与周围的神经元越相似，对周围神经元的抑制越强。这种机制会导致匹配度最高的神经元得到最大的电流输入，然后抑制周边神经元得到输入及进行反向抑制，以此达到获取**稀疏表示**的效果（WTA：winner takes all）。\n\n上面的膜电位变化机制可以用下面的常微分方程来描述：\n$$\n\\dot{u}_m(t) = \\frac{1}{\\tau}[b_m(t) - u_m(t) - \\sum_\\limits{\\substack{n \\neq m} }G_{m, n}a_n(t)\n$$\n\n### Demo实现\n\ngithub上的一个[参考实现](https://github.com/ctn-waterloo/cogsci17-decide/blob/5e82b8cf466db5ce84270c866e9dc0c36daa52b6/cogsci17_decide/networks.py)：\n\n```python\nimport nengo\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef LCA(d, n_neurons, dt):\n    k = 1.\n    beta = 1.\n    tau_model = 0.1\n    tau_actual = 0.1\n\n    I = np.eye(d)\n    inhibit = 1 - I\n    B = 1. / tau_model\n    A = (-k * I - beta * inhibit) / tau_model\n\n    with nengo.Network(label=\"LCA\") as net:\n        net.input = nengo.Node(size_in=d)\n        # array of ensembles: d ensembles, each with n_neurons neurons\n        x = nengo.networks.EnsembleArray(\n            n_neurons, d,\n            eval_points=nengo.dists.Uniform(0., 1.),\n            intercepts=nengo.dists.Uniform(0., 1.),\n            encoders=nengo.dists.Choice([[1.]]),\n            label=\"state\")\n        # transform: linear transformation mapping the pre output to the post input\n        # synapse: synapse model for filtering\n        nengo.Connection(x.output, x.input, transform=tau_actual * A + I, synapse=tau_actual)\n        nengo.Connection(net.input, x.input, transform=tau_actual*B, synapse=tau_actual)\n        net.output = x.output\n    return net\n\ndef main():\n    dt = 0.001\n    with nengo.Network(seed=42) as model:\n        # winner takes all\n        wta = LCA(3, 200, dt)\n        stimulus = nengo.Node([0.8, 0.7, 0.6])\n        nengo.Connection(stimulus, wta.input, synapse=True)\n\n        p_stimulus = nengo.Probe(stimulus, synapse=None)\n        p_output = nengo.Probe(wta.output, synapse=0.01)\n    with nengo.Simulator(model, dt=dt) as sim:\n        sim.run(1.)\n\n    fig = plt.figure()\n    plt.plot(sim.trange(), sim.data[p_output])\n    plt.title(\"(a)LCA\")\n    plt.xlabel(\"Time [s]\")\n    plt.ylabel(\"Decoded output\")\n    plt.locator_params(axis='y', nbins=5)\n    plt.tight_layout()\n    plt.show()\n        \n\nif __name__ == \"__main__\":\n    main()\n```\n\n效果如下：\n\n![LCA](../images/lca.png)\n\n可以看到3个ensemble中只有得到最强输入的一个保留了下来。","source":"_posts/SNN-5-LCA.md","raw":"---\ntitle: 'SNN[5]: LCA'\ndate: 2020-07-07 10:25:56\ncategories: AI\ntags: SNN, Deep Learning\nmathjax: true\n---\n\n# SNN学习笔记5：LCA\n\n## 稀疏编码\n\n实验表明人脑对于外界刺激采取一种稀疏的内在表示，例如自然图像只需要用[稀疏词典](https://en.wikipedia.org/wiki/Sparse_dictionary_learning)中一个很小的子集及合适的对应系数来进行稀疏近似（sparse approximation）。\n\n### 稀疏近似\n\n稀疏近似的数学表述如下：\n\n​\t给定一个N维刺激$s \\in \\mathbb{R}^N$, 找到一个基于由M个向量$\\{\\phi_m\\}$组成的词典$D$的表示。当词典$D$是overcomplete时（i.e M > N），我们可以有无穷多种方式来选取词典中向量对应的稀疏$\\{a_m\\}$ 来表示$s$: $s = \\sum_{m = 1}^Ma_m\\phi_m$。\n\n在最优稀疏近似中，我们希望尽可能少的使用D中的向量，也就是**系数不为0的向量尽可能的少**：\n$$\n\\mathop{min}_a ||a||_0    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m\n$$\n上式中$||a||_0$表示$\\ell^0$ norm, 也就是 $a = [a_1, a_2, ..., a_M]$中非零元素的个数。需要注意的是，这个组合优化问题是NP-hard的。\n\n### Basis Pursuit目标\n\n对$\\ell_0$的优化是NP-hard的，BP目标函数尝试将优化目标改为最小化系数向量的$\\ell_1$ norm：\n$$\n\\mathop{min}_a ||a||_1    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m\n$$\nBP目标函数在信号$s$相对稀疏时也可以得到最优稀疏近似。\n\n### BPDN：重建误差\n\n实际操作中，由于$s$中存在噪音，我们不应该要求完美重建。BPDN（Basis Pursuit De-Noising）目标函数在BP的基础上引入了MSE重建误差来平衡正则项与重建精度：\n$$\n\\mathop{min}_a (||s - \\sum_{m = 1}^Ma_m\\phi_m||_2^2 + \\lambda||a||_1)\n$$\n公式中的$\\lambda$正是用来权衡重建误差与正则项的。\n\n#### MP算法\n\n在信号处理社区，常用MP(Matching Pursuit)算法来求解BPDN。MPs算法本质上是一种贪心算法，流程如下：\n\n1. 将残差初始化为$s$: $r_0 = s$\n2. 在第k次迭代，通过$\\theta_k = argmax_m|\\langle r_{k-1}, \\phi_m\\rangle|$找到词典M中的索引$\\theta_k$\n3. 更新残差：$r_k = r_{k - 1} - \\phi_{\\theta_k}d_k$\n\nK次迭代后得到一个$s$的稀疏近似：$\\hat{s} = \\sum_{k = 1}^K \\phi_{\\theta_k}d_k$。\n\n## LCA\n\n[LCA](https://ece.rice.edu/~eld1/papers/Rozell08.pdf)(Locally Competitive Algorithm)是一种稀疏编码算法，相比MP算法，不仅考虑到了选取最稀疏表示的目标，也考虑了选取最能表征信号特性的向量的目标。同时，LCA对随时间变化的信号的处理进行了优化，LCA不用每一步都从头进行稀疏近似，而是基于上一步的表征向量进行更新。\n\n### 框架\n\nLCA中，词典中的每个向量$\\phi_m \\in D$都被关联到一个神经元。神经元中维护自己的膜电位$u_m(t)$，神经元的输入电流为输入与神经元的感受野的匹配度：$b_m(t) = \\langle\\phi_m, s(t)\\rangle$。当神经元m的膜电位超过阈值$\\lambda $时，输出一个激活信号$a_m = T_\\lambda(u_m)$并向周边神经元n发射抑制信号$a_mG_{m, n}$其中$ G_{m, n} = \\langle \\phi_m, \\phi_n \\rangle$。\n\nNOTE: 从抑制信号的公式中可以看出，一个神经元的激活越强，对周边神经元的抑制越强；一个神经元与周围的神经元越相似，对周围神经元的抑制越强。这种机制会导致匹配度最高的神经元得到最大的电流输入，然后抑制周边神经元得到输入及进行反向抑制，以此达到获取**稀疏表示**的效果（WTA：winner takes all）。\n\n上面的膜电位变化机制可以用下面的常微分方程来描述：\n$$\n\\dot{u}_m(t) = \\frac{1}{\\tau}[b_m(t) - u_m(t) - \\sum_\\limits{\\substack{n \\neq m} }G_{m, n}a_n(t)\n$$\n\n### Demo实现\n\ngithub上的一个[参考实现](https://github.com/ctn-waterloo/cogsci17-decide/blob/5e82b8cf466db5ce84270c866e9dc0c36daa52b6/cogsci17_decide/networks.py)：\n\n```python\nimport nengo\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef LCA(d, n_neurons, dt):\n    k = 1.\n    beta = 1.\n    tau_model = 0.1\n    tau_actual = 0.1\n\n    I = np.eye(d)\n    inhibit = 1 - I\n    B = 1. / tau_model\n    A = (-k * I - beta * inhibit) / tau_model\n\n    with nengo.Network(label=\"LCA\") as net:\n        net.input = nengo.Node(size_in=d)\n        # array of ensembles: d ensembles, each with n_neurons neurons\n        x = nengo.networks.EnsembleArray(\n            n_neurons, d,\n            eval_points=nengo.dists.Uniform(0., 1.),\n            intercepts=nengo.dists.Uniform(0., 1.),\n            encoders=nengo.dists.Choice([[1.]]),\n            label=\"state\")\n        # transform: linear transformation mapping the pre output to the post input\n        # synapse: synapse model for filtering\n        nengo.Connection(x.output, x.input, transform=tau_actual * A + I, synapse=tau_actual)\n        nengo.Connection(net.input, x.input, transform=tau_actual*B, synapse=tau_actual)\n        net.output = x.output\n    return net\n\ndef main():\n    dt = 0.001\n    with nengo.Network(seed=42) as model:\n        # winner takes all\n        wta = LCA(3, 200, dt)\n        stimulus = nengo.Node([0.8, 0.7, 0.6])\n        nengo.Connection(stimulus, wta.input, synapse=True)\n\n        p_stimulus = nengo.Probe(stimulus, synapse=None)\n        p_output = nengo.Probe(wta.output, synapse=0.01)\n    with nengo.Simulator(model, dt=dt) as sim:\n        sim.run(1.)\n\n    fig = plt.figure()\n    plt.plot(sim.trange(), sim.data[p_output])\n    plt.title(\"(a)LCA\")\n    plt.xlabel(\"Time [s]\")\n    plt.ylabel(\"Decoded output\")\n    plt.locator_params(axis='y', nbins=5)\n    plt.tight_layout()\n    plt.show()\n        \n\nif __name__ == \"__main__\":\n    main()\n```\n\n效果如下：\n\n![LCA](../images/lca.png)\n\n可以看到3个ensemble中只有得到最强输入的一个保留了下来。","slug":"SNN-5-LCA","published":1,"updated":"2020-07-12T03:28:21.194Z","_id":"ckcd5lqko0000k41dbcun7nx5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"SNN学习笔记5：LCA\"><a href=\"#SNN学习笔记5：LCA\" class=\"headerlink\" title=\"SNN学习笔记5：LCA\"></a>SNN学习笔记5：LCA</h1><h2 id=\"稀疏编码\"><a href=\"#稀疏编码\" class=\"headerlink\" title=\"稀疏编码\"></a>稀疏编码</h2><p>实验表明人脑对于外界刺激采取一种稀疏的内在表示，例如自然图像只需要用<a href=\"https://en.wikipedia.org/wiki/Sparse_dictionary_learning\" target=\"_blank\" rel=\"noopener\">稀疏词典</a>中一个很小的子集及合适的对应系数来进行稀疏近似（sparse approximation）。</p>\n<h3 id=\"稀疏近似\"><a href=\"#稀疏近似\" class=\"headerlink\" title=\"稀疏近似\"></a>稀疏近似</h3><p>稀疏近似的数学表述如下：</p>\n<p>​    给定一个N维刺激$s \\in \\mathbb{R}^N$, 找到一个基于由M个向量$\\{\\phi_m\\}$组成的词典$D$的表示。当词典$D$是overcomplete时（i.e M &gt; N），我们可以有无穷多种方式来选取词典中向量对应的稀疏$\\{a_m\\}$ 来表示$s$: $s = \\sum_{m = 1}^Ma_m\\phi_m$。</p>\n<p>在最优稀疏近似中，我们希望尽可能少的使用D中的向量，也就是<strong>系数不为0的向量尽可能的少</strong>：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a ||a||_0    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m</script><p>上式中$||a||_0$表示$\\ell^0$ norm, 也就是 $a = [a_1, a_2, …, a_M]$中非零元素的个数。需要注意的是，这个组合优化问题是NP-hard的。</p>\n<h3 id=\"Basis-Pursuit目标\"><a href=\"#Basis-Pursuit目标\" class=\"headerlink\" title=\"Basis Pursuit目标\"></a>Basis Pursuit目标</h3><p>对$\\ell_0$的优化是NP-hard的，BP目标函数尝试将优化目标改为最小化系数向量的$\\ell_1$ norm：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a ||a||_1    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m</script><p>BP目标函数在信号$s$相对稀疏时也可以得到最优稀疏近似。</p>\n<h3 id=\"BPDN：重建误差\"><a href=\"#BPDN：重建误差\" class=\"headerlink\" title=\"BPDN：重建误差\"></a>BPDN：重建误差</h3><p>实际操作中，由于$s$中存在噪音，我们不应该要求完美重建。BPDN（Basis Pursuit De-Noising）目标函数在BP的基础上引入了MSE重建误差来平衡正则项与重建精度：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a (||s - \\sum_{m = 1}^Ma_m\\phi_m||_2^2 + \\lambda||a||_1)</script><p>公式中的$\\lambda$正是用来权衡重建误差与正则项的。</p>\n<h4 id=\"MP算法\"><a href=\"#MP算法\" class=\"headerlink\" title=\"MP算法\"></a>MP算法</h4><p>在信号处理社区，常用MP(Matching Pursuit)算法来求解BPDN。MPs算法本质上是一种贪心算法，流程如下：</p>\n<ol>\n<li>将残差初始化为$s$: $r_0 = s$</li>\n<li>在第k次迭代，通过$\\theta_k = argmax_m|\\langle r_{k-1}, \\phi_m\\rangle|$找到词典M中的索引$\\theta_k$</li>\n<li>更新残差：$r_k = r_{k - 1} - \\phi_{\\theta_k}d_k$</li>\n</ol>\n<p>K次迭代后得到一个$s$的稀疏近似：$\\hat{s} = \\sum_{k = 1}^K \\phi_{\\theta_k}d_k$。</p>\n<h2 id=\"LCA\"><a href=\"#LCA\" class=\"headerlink\" title=\"LCA\"></a>LCA</h2><p><a href=\"https://ece.rice.edu/~eld1/papers/Rozell08.pdf\" target=\"_blank\" rel=\"noopener\">LCA</a>(Locally Competitive Algorithm)是一种稀疏编码算法，相比MP算法，不仅考虑到了选取最稀疏表示的目标，也考虑了选取最能表征信号特性的向量的目标。同时，LCA对随时间变化的信号的处理进行了优化，LCA不用每一步都从头进行稀疏近似，而是基于上一步的表征向量进行更新。</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><p>LCA中，词典中的每个向量$\\phi_m \\in D$都被关联到一个神经元。神经元中维护自己的膜电位$u_m(t)$，神经元的输入电流为输入与神经元的感受野的匹配度：$b_m(t) = \\langle\\phi_m, s(t)\\rangle$。当神经元m的膜电位超过阈值$\\lambda $时，输出一个激活信号$a_m = T_\\lambda(u_m)$并向周边神经元n发射抑制信号$a_mG_{m, n}$其中$ G_{m, n} = \\langle \\phi_m, \\phi_n \\rangle$。</p>\n<p>NOTE: 从抑制信号的公式中可以看出，一个神经元的激活越强，对周边神经元的抑制越强；一个神经元与周围的神经元越相似，对周围神经元的抑制越强。这种机制会导致匹配度最高的神经元得到最大的电流输入，然后抑制周边神经元得到输入及进行反向抑制，以此达到获取<strong>稀疏表示</strong>的效果（WTA：winner takes all）。</p>\n<p>上面的膜电位变化机制可以用下面的常微分方程来描述：</p>\n<script type=\"math/tex; mode=display\">\n\\dot{u}_m(t) = \\frac{1}{\\tau}[b_m(t) - u_m(t) - \\sum_\\limits{\\substack{n \\neq m} }G_{m, n}a_n(t)</script><h3 id=\"Demo实现\"><a href=\"#Demo实现\" class=\"headerlink\" title=\"Demo实现\"></a>Demo实现</h3><p>github上的一个<a href=\"https://github.com/ctn-waterloo/cogsci17-decide/blob/5e82b8cf466db5ce84270c866e9dc0c36daa52b6/cogsci17_decide/networks.py\" target=\"_blank\" rel=\"noopener\">参考实现</a>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LCA</span><span class=\"params\">(d, n_neurons, dt)</span>:</span></span><br><span class=\"line\">    k = <span class=\"number\">1.</span></span><br><span class=\"line\">    beta = <span class=\"number\">1.</span></span><br><span class=\"line\">    tau_model = <span class=\"number\">0.1</span></span><br><span class=\"line\">    tau_actual = <span class=\"number\">0.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    I = np.eye(d)</span><br><span class=\"line\">    inhibit = <span class=\"number\">1</span> - I</span><br><span class=\"line\">    B = <span class=\"number\">1.</span> / tau_model</span><br><span class=\"line\">    A = (-k * I - beta * inhibit) / tau_model</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Network(label=<span class=\"string\">\"LCA\"</span>) <span class=\"keyword\">as</span> net:</span><br><span class=\"line\">        net.input = nengo.Node(size_in=d)</span><br><span class=\"line\">        <span class=\"comment\"># array of ensembles: d ensembles, each with n_neurons neurons</span></span><br><span class=\"line\">        x = nengo.networks.EnsembleArray(</span><br><span class=\"line\">            n_neurons, d,</span><br><span class=\"line\">            eval_points=nengo.dists.Uniform(<span class=\"number\">0.</span>, <span class=\"number\">1.</span>),</span><br><span class=\"line\">            intercepts=nengo.dists.Uniform(<span class=\"number\">0.</span>, <span class=\"number\">1.</span>),</span><br><span class=\"line\">            encoders=nengo.dists.Choice([[<span class=\"number\">1.</span>]]),</span><br><span class=\"line\">            label=<span class=\"string\">\"state\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># transform: linear transformation mapping the pre output to the post input</span></span><br><span class=\"line\">        <span class=\"comment\"># synapse: synapse model for filtering</span></span><br><span class=\"line\">        nengo.Connection(x.output, x.input, transform=tau_actual * A + I, synapse=tau_actual)</span><br><span class=\"line\">        nengo.Connection(net.input, x.input, transform=tau_actual*B, synapse=tau_actual)</span><br><span class=\"line\">        net.output = x.output</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    dt = <span class=\"number\">0.001</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Network(seed=<span class=\"number\">42</span>) <span class=\"keyword\">as</span> model:</span><br><span class=\"line\">        <span class=\"comment\"># winner takes all</span></span><br><span class=\"line\">        wta = LCA(<span class=\"number\">3</span>, <span class=\"number\">200</span>, dt)</span><br><span class=\"line\">        stimulus = nengo.Node([<span class=\"number\">0.8</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.6</span>])</span><br><span class=\"line\">        nengo.Connection(stimulus, wta.input, synapse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        p_stimulus = nengo.Probe(stimulus, synapse=<span class=\"literal\">None</span>)</span><br><span class=\"line\">        p_output = nengo.Probe(wta.output, synapse=<span class=\"number\">0.01</span>)</span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Simulator(model, dt=dt) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">        sim.run(<span class=\"number\">1.</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    fig = plt.figure()</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[p_output])</span><br><span class=\"line\">    plt.title(<span class=\"string\">\"(a)LCA\"</span>)</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">\"Time [s]\"</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">\"Decoded output\"</span>)</span><br><span class=\"line\">    plt.locator_params(axis=<span class=\"string\">'y'</span>, nbins=<span class=\"number\">5</span>)</span><br><span class=\"line\">    plt.tight_layout()</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"../images/lca.png\" alt=\"LCA\"></p>\n<p>可以看到3个ensemble中只有得到最强输入的一个保留了下来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SNN学习笔记5：LCA\"><a href=\"#SNN学习笔记5：LCA\" class=\"headerlink\" title=\"SNN学习笔记5：LCA\"></a>SNN学习笔记5：LCA</h1><h2 id=\"稀疏编码\"><a href=\"#稀疏编码\" class=\"headerlink\" title=\"稀疏编码\"></a>稀疏编码</h2><p>实验表明人脑对于外界刺激采取一种稀疏的内在表示，例如自然图像只需要用<a href=\"https://en.wikipedia.org/wiki/Sparse_dictionary_learning\" target=\"_blank\" rel=\"noopener\">稀疏词典</a>中一个很小的子集及合适的对应系数来进行稀疏近似（sparse approximation）。</p>\n<h3 id=\"稀疏近似\"><a href=\"#稀疏近似\" class=\"headerlink\" title=\"稀疏近似\"></a>稀疏近似</h3><p>稀疏近似的数学表述如下：</p>\n<p>​    给定一个N维刺激$s \\in \\mathbb{R}^N$, 找到一个基于由M个向量$\\{\\phi_m\\}$组成的词典$D$的表示。当词典$D$是overcomplete时（i.e M &gt; N），我们可以有无穷多种方式来选取词典中向量对应的稀疏$\\{a_m\\}$ 来表示$s$: $s = \\sum_{m = 1}^Ma_m\\phi_m$。</p>\n<p>在最优稀疏近似中，我们希望尽可能少的使用D中的向量，也就是<strong>系数不为0的向量尽可能的少</strong>：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a ||a||_0    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m</script><p>上式中$||a||_0$表示$\\ell^0$ norm, 也就是 $a = [a_1, a_2, …, a_M]$中非零元素的个数。需要注意的是，这个组合优化问题是NP-hard的。</p>\n<h3 id=\"Basis-Pursuit目标\"><a href=\"#Basis-Pursuit目标\" class=\"headerlink\" title=\"Basis Pursuit目标\"></a>Basis Pursuit目标</h3><p>对$\\ell_0$的优化是NP-hard的，BP目标函数尝试将优化目标改为最小化系数向量的$\\ell_1$ norm：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a ||a||_1    s.t.    s = \\sum_{m = 1}^Ma_m\\phi_m</script><p>BP目标函数在信号$s$相对稀疏时也可以得到最优稀疏近似。</p>\n<h3 id=\"BPDN：重建误差\"><a href=\"#BPDN：重建误差\" class=\"headerlink\" title=\"BPDN：重建误差\"></a>BPDN：重建误差</h3><p>实际操作中，由于$s$中存在噪音，我们不应该要求完美重建。BPDN（Basis Pursuit De-Noising）目标函数在BP的基础上引入了MSE重建误差来平衡正则项与重建精度：</p>\n<script type=\"math/tex; mode=display\">\n\\mathop{min}_a (||s - \\sum_{m = 1}^Ma_m\\phi_m||_2^2 + \\lambda||a||_1)</script><p>公式中的$\\lambda$正是用来权衡重建误差与正则项的。</p>\n<h4 id=\"MP算法\"><a href=\"#MP算法\" class=\"headerlink\" title=\"MP算法\"></a>MP算法</h4><p>在信号处理社区，常用MP(Matching Pursuit)算法来求解BPDN。MPs算法本质上是一种贪心算法，流程如下：</p>\n<ol>\n<li>将残差初始化为$s$: $r_0 = s$</li>\n<li>在第k次迭代，通过$\\theta_k = argmax_m|\\langle r_{k-1}, \\phi_m\\rangle|$找到词典M中的索引$\\theta_k$</li>\n<li>更新残差：$r_k = r_{k - 1} - \\phi_{\\theta_k}d_k$</li>\n</ol>\n<p>K次迭代后得到一个$s$的稀疏近似：$\\hat{s} = \\sum_{k = 1}^K \\phi_{\\theta_k}d_k$。</p>\n<h2 id=\"LCA\"><a href=\"#LCA\" class=\"headerlink\" title=\"LCA\"></a>LCA</h2><p><a href=\"https://ece.rice.edu/~eld1/papers/Rozell08.pdf\" target=\"_blank\" rel=\"noopener\">LCA</a>(Locally Competitive Algorithm)是一种稀疏编码算法，相比MP算法，不仅考虑到了选取最稀疏表示的目标，也考虑了选取最能表征信号特性的向量的目标。同时，LCA对随时间变化的信号的处理进行了优化，LCA不用每一步都从头进行稀疏近似，而是基于上一步的表征向量进行更新。</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><p>LCA中，词典中的每个向量$\\phi_m \\in D$都被关联到一个神经元。神经元中维护自己的膜电位$u_m(t)$，神经元的输入电流为输入与神经元的感受野的匹配度：$b_m(t) = \\langle\\phi_m, s(t)\\rangle$。当神经元m的膜电位超过阈值$\\lambda $时，输出一个激活信号$a_m = T_\\lambda(u_m)$并向周边神经元n发射抑制信号$a_mG_{m, n}$其中$ G_{m, n} = \\langle \\phi_m, \\phi_n \\rangle$。</p>\n<p>NOTE: 从抑制信号的公式中可以看出，一个神经元的激活越强，对周边神经元的抑制越强；一个神经元与周围的神经元越相似，对周围神经元的抑制越强。这种机制会导致匹配度最高的神经元得到最大的电流输入，然后抑制周边神经元得到输入及进行反向抑制，以此达到获取<strong>稀疏表示</strong>的效果（WTA：winner takes all）。</p>\n<p>上面的膜电位变化机制可以用下面的常微分方程来描述：</p>\n<script type=\"math/tex; mode=display\">\n\\dot{u}_m(t) = \\frac{1}{\\tau}[b_m(t) - u_m(t) - \\sum_\\limits{\\substack{n \\neq m} }G_{m, n}a_n(t)</script><h3 id=\"Demo实现\"><a href=\"#Demo实现\" class=\"headerlink\" title=\"Demo实现\"></a>Demo实现</h3><p>github上的一个<a href=\"https://github.com/ctn-waterloo/cogsci17-decide/blob/5e82b8cf466db5ce84270c866e9dc0c36daa52b6/cogsci17_decide/networks.py\" target=\"_blank\" rel=\"noopener\">参考实现</a>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nengo</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LCA</span><span class=\"params\">(d, n_neurons, dt)</span>:</span></span><br><span class=\"line\">    k = <span class=\"number\">1.</span></span><br><span class=\"line\">    beta = <span class=\"number\">1.</span></span><br><span class=\"line\">    tau_model = <span class=\"number\">0.1</span></span><br><span class=\"line\">    tau_actual = <span class=\"number\">0.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    I = np.eye(d)</span><br><span class=\"line\">    inhibit = <span class=\"number\">1</span> - I</span><br><span class=\"line\">    B = <span class=\"number\">1.</span> / tau_model</span><br><span class=\"line\">    A = (-k * I - beta * inhibit) / tau_model</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Network(label=<span class=\"string\">\"LCA\"</span>) <span class=\"keyword\">as</span> net:</span><br><span class=\"line\">        net.input = nengo.Node(size_in=d)</span><br><span class=\"line\">        <span class=\"comment\"># array of ensembles: d ensembles, each with n_neurons neurons</span></span><br><span class=\"line\">        x = nengo.networks.EnsembleArray(</span><br><span class=\"line\">            n_neurons, d,</span><br><span class=\"line\">            eval_points=nengo.dists.Uniform(<span class=\"number\">0.</span>, <span class=\"number\">1.</span>),</span><br><span class=\"line\">            intercepts=nengo.dists.Uniform(<span class=\"number\">0.</span>, <span class=\"number\">1.</span>),</span><br><span class=\"line\">            encoders=nengo.dists.Choice([[<span class=\"number\">1.</span>]]),</span><br><span class=\"line\">            label=<span class=\"string\">\"state\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># transform: linear transformation mapping the pre output to the post input</span></span><br><span class=\"line\">        <span class=\"comment\"># synapse: synapse model for filtering</span></span><br><span class=\"line\">        nengo.Connection(x.output, x.input, transform=tau_actual * A + I, synapse=tau_actual)</span><br><span class=\"line\">        nengo.Connection(net.input, x.input, transform=tau_actual*B, synapse=tau_actual)</span><br><span class=\"line\">        net.output = x.output</span><br><span class=\"line\">    <span class=\"keyword\">return</span> net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    dt = <span class=\"number\">0.001</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Network(seed=<span class=\"number\">42</span>) <span class=\"keyword\">as</span> model:</span><br><span class=\"line\">        <span class=\"comment\"># winner takes all</span></span><br><span class=\"line\">        wta = LCA(<span class=\"number\">3</span>, <span class=\"number\">200</span>, dt)</span><br><span class=\"line\">        stimulus = nengo.Node([<span class=\"number\">0.8</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.6</span>])</span><br><span class=\"line\">        nengo.Connection(stimulus, wta.input, synapse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        p_stimulus = nengo.Probe(stimulus, synapse=<span class=\"literal\">None</span>)</span><br><span class=\"line\">        p_output = nengo.Probe(wta.output, synapse=<span class=\"number\">0.01</span>)</span><br><span class=\"line\">    <span class=\"keyword\">with</span> nengo.Simulator(model, dt=dt) <span class=\"keyword\">as</span> sim:</span><br><span class=\"line\">        sim.run(<span class=\"number\">1.</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    fig = plt.figure()</span><br><span class=\"line\">    plt.plot(sim.trange(), sim.data[p_output])</span><br><span class=\"line\">    plt.title(<span class=\"string\">\"(a)LCA\"</span>)</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">\"Time [s]\"</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">\"Decoded output\"</span>)</span><br><span class=\"line\">    plt.locator_params(axis=<span class=\"string\">'y'</span>, nbins=<span class=\"number\">5</span>)</span><br><span class=\"line\">    plt.tight_layout()</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"../images/lca.png\" alt=\"LCA\"></p>\n<p>可以看到3个ensemble中只有得到最强输入的一个保留了下来。</p>\n"},{"title":"Tensorflow graph_matcher","date":"2020-07-20T01:34:12.000Z","mathjax":true,"_content":"\n# TF graph_matcher用法及源码探究\n\n`graph_matcher`是`tensorflow.contrib`中量化模块（`quantize`）的一个子模块，用于在计算图中描述和匹配特定的模式。配合对模式匹配后的处理，可以在python层面实现计算图的pass。\n\n## 用法: 以Conv + BN融合为例\n\nConv+BN是CNN网络中常见的组合。如果我们观察两者的计算公式，可以发现两者可以融合为一个算子达到运行加速的效果（实质上，Conv计算上等价于MatMul，所以融合也适用于FC+BN等组合）。\n\n### 融合原理\n\n首先，分别观察Conv和BN的计算公式：\n\n​\tConv的计算公式：$z = w * x + b$\n\n​\tBN的计算公式：$y = \\frac{(z - \\mu_B) * \\gamma}{ \\sigma_B} + \\beta$\n\n实际上，我们可以通过更新Conv的`weight`和`bias`直接在Conv中完成Conv + BN所需完成的计算。略去推导，直接给出新的`weight`和`bias`的计算公式如下：\n\n​\t$w^{\\prime} = \\frac{w * \\gamma}{\\sigma_B}$, $b^{\\prime} = \\frac{(b - \\mu_B)\\gamma}{\\sigma_B} + \\beta$\n\n代入新的$w^{'}$和$b^{'}$，容易验证新的Conv计算等价于Conv + BN:\n$$\n\\begin{align}\nz^{\\prime} &= w^{\\prime} * x + b^{\\prime} \\\\\n          &= \\frac{w * \\gamma * x}{\\sigma_B} +\\frac{(b - \\mu_B) * \\gamma} {\\sigma_B} + \\beta \\\\\n          &=\\frac{\\gamma(w*x + b - \\mu_B)}{\\sigma_B} + \\beta \\\\\n          &=\\frac{(z - \\mu_B) * \\gamma}{\\sigma_B} + \\beta = y\n\\end{align}\n$$\n\n### graph_matcher实现\n\n`tensorflow.contrib.quantize.python`中包含了Conv + BN融合的[实现](https://github.com/tensorflow/tensorflow/blob/590d6eef7e91a6a7392c8ffffb7b58f2e0c8bc6b/tensorflow/contrib/quantize/python/fold_batch_norms.py#L151-L205)，完整的代码较长，我们重点关注其中对Conv+BN模式描述的部分。\n\n```python\ndef _FindFusedBatchNorms(graph):\n    \"\"\"Finds all ops and tensors related to found FusedBatchNorms.\n    \tArgs:\n    \t\tgraph: Graph to inspect.\n    \tReturns:\n    \t\t_FusedBatchNormMatches.\n    \"\"\"\n    input_pattern = graph_matcher.OpTypePattern('*')\n    weight_pattern = graph_matcher.OpTypePattern('*')\n    gamma_pattern = graph_matcher.OpTypePattern('*')\n    beta_pattern = graph_matcher.OpTypePattern('*')\n    mean_pattern = graph_matcher.OpTypePattern('*')\n    variance_pattern = graph_matcher.OpTypePattern('*')\n    \n    moving_average_pattern = graph_matcher.OpTypePattern('*')\n    bn_decay_pattern = graph_matcher.OpTypePattern('*')\n    layer_pattern = graph_matcher.OpTypePattern('Conv2D|DepthwiseConv2dNative|MatMul', inputs=[input_pattern, weight_pattern])\n    ...\n    layer_output_pattern = graph_matcher.OneofPattern([layer_pattern_with_identity, layer_pattern, batch_to_space_pattern])\n    ...\n    bn_matcher = graph_matcher.GraphMatcher(graph_matcher.OneofPattern([matmul_bn_output_reshape_pattern, batch_norm_pattern]))\n    ...\n    def _GetLayerMatch(match_result):\n        \"\"\"Populates a layer match object containing ops/tensors for folding BNs.\n        Args:\n        \tmatch_result: Matched result from graph matcher\n        Returns:\n        \tlayer_op: Matching conv/fc op prior to batch norm\n        \tBatchNormMatch: _BatchNormMatch containing all required batch norm parameters.\n        \"\"\"\n        ...\n    layer_matches = []\n    matched_layer_set = set()\n    for match_result in bn_identity_matcher.match_graph(graph):\n        layer_op, layer_match = _GetLayerMatch(match_result)\n        if layer_op is not None:\n            if layer_op not in matched_layer_set:\n                matched_layer_set.add(layer_op)\n                layer_matches.append(layer_match)\n    ...\n    return layer_matches\ndef _FoldFusedBatchNorms(graph, is_training, freeze_batch_norm_delay):\n    \"\"\"Finds fused batch norm layers and folds them into preceding layers.\n    Folding only affects the following layers: Conv2D, fully connected, depthwise convolution.\n    Args:\n    \tgraph: Graph to walk and modify.\n    \tis_training: Bool, true if training.\n    \tfreeze_batch_norm_delay: How many steps to wait before freezing moving mean\n      and variance and using them for batch normalization.\n  Raises:\n  \tValueError: When batch norm folding fails.\n  \t\"\"\"\n    for match in _FindFusedBatchNorms(graph):\n        scope, sep, _ = match.layer_op.name.rpartition('/')\n        with graph.as_default(), graph.name_scope(scope + sep):\n            with graph.name_scope(scope + sep + 'BatchNorm_Fold' + sep):\n                # new weights = old weights * gamma / sqrt(variance + epsilon)\n                # new biases = -mean * gamma / sqrt(variance + epsilon) + beta\n                multiplier_tensor = match.gamma_tensor * math_ops.rsqrt(match.variance_tensor + match.bn_op.get_attr('epsilon'))\n                bias_tensor = math_ops.subtract(match.beta_tensor, match.mean_tensor * multiplier_tensor, name='bias')\n    ...\n```\n\n#### 流程\n\n使用`GraphMatcher`进行pattern描述、匹配、替换主要分为以下几步：\n\n1. 使用`OpTypePattern`及`OneofPattern`（语法糖）自底向上构建目标pattern\n2. 用目标pattern构造`GraphMatcher`\n3. 向`GraphMatcher`的`match_graph`方法传入要匹配的图，获得`match_result`\n4. 从`match_result`中取出需要复用的pattern中的节点，构造新的节点替换pattern\n\n## graph_matcher实现\n\ngraph_matcher的[实现](https://github.com/rockchip-linux/tensorflow/blob/master/tensorflow/contrib/quantize/python/graph_matcher.py)主要包括三个部分：`Pattern`, `GraphMatcher`, `MatchResult`。\n\n### Pattern实现\n\nPattern作为一个抽象类，要求子类必须实现`match`方法。`match`方法接收两个参数：`op`；`tensor`。\n\nPattern类有两个子类：`OpTypePattern`类可以限定节点的类型、输入，可以描述一个类型树；`Oneof`\n\n`Pattern`作为语法糖用于描述one-of关系，也就是匹配输入多个子模式之一即可。\n\nNOTE: 当前实现了的模式中，`match`方法中的`tensor`只是占位用，没有实际使用到。\n\n#### OpTypePattern\n\n构造函数（`def __init__(self, op_type, name=None, inputs=None, ordered_inputs=True)`）通过限定节点的类型、输入来描述一个类型树；对应的，`match`中也会递归地对输入节点调用`match`函数。NOTE: `OpType`的匹配是使用字符串来完成的。\n\n### MatchResult\n\n保存match的结果，可以从`Pattern`实例映射到对应的匹配到的`op`和`tensor`。\n\n### GraphMatcher\n\n`GraphMatcher`中会保存一个pattern，提供方法来检验输入的`op`或者`graph`是否和`pattern`匹配，主要方法有：\n\n1. match_op\n2. match_ops\n3. match_graph\n\n## 拓展思考\n\n`TensorFlow`中能够轻松的在python中操作图主要得益于图数据结构对python的暴露。当前MindSpore要在python中支持图pass(图中模式的匹配和替换)，可以对比两种思路：\n\n1. python向C++注册pass，python中对模式和要替换的目标进行描述，C++中运行pass\n   1. 优点：可以复用部分优化器部分的代码；执行效率较高\n   2. 缺点：python pass中的pattern、target与C++通信较复杂\n2. C++向python暴露图接口，直接在python中完成改图\n   1. 优点：对图修改的逻辑全部包含在python中\n   2. 缺点：效率较低，但此类任务通常较低频，性能要求不高\n\n综合考虑，C++新增向python暴露图接口，直接在python中完成改图较合理。","source":"_posts/Tensorflow-Graph-Matcher.md","raw":"---\ntitle: Tensorflow graph_matcher\ndate: 2020-07-20 09:34:12\ncategories: AI\ntags: TensorFlow, Deep Learning\nmathjax: true\n---\n\n# TF graph_matcher用法及源码探究\n\n`graph_matcher`是`tensorflow.contrib`中量化模块（`quantize`）的一个子模块，用于在计算图中描述和匹配特定的模式。配合对模式匹配后的处理，可以在python层面实现计算图的pass。\n\n## 用法: 以Conv + BN融合为例\n\nConv+BN是CNN网络中常见的组合。如果我们观察两者的计算公式，可以发现两者可以融合为一个算子达到运行加速的效果（实质上，Conv计算上等价于MatMul，所以融合也适用于FC+BN等组合）。\n\n### 融合原理\n\n首先，分别观察Conv和BN的计算公式：\n\n​\tConv的计算公式：$z = w * x + b$\n\n​\tBN的计算公式：$y = \\frac{(z - \\mu_B) * \\gamma}{ \\sigma_B} + \\beta$\n\n实际上，我们可以通过更新Conv的`weight`和`bias`直接在Conv中完成Conv + BN所需完成的计算。略去推导，直接给出新的`weight`和`bias`的计算公式如下：\n\n​\t$w^{\\prime} = \\frac{w * \\gamma}{\\sigma_B}$, $b^{\\prime} = \\frac{(b - \\mu_B)\\gamma}{\\sigma_B} + \\beta$\n\n代入新的$w^{'}$和$b^{'}$，容易验证新的Conv计算等价于Conv + BN:\n$$\n\\begin{align}\nz^{\\prime} &= w^{\\prime} * x + b^{\\prime} \\\\\n          &= \\frac{w * \\gamma * x}{\\sigma_B} +\\frac{(b - \\mu_B) * \\gamma} {\\sigma_B} + \\beta \\\\\n          &=\\frac{\\gamma(w*x + b - \\mu_B)}{\\sigma_B} + \\beta \\\\\n          &=\\frac{(z - \\mu_B) * \\gamma}{\\sigma_B} + \\beta = y\n\\end{align}\n$$\n\n### graph_matcher实现\n\n`tensorflow.contrib.quantize.python`中包含了Conv + BN融合的[实现](https://github.com/tensorflow/tensorflow/blob/590d6eef7e91a6a7392c8ffffb7b58f2e0c8bc6b/tensorflow/contrib/quantize/python/fold_batch_norms.py#L151-L205)，完整的代码较长，我们重点关注其中对Conv+BN模式描述的部分。\n\n```python\ndef _FindFusedBatchNorms(graph):\n    \"\"\"Finds all ops and tensors related to found FusedBatchNorms.\n    \tArgs:\n    \t\tgraph: Graph to inspect.\n    \tReturns:\n    \t\t_FusedBatchNormMatches.\n    \"\"\"\n    input_pattern = graph_matcher.OpTypePattern('*')\n    weight_pattern = graph_matcher.OpTypePattern('*')\n    gamma_pattern = graph_matcher.OpTypePattern('*')\n    beta_pattern = graph_matcher.OpTypePattern('*')\n    mean_pattern = graph_matcher.OpTypePattern('*')\n    variance_pattern = graph_matcher.OpTypePattern('*')\n    \n    moving_average_pattern = graph_matcher.OpTypePattern('*')\n    bn_decay_pattern = graph_matcher.OpTypePattern('*')\n    layer_pattern = graph_matcher.OpTypePattern('Conv2D|DepthwiseConv2dNative|MatMul', inputs=[input_pattern, weight_pattern])\n    ...\n    layer_output_pattern = graph_matcher.OneofPattern([layer_pattern_with_identity, layer_pattern, batch_to_space_pattern])\n    ...\n    bn_matcher = graph_matcher.GraphMatcher(graph_matcher.OneofPattern([matmul_bn_output_reshape_pattern, batch_norm_pattern]))\n    ...\n    def _GetLayerMatch(match_result):\n        \"\"\"Populates a layer match object containing ops/tensors for folding BNs.\n        Args:\n        \tmatch_result: Matched result from graph matcher\n        Returns:\n        \tlayer_op: Matching conv/fc op prior to batch norm\n        \tBatchNormMatch: _BatchNormMatch containing all required batch norm parameters.\n        \"\"\"\n        ...\n    layer_matches = []\n    matched_layer_set = set()\n    for match_result in bn_identity_matcher.match_graph(graph):\n        layer_op, layer_match = _GetLayerMatch(match_result)\n        if layer_op is not None:\n            if layer_op not in matched_layer_set:\n                matched_layer_set.add(layer_op)\n                layer_matches.append(layer_match)\n    ...\n    return layer_matches\ndef _FoldFusedBatchNorms(graph, is_training, freeze_batch_norm_delay):\n    \"\"\"Finds fused batch norm layers and folds them into preceding layers.\n    Folding only affects the following layers: Conv2D, fully connected, depthwise convolution.\n    Args:\n    \tgraph: Graph to walk and modify.\n    \tis_training: Bool, true if training.\n    \tfreeze_batch_norm_delay: How many steps to wait before freezing moving mean\n      and variance and using them for batch normalization.\n  Raises:\n  \tValueError: When batch norm folding fails.\n  \t\"\"\"\n    for match in _FindFusedBatchNorms(graph):\n        scope, sep, _ = match.layer_op.name.rpartition('/')\n        with graph.as_default(), graph.name_scope(scope + sep):\n            with graph.name_scope(scope + sep + 'BatchNorm_Fold' + sep):\n                # new weights = old weights * gamma / sqrt(variance + epsilon)\n                # new biases = -mean * gamma / sqrt(variance + epsilon) + beta\n                multiplier_tensor = match.gamma_tensor * math_ops.rsqrt(match.variance_tensor + match.bn_op.get_attr('epsilon'))\n                bias_tensor = math_ops.subtract(match.beta_tensor, match.mean_tensor * multiplier_tensor, name='bias')\n    ...\n```\n\n#### 流程\n\n使用`GraphMatcher`进行pattern描述、匹配、替换主要分为以下几步：\n\n1. 使用`OpTypePattern`及`OneofPattern`（语法糖）自底向上构建目标pattern\n2. 用目标pattern构造`GraphMatcher`\n3. 向`GraphMatcher`的`match_graph`方法传入要匹配的图，获得`match_result`\n4. 从`match_result`中取出需要复用的pattern中的节点，构造新的节点替换pattern\n\n## graph_matcher实现\n\ngraph_matcher的[实现](https://github.com/rockchip-linux/tensorflow/blob/master/tensorflow/contrib/quantize/python/graph_matcher.py)主要包括三个部分：`Pattern`, `GraphMatcher`, `MatchResult`。\n\n### Pattern实现\n\nPattern作为一个抽象类，要求子类必须实现`match`方法。`match`方法接收两个参数：`op`；`tensor`。\n\nPattern类有两个子类：`OpTypePattern`类可以限定节点的类型、输入，可以描述一个类型树；`Oneof`\n\n`Pattern`作为语法糖用于描述one-of关系，也就是匹配输入多个子模式之一即可。\n\nNOTE: 当前实现了的模式中，`match`方法中的`tensor`只是占位用，没有实际使用到。\n\n#### OpTypePattern\n\n构造函数（`def __init__(self, op_type, name=None, inputs=None, ordered_inputs=True)`）通过限定节点的类型、输入来描述一个类型树；对应的，`match`中也会递归地对输入节点调用`match`函数。NOTE: `OpType`的匹配是使用字符串来完成的。\n\n### MatchResult\n\n保存match的结果，可以从`Pattern`实例映射到对应的匹配到的`op`和`tensor`。\n\n### GraphMatcher\n\n`GraphMatcher`中会保存一个pattern，提供方法来检验输入的`op`或者`graph`是否和`pattern`匹配，主要方法有：\n\n1. match_op\n2. match_ops\n3. match_graph\n\n## 拓展思考\n\n`TensorFlow`中能够轻松的在python中操作图主要得益于图数据结构对python的暴露。当前MindSpore要在python中支持图pass(图中模式的匹配和替换)，可以对比两种思路：\n\n1. python向C++注册pass，python中对模式和要替换的目标进行描述，C++中运行pass\n   1. 优点：可以复用部分优化器部分的代码；执行效率较高\n   2. 缺点：python pass中的pattern、target与C++通信较复杂\n2. C++向python暴露图接口，直接在python中完成改图\n   1. 优点：对图修改的逻辑全部包含在python中\n   2. 缺点：效率较低，但此类任务通常较低频，性能要求不高\n\n综合考虑，C++新增向python暴露图接口，直接在python中完成改图较合理。","slug":"Tensorflow-Graph-Matcher","published":1,"updated":"2020-07-21T06:34:23.753Z","_id":"ckcugunuv00003s79coth05ko","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"TF-graph-matcher用法及源码探究\"><a href=\"#TF-graph-matcher用法及源码探究\" class=\"headerlink\" title=\"TF graph_matcher用法及源码探究\"></a>TF graph_matcher用法及源码探究</h1><p><code>graph_matcher</code>是<code>tensorflow.contrib</code>中量化模块（<code>quantize</code>）的一个子模块，用于在计算图中描述和匹配特定的模式。配合对模式匹配后的处理，可以在python层面实现计算图的pass。</p>\n<h2 id=\"用法-以Conv-BN融合为例\"><a href=\"#用法-以Conv-BN融合为例\" class=\"headerlink\" title=\"用法: 以Conv + BN融合为例\"></a>用法: 以Conv + BN融合为例</h2><p>Conv+BN是CNN网络中常见的组合。如果我们观察两者的计算公式，可以发现两者可以融合为一个算子达到运行加速的效果（实质上，Conv计算上等价于MatMul，所以融合也适用于FC+BN等组合）。</p>\n<h3 id=\"融合原理\"><a href=\"#融合原理\" class=\"headerlink\" title=\"融合原理\"></a>融合原理</h3><p>首先，分别观察Conv和BN的计算公式：</p>\n<p>​    Conv的计算公式：$z = w * x + b$</p>\n<p>​    BN的计算公式：$y = \\frac{(z - \\mu_B) * \\gamma}{ \\sigma_B} + \\beta$</p>\n<p>实际上，我们可以通过更新Conv的<code>weight</code>和<code>bias</code>直接在Conv中完成Conv + BN所需完成的计算。略去推导，直接给出新的<code>weight</code>和<code>bias</code>的计算公式如下：</p>\n<p>​    $w^{\\prime} = \\frac{w * \\gamma}{\\sigma_B}$, $b^{\\prime} = \\frac{(b - \\mu_B)\\gamma}{\\sigma_B} + \\beta$</p>\n<p>代入新的$w^{‘}$和$b^{‘}$，容易验证新的Conv计算等价于Conv + BN:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nz^{\\prime} &= w^{\\prime} * x + b^{\\prime} \\\\\n          &= \\frac{w * \\gamma * x}{\\sigma_B} +\\frac{(b - \\mu_B) * \\gamma} {\\sigma_B} + \\beta \\\\\n          &=\\frac{\\gamma(w*x + b - \\mu_B)}{\\sigma_B} + \\beta \\\\\n          &=\\frac{(z - \\mu_B) * \\gamma}{\\sigma_B} + \\beta = y\n\\end{align}</script><h3 id=\"graph-matcher实现\"><a href=\"#graph-matcher实现\" class=\"headerlink\" title=\"graph_matcher实现\"></a>graph_matcher实现</h3><p><code>tensorflow.contrib.quantize.python</code>中包含了Conv + BN融合的<a href=\"https://github.com/tensorflow/tensorflow/blob/590d6eef7e91a6a7392c8ffffb7b58f2e0c8bc6b/tensorflow/contrib/quantize/python/fold_batch_norms.py#L151-L205\" target=\"_blank\" rel=\"noopener\">实现</a>，完整的代码较长，我们重点关注其中对Conv+BN模式描述的部分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_FindFusedBatchNorms</span><span class=\"params\">(graph)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finds all ops and tensors related to found FusedBatchNorms.</span></span><br><span class=\"line\"><span class=\"string\">    \tArgs:</span></span><br><span class=\"line\"><span class=\"string\">    \t\tgraph: Graph to inspect.</span></span><br><span class=\"line\"><span class=\"string\">    \tReturns:</span></span><br><span class=\"line\"><span class=\"string\">    \t\t_FusedBatchNormMatches.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    input_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    weight_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    gamma_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    beta_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    mean_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    variance_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    moving_average_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    bn_decay_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    layer_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'Conv2D|DepthwiseConv2dNative|MatMul'</span>, inputs=[input_pattern, weight_pattern])</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layer_output_pattern = graph_matcher.OneofPattern([layer_pattern_with_identity, layer_pattern, batch_to_space_pattern])</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    bn_matcher = graph_matcher.GraphMatcher(graph_matcher.OneofPattern([matmul_bn_output_reshape_pattern, batch_norm_pattern]))</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_GetLayerMatch</span><span class=\"params\">(match_result)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Populates a layer match object containing ops/tensors for folding BNs.</span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">        \tmatch_result: Matched result from graph matcher</span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">        \tlayer_op: Matching conv/fc op prior to batch norm</span></span><br><span class=\"line\"><span class=\"string\">        \tBatchNormMatch: _BatchNormMatch containing all required batch norm parameters.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    layer_matches = []</span><br><span class=\"line\">    matched_layer_set = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> match_result <span class=\"keyword\">in</span> bn_identity_matcher.match_graph(graph):</span><br><span class=\"line\">        layer_op, layer_match = _GetLayerMatch(match_result)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> layer_op <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> layer_op <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> matched_layer_set:</span><br><span class=\"line\">                matched_layer_set.add(layer_op)</span><br><span class=\"line\">                layer_matches.append(layer_match)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> layer_matches</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_FoldFusedBatchNorms</span><span class=\"params\">(graph, is_training, freeze_batch_norm_delay)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finds fused batch norm layers and folds them into preceding layers.</span></span><br><span class=\"line\"><span class=\"string\">    Folding only affects the following layers: Conv2D, fully connected, depthwise convolution.</span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">    \tgraph: Graph to walk and modify.</span></span><br><span class=\"line\"><span class=\"string\">    \tis_training: Bool, true if training.</span></span><br><span class=\"line\"><span class=\"string\">    \tfreeze_batch_norm_delay: How many steps to wait before freezing moving mean</span></span><br><span class=\"line\"><span class=\"string\">      and variance and using them for batch normalization.</span></span><br><span class=\"line\"><span class=\"string\">  Raises:</span></span><br><span class=\"line\"><span class=\"string\">  \tValueError: When batch norm folding fails.</span></span><br><span class=\"line\"><span class=\"string\">  \t\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> match <span class=\"keyword\">in</span> _FindFusedBatchNorms(graph):</span><br><span class=\"line\">        scope, sep, _ = match.layer_op.name.rpartition(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> graph.as_default(), graph.name_scope(scope + sep):</span><br><span class=\"line\">            <span class=\"keyword\">with</span> graph.name_scope(scope + sep + <span class=\"string\">'BatchNorm_Fold'</span> + sep):</span><br><span class=\"line\">                <span class=\"comment\"># new weights = old weights * gamma / sqrt(variance + epsilon)</span></span><br><span class=\"line\">                <span class=\"comment\"># new biases = -mean * gamma / sqrt(variance + epsilon) + beta</span></span><br><span class=\"line\">                multiplier_tensor = match.gamma_tensor * math_ops.rsqrt(match.variance_tensor + match.bn_op.get_attr(<span class=\"string\">'epsilon'</span>))</span><br><span class=\"line\">                bias_tensor = math_ops.subtract(match.beta_tensor, match.mean_tensor * multiplier_tensor, name=<span class=\"string\">'bias'</span>)</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>使用<code>GraphMatcher</code>进行pattern描述、匹配、替换主要分为以下几步：</p>\n<ol>\n<li>使用<code>OpTypePattern</code>及<code>OneofPattern</code>（语法糖）自底向上构建目标pattern</li>\n<li>用目标pattern构造<code>GraphMatcher</code></li>\n<li>向<code>GraphMatcher</code>的<code>match_graph</code>方法传入要匹配的图，获得<code>match_result</code></li>\n<li>从<code>match_result</code>中取出需要复用的pattern中的节点，构造新的节点替换pattern</li>\n</ol>\n<h2 id=\"graph-matcher实现-1\"><a href=\"#graph-matcher实现-1\" class=\"headerlink\" title=\"graph_matcher实现\"></a>graph_matcher实现</h2><p>graph_matcher的<a href=\"https://github.com/rockchip-linux/tensorflow/blob/master/tensorflow/contrib/quantize/python/graph_matcher.py\" target=\"_blank\" rel=\"noopener\">实现</a>主要包括三个部分：<code>Pattern</code>, <code>GraphMatcher</code>, <code>MatchResult</code>。</p>\n<h3 id=\"Pattern实现\"><a href=\"#Pattern实现\" class=\"headerlink\" title=\"Pattern实现\"></a>Pattern实现</h3><p>Pattern作为一个抽象类，要求子类必须实现<code>match</code>方法。<code>match</code>方法接收两个参数：<code>op</code>；<code>tensor</code>。</p>\n<p>Pattern类有两个子类：<code>OpTypePattern</code>类可以限定节点的类型、输入，可以描述一个类型树；<code>Oneof</code></p>\n<p><code>Pattern</code>作为语法糖用于描述one-of关系，也就是匹配输入多个子模式之一即可。</p>\n<p>NOTE: 当前实现了的模式中，<code>match</code>方法中的<code>tensor</code>只是占位用，没有实际使用到。</p>\n<h4 id=\"OpTypePattern\"><a href=\"#OpTypePattern\" class=\"headerlink\" title=\"OpTypePattern\"></a>OpTypePattern</h4><p>构造函数（<code>def __init__(self, op_type, name=None, inputs=None, ordered_inputs=True)</code>）通过限定节点的类型、输入来描述一个类型树；对应的，<code>match</code>中也会递归地对输入节点调用<code>match</code>函数。NOTE: <code>OpType</code>的匹配是使用字符串来完成的。</p>\n<h3 id=\"MatchResult\"><a href=\"#MatchResult\" class=\"headerlink\" title=\"MatchResult\"></a>MatchResult</h3><p>保存match的结果，可以从<code>Pattern</code>实例映射到对应的匹配到的<code>op</code>和<code>tensor</code>。</p>\n<h3 id=\"GraphMatcher\"><a href=\"#GraphMatcher\" class=\"headerlink\" title=\"GraphMatcher\"></a>GraphMatcher</h3><p><code>GraphMatcher</code>中会保存一个pattern，提供方法来检验输入的<code>op</code>或者<code>graph</code>是否和<code>pattern</code>匹配，主要方法有：</p>\n<ol>\n<li>match_op</li>\n<li>match_ops</li>\n<li>match_graph</li>\n</ol>\n<h2 id=\"拓展思考\"><a href=\"#拓展思考\" class=\"headerlink\" title=\"拓展思考\"></a>拓展思考</h2><p><code>TensorFlow</code>中能够轻松的在python中操作图主要得益于图数据结构对python的暴露。当前MindSpore要在python中支持图pass(图中模式的匹配和替换)，可以对比两种思路：</p>\n<ol>\n<li>python向C++注册pass，python中对模式和要替换的目标进行描述，C++中运行pass<ol>\n<li>优点：可以复用部分优化器部分的代码；执行效率较高</li>\n<li>缺点：python pass中的pattern、target与C++通信较复杂</li>\n</ol>\n</li>\n<li>C++向python暴露图接口，直接在python中完成改图<ol>\n<li>优点：对图修改的逻辑全部包含在python中</li>\n<li>缺点：效率较低，但此类任务通常较低频，性能要求不高</li>\n</ol>\n</li>\n</ol>\n<p>综合考虑，C++新增向python暴露图接口，直接在python中完成改图较合理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TF-graph-matcher用法及源码探究\"><a href=\"#TF-graph-matcher用法及源码探究\" class=\"headerlink\" title=\"TF graph_matcher用法及源码探究\"></a>TF graph_matcher用法及源码探究</h1><p><code>graph_matcher</code>是<code>tensorflow.contrib</code>中量化模块（<code>quantize</code>）的一个子模块，用于在计算图中描述和匹配特定的模式。配合对模式匹配后的处理，可以在python层面实现计算图的pass。</p>\n<h2 id=\"用法-以Conv-BN融合为例\"><a href=\"#用法-以Conv-BN融合为例\" class=\"headerlink\" title=\"用法: 以Conv + BN融合为例\"></a>用法: 以Conv + BN融合为例</h2><p>Conv+BN是CNN网络中常见的组合。如果我们观察两者的计算公式，可以发现两者可以融合为一个算子达到运行加速的效果（实质上，Conv计算上等价于MatMul，所以融合也适用于FC+BN等组合）。</p>\n<h3 id=\"融合原理\"><a href=\"#融合原理\" class=\"headerlink\" title=\"融合原理\"></a>融合原理</h3><p>首先，分别观察Conv和BN的计算公式：</p>\n<p>​    Conv的计算公式：$z = w * x + b$</p>\n<p>​    BN的计算公式：$y = \\frac{(z - \\mu_B) * \\gamma}{ \\sigma_B} + \\beta$</p>\n<p>实际上，我们可以通过更新Conv的<code>weight</code>和<code>bias</code>直接在Conv中完成Conv + BN所需完成的计算。略去推导，直接给出新的<code>weight</code>和<code>bias</code>的计算公式如下：</p>\n<p>​    $w^{\\prime} = \\frac{w * \\gamma}{\\sigma_B}$, $b^{\\prime} = \\frac{(b - \\mu_B)\\gamma}{\\sigma_B} + \\beta$</p>\n<p>代入新的$w^{‘}$和$b^{‘}$，容易验证新的Conv计算等价于Conv + BN:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nz^{\\prime} &= w^{\\prime} * x + b^{\\prime} \\\\\n          &= \\frac{w * \\gamma * x}{\\sigma_B} +\\frac{(b - \\mu_B) * \\gamma} {\\sigma_B} + \\beta \\\\\n          &=\\frac{\\gamma(w*x + b - \\mu_B)}{\\sigma_B} + \\beta \\\\\n          &=\\frac{(z - \\mu_B) * \\gamma}{\\sigma_B} + \\beta = y\n\\end{align}</script><h3 id=\"graph-matcher实现\"><a href=\"#graph-matcher实现\" class=\"headerlink\" title=\"graph_matcher实现\"></a>graph_matcher实现</h3><p><code>tensorflow.contrib.quantize.python</code>中包含了Conv + BN融合的<a href=\"https://github.com/tensorflow/tensorflow/blob/590d6eef7e91a6a7392c8ffffb7b58f2e0c8bc6b/tensorflow/contrib/quantize/python/fold_batch_norms.py#L151-L205\" target=\"_blank\" rel=\"noopener\">实现</a>，完整的代码较长，我们重点关注其中对Conv+BN模式描述的部分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_FindFusedBatchNorms</span><span class=\"params\">(graph)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finds all ops and tensors related to found FusedBatchNorms.</span></span><br><span class=\"line\"><span class=\"string\">    \tArgs:</span></span><br><span class=\"line\"><span class=\"string\">    \t\tgraph: Graph to inspect.</span></span><br><span class=\"line\"><span class=\"string\">    \tReturns:</span></span><br><span class=\"line\"><span class=\"string\">    \t\t_FusedBatchNormMatches.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    input_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    weight_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    gamma_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    beta_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    mean_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    variance_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    moving_average_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    bn_decay_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'*'</span>)</span><br><span class=\"line\">    layer_pattern = graph_matcher.OpTypePattern(<span class=\"string\">'Conv2D|DepthwiseConv2dNative|MatMul'</span>, inputs=[input_pattern, weight_pattern])</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layer_output_pattern = graph_matcher.OneofPattern([layer_pattern_with_identity, layer_pattern, batch_to_space_pattern])</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    bn_matcher = graph_matcher.GraphMatcher(graph_matcher.OneofPattern([matmul_bn_output_reshape_pattern, batch_norm_pattern]))</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_GetLayerMatch</span><span class=\"params\">(match_result)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Populates a layer match object containing ops/tensors for folding BNs.</span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">        \tmatch_result: Matched result from graph matcher</span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">        \tlayer_op: Matching conv/fc op prior to batch norm</span></span><br><span class=\"line\"><span class=\"string\">        \tBatchNormMatch: _BatchNormMatch containing all required batch norm parameters.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    layer_matches = []</span><br><span class=\"line\">    matched_layer_set = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> match_result <span class=\"keyword\">in</span> bn_identity_matcher.match_graph(graph):</span><br><span class=\"line\">        layer_op, layer_match = _GetLayerMatch(match_result)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> layer_op <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> layer_op <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> matched_layer_set:</span><br><span class=\"line\">                matched_layer_set.add(layer_op)</span><br><span class=\"line\">                layer_matches.append(layer_match)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> layer_matches</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_FoldFusedBatchNorms</span><span class=\"params\">(graph, is_training, freeze_batch_norm_delay)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finds fused batch norm layers and folds them into preceding layers.</span></span><br><span class=\"line\"><span class=\"string\">    Folding only affects the following layers: Conv2D, fully connected, depthwise convolution.</span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">    \tgraph: Graph to walk and modify.</span></span><br><span class=\"line\"><span class=\"string\">    \tis_training: Bool, true if training.</span></span><br><span class=\"line\"><span class=\"string\">    \tfreeze_batch_norm_delay: How many steps to wait before freezing moving mean</span></span><br><span class=\"line\"><span class=\"string\">      and variance and using them for batch normalization.</span></span><br><span class=\"line\"><span class=\"string\">  Raises:</span></span><br><span class=\"line\"><span class=\"string\">  \tValueError: When batch norm folding fails.</span></span><br><span class=\"line\"><span class=\"string\">  \t\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> match <span class=\"keyword\">in</span> _FindFusedBatchNorms(graph):</span><br><span class=\"line\">        scope, sep, _ = match.layer_op.name.rpartition(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> graph.as_default(), graph.name_scope(scope + sep):</span><br><span class=\"line\">            <span class=\"keyword\">with</span> graph.name_scope(scope + sep + <span class=\"string\">'BatchNorm_Fold'</span> + sep):</span><br><span class=\"line\">                <span class=\"comment\"># new weights = old weights * gamma / sqrt(variance + epsilon)</span></span><br><span class=\"line\">                <span class=\"comment\"># new biases = -mean * gamma / sqrt(variance + epsilon) + beta</span></span><br><span class=\"line\">                multiplier_tensor = match.gamma_tensor * math_ops.rsqrt(match.variance_tensor + match.bn_op.get_attr(<span class=\"string\">'epsilon'</span>))</span><br><span class=\"line\">                bias_tensor = math_ops.subtract(match.beta_tensor, match.mean_tensor * multiplier_tensor, name=<span class=\"string\">'bias'</span>)</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>使用<code>GraphMatcher</code>进行pattern描述、匹配、替换主要分为以下几步：</p>\n<ol>\n<li>使用<code>OpTypePattern</code>及<code>OneofPattern</code>（语法糖）自底向上构建目标pattern</li>\n<li>用目标pattern构造<code>GraphMatcher</code></li>\n<li>向<code>GraphMatcher</code>的<code>match_graph</code>方法传入要匹配的图，获得<code>match_result</code></li>\n<li>从<code>match_result</code>中取出需要复用的pattern中的节点，构造新的节点替换pattern</li>\n</ol>\n<h2 id=\"graph-matcher实现-1\"><a href=\"#graph-matcher实现-1\" class=\"headerlink\" title=\"graph_matcher实现\"></a>graph_matcher实现</h2><p>graph_matcher的<a href=\"https://github.com/rockchip-linux/tensorflow/blob/master/tensorflow/contrib/quantize/python/graph_matcher.py\" target=\"_blank\" rel=\"noopener\">实现</a>主要包括三个部分：<code>Pattern</code>, <code>GraphMatcher</code>, <code>MatchResult</code>。</p>\n<h3 id=\"Pattern实现\"><a href=\"#Pattern实现\" class=\"headerlink\" title=\"Pattern实现\"></a>Pattern实现</h3><p>Pattern作为一个抽象类，要求子类必须实现<code>match</code>方法。<code>match</code>方法接收两个参数：<code>op</code>；<code>tensor</code>。</p>\n<p>Pattern类有两个子类：<code>OpTypePattern</code>类可以限定节点的类型、输入，可以描述一个类型树；<code>Oneof</code></p>\n<p><code>Pattern</code>作为语法糖用于描述one-of关系，也就是匹配输入多个子模式之一即可。</p>\n<p>NOTE: 当前实现了的模式中，<code>match</code>方法中的<code>tensor</code>只是占位用，没有实际使用到。</p>\n<h4 id=\"OpTypePattern\"><a href=\"#OpTypePattern\" class=\"headerlink\" title=\"OpTypePattern\"></a>OpTypePattern</h4><p>构造函数（<code>def __init__(self, op_type, name=None, inputs=None, ordered_inputs=True)</code>）通过限定节点的类型、输入来描述一个类型树；对应的，<code>match</code>中也会递归地对输入节点调用<code>match</code>函数。NOTE: <code>OpType</code>的匹配是使用字符串来完成的。</p>\n<h3 id=\"MatchResult\"><a href=\"#MatchResult\" class=\"headerlink\" title=\"MatchResult\"></a>MatchResult</h3><p>保存match的结果，可以从<code>Pattern</code>实例映射到对应的匹配到的<code>op</code>和<code>tensor</code>。</p>\n<h3 id=\"GraphMatcher\"><a href=\"#GraphMatcher\" class=\"headerlink\" title=\"GraphMatcher\"></a>GraphMatcher</h3><p><code>GraphMatcher</code>中会保存一个pattern，提供方法来检验输入的<code>op</code>或者<code>graph</code>是否和<code>pattern</code>匹配，主要方法有：</p>\n<ol>\n<li>match_op</li>\n<li>match_ops</li>\n<li>match_graph</li>\n</ol>\n<h2 id=\"拓展思考\"><a href=\"#拓展思考\" class=\"headerlink\" title=\"拓展思考\"></a>拓展思考</h2><p><code>TensorFlow</code>中能够轻松的在python中操作图主要得益于图数据结构对python的暴露。当前MindSpore要在python中支持图pass(图中模式的匹配和替换)，可以对比两种思路：</p>\n<ol>\n<li>python向C++注册pass，python中对模式和要替换的目标进行描述，C++中运行pass<ol>\n<li>优点：可以复用部分优化器部分的代码；执行效率较高</li>\n<li>缺点：python pass中的pattern、target与C++通信较复杂</li>\n</ol>\n</li>\n<li>C++向python暴露图接口，直接在python中完成改图<ol>\n<li>优点：对图修改的逻辑全部包含在python中</li>\n<li>缺点：效率较低，但此类任务通常较低频，性能要求不高</li>\n</ol>\n</li>\n</ol>\n<p>综合考虑，C++新增向python暴露图接口，直接在python中完成改图较合理。</p>\n"},{"title":"Bonfire","date":"2020-07-26T03:46:59.000Z","_content":"\n# Bonfire\n\nCannot move my eyes away from the bonfire\n\nIt was his will\n\nIt is a dance of life and death\n\nIt would be ashes of bodies\n\nIt is not an illusion as long as it burns\n\nBut I had stared at it for too long\n\nSo I lit my hand\n\nAnd walked into the dark\n\nAs my lights going dimmer and dimmer\n\nHow I wish it is a cool autumn\n\nI would just fall down on the ground\n\nAnd flare up the whole forest","source":"_posts/Bonfire.md","raw":"---\ntitle: Bonfire\ndate: 2020-07-26 11:46:59\ntags: Mood\n---\n\n# Bonfire\n\nCannot move my eyes away from the bonfire\n\nIt was his will\n\nIt is a dance of life and death\n\nIt would be ashes of bodies\n\nIt is not an illusion as long as it burns\n\nBut I had stared at it for too long\n\nSo I lit my hand\n\nAnd walked into the dark\n\nAs my lights going dimmer and dimmer\n\nHow I wish it is a cool autumn\n\nI would just fall down on the ground\n\nAnd flare up the whole forest","slug":"Bonfire","published":1,"updated":"2020-07-26T04:14:08.447Z","_id":"ckd2kgi660000c67975gd8ml8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Bonfire\"><a href=\"#Bonfire\" class=\"headerlink\" title=\"Bonfire\"></a>Bonfire</h1><p>Cannot move my eyes away from the bonfire</p>\n<p>It was his will</p>\n<p>It is a dance of life and death</p>\n<p>It would be ashes of bodies</p>\n<p>It is not an illusion as long as it burns</p>\n<p>But I had stared at it for too long</p>\n<p>So I lit my hand</p>\n<p>And walked into the dark</p>\n<p>As my lights going dimmer and dimmer</p>\n<p>How I wish it is a cool autumn</p>\n<p>I would just fall down on the ground</p>\n<p>And flare up the whole forest</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Bonfire\"><a href=\"#Bonfire\" class=\"headerlink\" title=\"Bonfire\"></a>Bonfire</h1><p>Cannot move my eyes away from the bonfire</p>\n<p>It was his will</p>\n<p>It is a dance of life and death</p>\n<p>It would be ashes of bodies</p>\n<p>It is not an illusion as long as it burns</p>\n<p>But I had stared at it for too long</p>\n<p>So I lit my hand</p>\n<p>And walked into the dark</p>\n<p>As my lights going dimmer and dimmer</p>\n<p>How I wish it is a cool autumn</p>\n<p>I would just fall down on the ground</p>\n<p>And flare up the whole forest</p>\n"},{"title":"Pybind11 Type Conversions","date":"2020-07-27T02:17:43.000Z","_content":"\n# Pybind11类型转换\n\nPybind11帮助我们方便的实现C++和Python之间的调用，无论是相互的接口暴露还是数据传递都要求我们正确的在C++和Python类型之间进行转换（[官方文档](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html)）。\n\n## 三种场景\n\n1. C++原生类型暴露给python\n2. Python原生类型暴露给C++\n3. C++和Python原生类型间相互转换\n\n## C++原生类型暴露给Python\n\n使用`py::class_`将自定义的C++类型暴露给Python（[参考这里](https://pybind11.readthedocs.io/en/stable/classes.html)）。C++类型传递给Python时会在原生C++类型外加一层wrapper，从Python取回时只用去掉wrapper即可。\n\n## Python原生类型暴露给C++\n\n在C++中取用Python的原生类型（例如：`tuple`、`list`），例如：\n\n```c++\n// C++中使用Python对象\nvoid print_list(py::list my_list) {\n  for (auto item : my_list) {\n    std::cout << item << \" \";\n  }\n}\n```\n\nPython中传入Python对象给C++:\n\n```python\n>>> print_list([1, 2, 3])\n1 2 3\n```\n\n这个例子里Python中的`list`类型没有进行任何转换，只是被封装进了C++的`py::list`类中。目前Pybind11支持以下类型([参考这里](https://pybind11.readthedocs.io/en/stable/advanced/pycpp))：`handle`, `object`, `bool_`, `int_`, `float_`, `str`, `bytes`, `tuple`, `list`, `dict`, `slice`, `none`, `capsule`, `iterable`, `iterator`, `function`, `buffer`, `array`, `array_t`。\n\n## C++和Python原生类型间相互转换\n\n有些场景C++和Python都用的是各自的原生类型，Pybind11支持常见C++原生类型和Python原生类型间的相互转换，例如：\n\n```c++\nvoid print_vector(const std::vector<int> &v) {\n  for (auto item : v) {\n    std::cout << item << \"\\n\";\n  }\n}\n```\n\nPython中调用：\n\n```\n>>> print_vector([1, 2, 3])\n1 2 3\n```\n\n容易注意到Python中传入的为`list`类型，而C++中处理的类型为`const std::vector<int> &`。Pybind11这种默认类型转换会在原生类型间拷贝数据，例如上面Python中的调用会首先将list中的数据拷贝到一个`std::vector<int>`中，然后进行C++中的调用。\n\nNOTE: 默认的拷贝可能开销很大，可以通过手写[opaque types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque)重载类型转换的wrapper来避免不必要的拷贝。opaque types还没有使用过，有机会单独挖坑写。\n\n## STL库\n\nPybind11默认（`pybind11/pybind11.h`）支持`std::pair<>`，`std::tuple<>`和`list`, `set`, `dict`之间的自动转换。引入`pybind11/stl.h`可以新增`std::vector<>`, `std::deque<>`, `std::list<>`, `std::array<>`, `std::set<>`, `std::unordered_set<>`, `std::map<>`和`std::unordered_map<>`的与Python的自动转换。\n\n### 绑定STL容器\n\n`pybind11/stl_bind.h`可以帮助我们将STL容器作为原生对象暴露出来。例如：\n\n```c++\n#include <pybind11/stl_bind.h>\n\nPYBIND11_MAKE_OPAQUE(std::vector<int>);\nPYBIND11_MAKE_OPAQUE(std::map<std::string, double>);\n\n// ...\n\n// 绑定\npy::bind_vector<std::vector<int>>(m, \"VectorInt\");\npy::bind_map<std::map<std::string, double>>(m, \"MapStringDouble\");\n// 或者同时设置绑定的作用域\npy::bind_vector<std::vector<int>>(m, \"VectorInt\", py::module_local(false));\n```\n\n\n\n","source":"_posts/Pybind11-Type-Conversions.md","raw":"---\ntitle: Pybind11 Type Conversions\ndate: 2020-07-27 10:17:43\ncategory: 编程\ntags: pybind11, c++, python\n---\n\n# Pybind11类型转换\n\nPybind11帮助我们方便的实现C++和Python之间的调用，无论是相互的接口暴露还是数据传递都要求我们正确的在C++和Python类型之间进行转换（[官方文档](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html)）。\n\n## 三种场景\n\n1. C++原生类型暴露给python\n2. Python原生类型暴露给C++\n3. C++和Python原生类型间相互转换\n\n## C++原生类型暴露给Python\n\n使用`py::class_`将自定义的C++类型暴露给Python（[参考这里](https://pybind11.readthedocs.io/en/stable/classes.html)）。C++类型传递给Python时会在原生C++类型外加一层wrapper，从Python取回时只用去掉wrapper即可。\n\n## Python原生类型暴露给C++\n\n在C++中取用Python的原生类型（例如：`tuple`、`list`），例如：\n\n```c++\n// C++中使用Python对象\nvoid print_list(py::list my_list) {\n  for (auto item : my_list) {\n    std::cout << item << \" \";\n  }\n}\n```\n\nPython中传入Python对象给C++:\n\n```python\n>>> print_list([1, 2, 3])\n1 2 3\n```\n\n这个例子里Python中的`list`类型没有进行任何转换，只是被封装进了C++的`py::list`类中。目前Pybind11支持以下类型([参考这里](https://pybind11.readthedocs.io/en/stable/advanced/pycpp))：`handle`, `object`, `bool_`, `int_`, `float_`, `str`, `bytes`, `tuple`, `list`, `dict`, `slice`, `none`, `capsule`, `iterable`, `iterator`, `function`, `buffer`, `array`, `array_t`。\n\n## C++和Python原生类型间相互转换\n\n有些场景C++和Python都用的是各自的原生类型，Pybind11支持常见C++原生类型和Python原生类型间的相互转换，例如：\n\n```c++\nvoid print_vector(const std::vector<int> &v) {\n  for (auto item : v) {\n    std::cout << item << \"\\n\";\n  }\n}\n```\n\nPython中调用：\n\n```\n>>> print_vector([1, 2, 3])\n1 2 3\n```\n\n容易注意到Python中传入的为`list`类型，而C++中处理的类型为`const std::vector<int> &`。Pybind11这种默认类型转换会在原生类型间拷贝数据，例如上面Python中的调用会首先将list中的数据拷贝到一个`std::vector<int>`中，然后进行C++中的调用。\n\nNOTE: 默认的拷贝可能开销很大，可以通过手写[opaque types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque)重载类型转换的wrapper来避免不必要的拷贝。opaque types还没有使用过，有机会单独挖坑写。\n\n## STL库\n\nPybind11默认（`pybind11/pybind11.h`）支持`std::pair<>`，`std::tuple<>`和`list`, `set`, `dict`之间的自动转换。引入`pybind11/stl.h`可以新增`std::vector<>`, `std::deque<>`, `std::list<>`, `std::array<>`, `std::set<>`, `std::unordered_set<>`, `std::map<>`和`std::unordered_map<>`的与Python的自动转换。\n\n### 绑定STL容器\n\n`pybind11/stl_bind.h`可以帮助我们将STL容器作为原生对象暴露出来。例如：\n\n```c++\n#include <pybind11/stl_bind.h>\n\nPYBIND11_MAKE_OPAQUE(std::vector<int>);\nPYBIND11_MAKE_OPAQUE(std::map<std::string, double>);\n\n// ...\n\n// 绑定\npy::bind_vector<std::vector<int>>(m, \"VectorInt\");\npy::bind_map<std::map<std::string, double>>(m, \"MapStringDouble\");\n// 或者同时设置绑定的作用域\npy::bind_vector<std::vector<int>>(m, \"VectorInt\", py::module_local(false));\n```\n\n\n\n","slug":"Pybind11-Type-Conversions","published":1,"updated":"2020-07-27T04:01:28.342Z","_id":"ckd3zdaqx00000d79hxtz43ip","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Pybind11类型转换\"><a href=\"#Pybind11类型转换\" class=\"headerlink\" title=\"Pybind11类型转换\"></a>Pybind11类型转换</h1><p>Pybind11帮助我们方便的实现C++和Python之间的调用，无论是相互的接口暴露还是数据传递都要求我们正确的在C++和Python类型之间进行转换（<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>）。</p>\n<h2 id=\"三种场景\"><a href=\"#三种场景\" class=\"headerlink\" title=\"三种场景\"></a>三种场景</h2><ol>\n<li>C++原生类型暴露给python</li>\n<li>Python原生类型暴露给C++</li>\n<li>C++和Python原生类型间相互转换</li>\n</ol>\n<h2 id=\"C-原生类型暴露给Python\"><a href=\"#C-原生类型暴露给Python\" class=\"headerlink\" title=\"C++原生类型暴露给Python\"></a>C++原生类型暴露给Python</h2><p>使用<code>py::class_</code>将自定义的C++类型暴露给Python（<a href=\"https://pybind11.readthedocs.io/en/stable/classes.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>）。C++类型传递给Python时会在原生C++类型外加一层wrapper，从Python取回时只用去掉wrapper即可。</p>\n<h2 id=\"Python原生类型暴露给C\"><a href=\"#Python原生类型暴露给C\" class=\"headerlink\" title=\"Python原生类型暴露给C++\"></a>Python原生类型暴露给C++</h2><p>在C++中取用Python的原生类型（例如：<code>tuple</code>、<code>list</code>），例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++中使用Python对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_list</span><span class=\"params\">(py::<span class=\"built_in\">list</span> my_list)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item : my_list) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; item &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python中传入Python对象给C++:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print_list([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>这个例子里Python中的<code>list</code>类型没有进行任何转换，只是被封装进了C++的<code>py::list</code>类中。目前Pybind11支持以下类型(<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/pycpp\" target=\"_blank\" rel=\"noopener\">参考这里</a>)：<code>handle</code>, <code>object</code>, <code>bool_</code>, <code>int_</code>, <code>float_</code>, <code>str</code>, <code>bytes</code>, <code>tuple</code>, <code>list</code>, <code>dict</code>, <code>slice</code>, <code>none</code>, <code>capsule</code>, <code>iterable</code>, <code>iterator</code>, <code>function</code>, <code>buffer</code>, <code>array</code>, <code>array_t</code>。</p>\n<h2 id=\"C-和Python原生类型间相互转换\"><a href=\"#C-和Python原生类型间相互转换\" class=\"headerlink\" title=\"C++和Python原生类型间相互转换\"></a>C++和Python原生类型间相互转换</h2><p>有些场景C++和Python都用的是各自的原生类型，Pybind11支持常见C++原生类型和Python原生类型间的相互转换，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_vector</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item : v) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; item &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python中调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; print_vector([1, 2, 3])</span><br><span class=\"line\">1 2 3</span><br></pre></td></tr></table></figure>\n<p>容易注意到Python中传入的为<code>list</code>类型，而C++中处理的类型为<code>const std::vector&lt;int&gt; &amp;</code>。Pybind11这种默认类型转换会在原生类型间拷贝数据，例如上面Python中的调用会首先将list中的数据拷贝到一个<code>std::vector&lt;int&gt;</code>中，然后进行C++中的调用。</p>\n<p>NOTE: 默认的拷贝可能开销很大，可以通过手写<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque\" target=\"_blank\" rel=\"noopener\">opaque types</a>重载类型转换的wrapper来避免不必要的拷贝。opaque types还没有使用过，有机会单独挖坑写。</p>\n<h2 id=\"STL库\"><a href=\"#STL库\" class=\"headerlink\" title=\"STL库\"></a>STL库</h2><p>Pybind11默认（<code>pybind11/pybind11.h</code>）支持<code>std::pair&lt;&gt;</code>，<code>std::tuple&lt;&gt;</code>和<code>list</code>, <code>set</code>, <code>dict</code>之间的自动转换。引入<code>pybind11/stl.h</code>可以新增<code>std::vector&lt;&gt;</code>, <code>std::deque&lt;&gt;</code>, <code>std::list&lt;&gt;</code>, <code>std::array&lt;&gt;</code>, <code>std::set&lt;&gt;</code>, <code>std::unordered_set&lt;&gt;</code>, <code>std::map&lt;&gt;</code>和<code>std::unordered_map&lt;&gt;</code>的与Python的自动转换。</p>\n<h3 id=\"绑定STL容器\"><a href=\"#绑定STL容器\" class=\"headerlink\" title=\"绑定STL容器\"></a>绑定STL容器</h3><p><code>pybind11/stl_bind.h</code>可以帮助我们将STL容器作为原生对象暴露出来。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/stl_bind.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MAKE_OPAQUE(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;);</span><br><span class=\"line\">PYBIND11_MAKE_OPAQUE(<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"keyword\">double</span>&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定</span></span><br><span class=\"line\">py::bind_vector&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;(m, <span class=\"string\">\"VectorInt\"</span>);</span><br><span class=\"line\">py::bind_map&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"keyword\">double</span>&gt;&gt;(m, <span class=\"string\">\"MapStringDouble\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或者同时设置绑定的作用域</span></span><br><span class=\"line\">py::bind_vector&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;(m, <span class=\"string\">\"VectorInt\"</span>, py::module_local(<span class=\"literal\">false</span>));</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pybind11类型转换\"><a href=\"#Pybind11类型转换\" class=\"headerlink\" title=\"Pybind11类型转换\"></a>Pybind11类型转换</h1><p>Pybind11帮助我们方便的实现C++和Python之间的调用，无论是相互的接口暴露还是数据传递都要求我们正确的在C++和Python类型之间进行转换（<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>）。</p>\n<h2 id=\"三种场景\"><a href=\"#三种场景\" class=\"headerlink\" title=\"三种场景\"></a>三种场景</h2><ol>\n<li>C++原生类型暴露给python</li>\n<li>Python原生类型暴露给C++</li>\n<li>C++和Python原生类型间相互转换</li>\n</ol>\n<h2 id=\"C-原生类型暴露给Python\"><a href=\"#C-原生类型暴露给Python\" class=\"headerlink\" title=\"C++原生类型暴露给Python\"></a>C++原生类型暴露给Python</h2><p>使用<code>py::class_</code>将自定义的C++类型暴露给Python（<a href=\"https://pybind11.readthedocs.io/en/stable/classes.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>）。C++类型传递给Python时会在原生C++类型外加一层wrapper，从Python取回时只用去掉wrapper即可。</p>\n<h2 id=\"Python原生类型暴露给C\"><a href=\"#Python原生类型暴露给C\" class=\"headerlink\" title=\"Python原生类型暴露给C++\"></a>Python原生类型暴露给C++</h2><p>在C++中取用Python的原生类型（例如：<code>tuple</code>、<code>list</code>），例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++中使用Python对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_list</span><span class=\"params\">(py::<span class=\"built_in\">list</span> my_list)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item : my_list) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; item &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python中传入Python对象给C++:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print_list([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>这个例子里Python中的<code>list</code>类型没有进行任何转换，只是被封装进了C++的<code>py::list</code>类中。目前Pybind11支持以下类型(<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/pycpp\" target=\"_blank\" rel=\"noopener\">参考这里</a>)：<code>handle</code>, <code>object</code>, <code>bool_</code>, <code>int_</code>, <code>float_</code>, <code>str</code>, <code>bytes</code>, <code>tuple</code>, <code>list</code>, <code>dict</code>, <code>slice</code>, <code>none</code>, <code>capsule</code>, <code>iterable</code>, <code>iterator</code>, <code>function</code>, <code>buffer</code>, <code>array</code>, <code>array_t</code>。</p>\n<h2 id=\"C-和Python原生类型间相互转换\"><a href=\"#C-和Python原生类型间相互转换\" class=\"headerlink\" title=\"C++和Python原生类型间相互转换\"></a>C++和Python原生类型间相互转换</h2><p>有些场景C++和Python都用的是各自的原生类型，Pybind11支持常见C++原生类型和Python原生类型间的相互转换，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_vector</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item : v) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; item &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python中调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; print_vector([1, 2, 3])</span><br><span class=\"line\">1 2 3</span><br></pre></td></tr></table></figure>\n<p>容易注意到Python中传入的为<code>list</code>类型，而C++中处理的类型为<code>const std::vector&lt;int&gt; &amp;</code>。Pybind11这种默认类型转换会在原生类型间拷贝数据，例如上面Python中的调用会首先将list中的数据拷贝到一个<code>std::vector&lt;int&gt;</code>中，然后进行C++中的调用。</p>\n<p>NOTE: 默认的拷贝可能开销很大，可以通过手写<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque\" target=\"_blank\" rel=\"noopener\">opaque types</a>重载类型转换的wrapper来避免不必要的拷贝。opaque types还没有使用过，有机会单独挖坑写。</p>\n<h2 id=\"STL库\"><a href=\"#STL库\" class=\"headerlink\" title=\"STL库\"></a>STL库</h2><p>Pybind11默认（<code>pybind11/pybind11.h</code>）支持<code>std::pair&lt;&gt;</code>，<code>std::tuple&lt;&gt;</code>和<code>list</code>, <code>set</code>, <code>dict</code>之间的自动转换。引入<code>pybind11/stl.h</code>可以新增<code>std::vector&lt;&gt;</code>, <code>std::deque&lt;&gt;</code>, <code>std::list&lt;&gt;</code>, <code>std::array&lt;&gt;</code>, <code>std::set&lt;&gt;</code>, <code>std::unordered_set&lt;&gt;</code>, <code>std::map&lt;&gt;</code>和<code>std::unordered_map&lt;&gt;</code>的与Python的自动转换。</p>\n<h3 id=\"绑定STL容器\"><a href=\"#绑定STL容器\" class=\"headerlink\" title=\"绑定STL容器\"></a>绑定STL容器</h3><p><code>pybind11/stl_bind.h</code>可以帮助我们将STL容器作为原生对象暴露出来。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/stl_bind.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MAKE_OPAQUE(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;);</span><br><span class=\"line\">PYBIND11_MAKE_OPAQUE(<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"keyword\">double</span>&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定</span></span><br><span class=\"line\">py::bind_vector&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;(m, <span class=\"string\">\"VectorInt\"</span>);</span><br><span class=\"line\">py::bind_map&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"keyword\">double</span>&gt;&gt;(m, <span class=\"string\">\"MapStringDouble\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或者同时设置绑定的作用域</span></span><br><span class=\"line\">py::bind_vector&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;(m, <span class=\"string\">\"VectorInt\"</span>, py::module_local(<span class=\"literal\">false</span>));</span><br></pre></td></tr></table></figure>\n"},{"title":"Pybind11 classes","date":"2020-07-27T06:10:51.000Z","_content":"\n# Pybind11 class绑定\n\n最近工作需要用到Pybind11 class绑定中一些较为高级的特性（虚函数、重载、继承），在此整理记录一下。\n\n## 基本用法\n\nclass绑定对应[上一篇](https://omnimilk.github.io/2020/07/27/Pybind11-Type-Conversions/)中的第一种场景，即将C++原生类型通过`class_`函数向Python暴露。下面用一个小例子展示class绑定最基本的用法：\n\n```c++\n#include <pybind11/pybind11.h>\nnamespace py = pybind11;\n\nstruct Pet {\n    Pet(const std::string &name) : name(name) { }\n    void setName(const std::string &name_) { name = name_; }\n    const std::string &getName() const { return name; }\n\n    std::string name;\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Pet>(m, \"Pet\")\n        .def(py::init<const std::string &>())\n        .def(\"setName\", &Pet::setName)\n        .def(\"getName\", &Pet::getName);\n}\n```\n\n上面的代码向Python暴露了`Pet`类，其中有三个方法：`__init__`, `setName`, `getName`。\n\n### 设置关键字参数和默认参数\n\n在def函数时可以添加参数的名字及设置默认值。\n\n```c++\n#include <pybind11/pybind11.h>\n\nint add(int i, int j) {\n  return i + j;\n}\n\nPYBIND11_MODULE(example, m) {\n  //m.def(\"add\", &add, \"A function which adds two numbers\");\n  // 变为关键字参数\n  m.def(\"add\", &add, \"A function which adds two numbers\", py::arg(\"i\"), py::arg(\"j\"));\n}\n// python调用：example.add(i=1,  j=2)\n```\n\n设置默认值类似（NOTE: C++接口中定义的默认值不会自动捕获，需要bind时设置）：\n\n```c++\nPYBIND11_MODULE(example, m) {\n  // 设置参数默认值\n  m.def(\"add\", &add, \"A function which adds two numbers\", py::arg(\"i\") = 1, py::arg(\"j\") = 2);\n}\n```\n\n### 绑定Lambda函数\n\n上面的方法绑定是将Python方法绑定到方法指针上，实际上可以用Lambda函数替换。例如，给Pet类增加一个`__repr__`方法：\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n    .def(py::init<const std::string &>())\n    .def(\"setName\", &Pet::setName)\n    .def(\"getName\", &Pet::getName)\n    .def(\"__repr__\",\n        [](const Pet &a) {\n            return \"<example.Pet named '\" + a.name + \"'>\";\n        }\n    );\n```\n\n### 绑定成员变量\n\nC++中公有成员变量可以绑定为Python中可以读写的attributes（const成员绑定为只读attributes），例如：\n\n```c++\nPYBIND11_MODULE(example, m) {\n    py::class_<Pet>(m, \"Pet\")\n        .def(py::init<const std::string &>())\n        .def(\"setName\", &Pet::setName)\n        .def(\"getName\", &Pet::getName)\n        .def_readwrite(\"name\", &Pet::name); //公有非const成员变量\n}\n// Python中调用：\n// >>> p = example.Pet(\"Molly\")\n// >>> p.name\n// >>> p.name = \"Charly\"\n```\n\n私有成员变量可以通过绑定C++中的getter和setter成为Python中的property：\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n  .def(py::init<const std::string &>())\n  .def_property(\"name\", &Pet::getName, &Pet::setName);\n  ...\n```\n\n类似的方法还有：`def_readwrite_static()`, `def_readonly_static()`, `def_property_static()`, `def_property_readonly_static()`\n\nNOTE: Python可以动态的添加属性，绑定时也可以使能C++暴露的类在Python中支持动态属性：\n\n```c++\n// py::dynamic_attr()支持动态属性\npy::class_<Pet>(m, \"Pet\", py::dynamic_attr())\n    .def(py::init<>())\n    .def_readwrite(\"name\", &Pet::name);\n\n// Python中动态向Pet添加属性\n// >>> p = example.Pet()\n// >>> p.name = \"charly\"\n// >>> p.age = 2 # 动态添加age属性\n```\n\n### 保持继承关系\n\nC++中的继承关系有两种方式保留到暴露到Python的类中，下面以一个例子说明。\n\n```c++\nstruct Pet {\n    Pet(const std::string &name) : name(name) { }\n    std::string name;\n};\n\nstruct Dog : Pet {\n    Dog(const std::string &name) : Pet(name) { }\n    std::string bark() const { return \"woof!\"; }\n};\n```\n\n第一种方法是子类暴露时在`class_`的模板中指定基类\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &>())\n   .def_readwrite(\"name\", &Pet::name);\n\n// Method 1: template parameter:\npy::class_<Dog, Pet /* <- specify C++ parent type */>(m, \"Dog\")\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n第二种方法是在子类暴露时在`class_`的参数中传入基类的`class_`闭包\n\n```c++\npy::class_<Pet> pet(m, \"Pet\");\npet.def(py::init<const std::string &>())\n   .def_readwrite(\"name\", &Pet::name);\n\n// Method 2: pass parent class_ object:\npy::class_<Dog>(m, \"Dog\", pet /* <- specify Python parent type */)\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n### 自动向下类型转换（downcasting）\n\n自动向下类型转换指的是**多态类型**的基类指针形式返回子类对象，此指针被自动识别并转换为子类的指针。需要注意的是，上面的`Pet`和`Dog`并不是多态类型，因为`Pet`中没有定义虚函数。\n\n下面以`Pet`和`Dog`为例展示**没有**自动downcasting时的行为：\n\n```c++\n// 返回指向子类对象的基类指针\nm.def(\"pet_store\", []() { return std::unique_ptr<Pet>(new Dog(\"Molly\")); });\n\n// 没有自动downcasting时的行为\n// >>> p = example.pet_stor()\n// >>> type(p)\nPet                                          # 没有被识别为Dog\n// p.bark()\nAttributeError: 'Pet' object has no attribute 'bark'\n```\n\n我们可以向`Pet`中添加一个虚函数来通知Pybind11这种多态关系：\n\n```c++\nstruct PolymorphicPet {\n    virtual ~PolymorphicPet() = default;\n};\n\nstruct PolymorphicDog : PolymorphicPet {\n    std::string bark() const { return \"woof!\"; }\n};\n\n// Same binding code\npy::class_<PolymorphicPet>(m, \"PolymorphicPet\");\npy::class_<PolymorphicDog, PolymorphicPet>(m, \"PolymorphicDog\")\n    .def(py::init<>())\n    .def(\"bark\", &PolymorphicDog::bark);\n\n// Again, return a base pointer to a derived instance\nm.def(\"pet_store2\", []() { return std::unique_ptr<PolymorphicPet>(new PolymorphicDog); });\n\n// Python中调用\n// >>> p = example.pet_store2()\n// >>> type(p)\n// PolymorphicDog  # automatically downcast\n// >>> p.bark()\n// u'woof!'\n```\n\n### 方法重载\n\nC++中重载的方法直接通过方法名取指针会有歧义，Pybind11有两种方法消除这种歧义。\n\n```c++\nstruct Pet {\n    Pet(const std::string &name, int age) : name(name), age(age) { }\n\n    void set(int age_) { age = age_; }\n    void set(const std::string &name_) { name = name_; }\n\n    std::string name;\n    int age;\n};\n\n// 方法1：指定方法指针类型，C++11+支持\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &, int>())\n   .def(\"set\", (void (Pet::*)(int)) &Pet::set, \"Set the pet's age\")\n   .def(\"set\", (void (Pet::*)(const std::string &)) &Pet::set, \"Set the pet's name\");\n// 方法2：py::overload_cast自动推导返回值类型， C++14+支持\npy::class_<Pet>(m, \"Pet\")\n    .def(\"set\", py::overload_cast<int>(&Pet::set), \"Set the pet's age\")\n    .def(\"set\", py::overload_cast<const std::string &>(&Pet::set), \"Set the pet's name\");\n```\n\n### 枚举类型\n\n```c++\nstruct Pet {\n    enum Kind {\n        Dog = 0,\n        Cat\n    };\n\n    Pet(const std::string &name, Kind type) : name(name), type(type) { }\n\n    std::string name;\n    Kind type;\n};\n\npy::class_<Pet> pet(m, \"Pet\");\n\npet.def(py::init<const std::string &, Pet::Kind>())\n    .def_readwrite(\"name\", &Pet::name)\n    .def_readwrite(\"type\", &Pet::type);\n\npy::enum_<Pet::Kind>(pet, \"Kind\")\n    .value(\"Dog\", Pet::Kind::Dog)\n    .value(\"Cat\", Pet::Kind::Cat)\n    .export_values();\n\n// Python 调用：\n// >>> p = Pet('Lucy', Pet.Cat)\n// >>> p.type\n// Kind.Cat\n// >>> int(p.type)\n// 1L\n```\n\n## 高级特性\n\n### 覆写虚函数\n\n直接以例子来说明：\n\n```c++\nclass Animal {\npublic:\n    virtual ~Animal() { }\n    // 纯虚函数， 有纯虚函数的类无法实例化， 因此无法定义构造函数\n    virtual std::string go(int n_times) = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += \"woof! \";\n        return result;\n    }\n};\n\n// 传入基类指针，调用实际对象的go方法\nstd::string call_go(Animal *animal) {\n    return animal->go(3);\n}\n\n// Bad binding! 无法扩展，因为此处Animal类没有构造函数\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal>(m, \"Animal\")\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n```\n\n我们可以在C++中新增一个跳转类来解决上述问题\n\n```c++\nclass PyAnimal : public Animal {\npublic:\n    /* Inherit the constructors */\n    using Animal::Animal;\n\n    /* Trampoline (need one for each virtual function) */\n    std::string go(int n_times) override {\n        /* 对纯虚函数使用此宏 */\n        /* 对有默认实现的虚函数，使用PYBIND11_OVERLOAD*/\n        PYBIND11_OVERLOAD_PURE(\n            std::string, /* Return type */\n            Animal,      /* Parent class */\n            go,          /* Name of function in C++ (must match Python name) */\n            n_times      /* Argument(s) */\n        );\n    }\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal, PyAnimal /* <--- trampoline*/>(m, \"Animal\")\n        .def(py::init<>())\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n/*\nPython中进行扩展和调用：\n>>> from example import *\n>>> d = Dog()\n>>> call_go(d)\nu'woof! woof! woof! '\n>>> class Cat(Animal):\n...     def go(self, n_times):\n...             return \"meow! \" * n_times\n...\n>>> class Dachshund(Dog):\n...        def __init__(self, name):\n...            Dog.__init__(self) # init c++ part\n...            self.name = name\n...        def bark(self):\n...            return \"yap!\"\n>>> c = Cat()\n>>> call_go(c)\nu'meow! meow! meow! '\n*/\n```\n\nNOTE: 用Python类扩展C++暴露出来的类时，不要使用`super()`, 不要使用`super()`, 不要使用`super()`! 应该直接使用对应类的`__init__`方法， 因为Python的方法解析顺序（MRO）和C++不一致。\n\n### 绑定虚函数和继承\n\n继续直接从例子开始\n\n```c++\nclass Animal {\npublic:\n    virtual std::string go(int n_times) = 0;\n    virtual std::string name() { return \"unknown\"; }\n};\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += bark() + \" \";\n        return result;\n    }\n    virtual std::string bark() { return \"woof!\"; }\n};\n\n// 定义两个跳转类， 覆写虚函数\nclass PyAnimal : public Animal {\npublic:\n    using Animal::Animal; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Animal, go, n_times); }\n    std::string name() override { PYBIND11_OVERLOAD(std::string, Animal, name, ); }\n};\nclass PyDog : public Dog {\npublic:\n    using Dog::Dog; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERLOAD(std::string, Dog, go, n_times); }\n    std::string name() override { PYBIND11_OVERLOAD(std::string, Dog, name, ); }\n    std::string bark() override { PYBIND11_OVERLOAD(std::string, Dog, bark, ); }\n};\n```\n\nNOTE: 上面通过pybind11注册过的类的子类都需要定义跳转类来覆写父类中的虚函数，当子类较多或者虚函数较多时，可以使用模板类来避免大量重复代码（参考[这里](https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance)）。\n\n### 绑定自定义构造函数\n\n使用`py::init<Args, ...>()`或者`py::init_alias<Args, ...>()`绑定构造函数较方便，但有时我们需要绑定自定义的方法作为构造函数（例如：工厂方法，单例获取静态方法）。\n\n下面的代码展示多种将C++方法绑定为Python构造函数的途径：\n\n```c++\nclass Example {\nprivate:\n    Example(int); // private constructor\npublic:\n    // Factory function - returned by value:\n    static Example create(int a) { return Example(a); }\n\n    // These constructors are publicly callable:\n    Example(double);\n    Example(int, int);\n    Example(std::string);\n};\n\npy::class_<Example>(m, \"Example\")\n    // Bind the factory function as a constructor:\n    .def(py::init(&Example::create))\n    // Bind a lambda function returning a pointer wrapped in a holder:\n    .def(py::init([](std::string arg) {\n        return std::unique_ptr<Example>(new Example(arg));\n    }))\n    // Return a raw pointer:\n    .def(py::init([](int a, int b) { return new Example(a, b); }))\n    // You can mix the above with regular C++ constructor bindings as well:\n    .def(py::init<double>())\n    ;\n```\n\n#### 有虚函数跳转类的构造函数\n\n两种方法：\n\n1. 以右值引用的方式将基类值传给子类构造函数\n2. 向`py::init<>`提供两个工厂函数，第一个在不需要子类时调（即暴露的类只在Python中被使用而没有被继承），第二个在需要子类时被调用\n\n两种方式的demo如下：\n\n```c++\n#include <pybind11/factory.h>\nclass Example {\npublic:\n    // ...\n    virtual ~Example() = default;\n};\nclass PyExample : public Example {\npublic:\n    using Example::Example;\n    // 第一种方式：跳转类以右值引用方式接收基类\n    PyExample(Example &&base) : Example(std::move(base)) {}\n};\npy::class_<Example, PyExample>(m, \"Example\")\n    // Returns an Example pointer.  If a PyExample is needed, the Example instance will be moved via the extra constructor in PyExample, above.\n    .def(py::init([]() { return new Example(); }))\n    // 第二种方式：提供两个工厂函数\n    .def(py::init([]() { return new Example(); } /* no alias needed */,\n                  []() { return new PyExample(); } /* alias needed */))\n    // *Always* returns an alias instance (like py::init_alias<>())\n    .def(py::init([]() { return new PyExample(); }))\n    ;\n```\n\n### 多重继承\n\n在`class_`的模板参数中指定所有的基类即可：\n\n```c++\npy::class_ <MyType, BaseType1, BaseType2, BaseType3>(m, \"MyType\")\n...\n```\n\n\n\n","source":"_posts/Pybind11-classes.md","raw":"---\ntitle: Pybind11 classes\ndate: 2020-07-27 14:10:51\ncategories: 编程\ntags: pybind11, c++, python\n---\n\n# Pybind11 class绑定\n\n最近工作需要用到Pybind11 class绑定中一些较为高级的特性（虚函数、重载、继承），在此整理记录一下。\n\n## 基本用法\n\nclass绑定对应[上一篇](https://omnimilk.github.io/2020/07/27/Pybind11-Type-Conversions/)中的第一种场景，即将C++原生类型通过`class_`函数向Python暴露。下面用一个小例子展示class绑定最基本的用法：\n\n```c++\n#include <pybind11/pybind11.h>\nnamespace py = pybind11;\n\nstruct Pet {\n    Pet(const std::string &name) : name(name) { }\n    void setName(const std::string &name_) { name = name_; }\n    const std::string &getName() const { return name; }\n\n    std::string name;\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Pet>(m, \"Pet\")\n        .def(py::init<const std::string &>())\n        .def(\"setName\", &Pet::setName)\n        .def(\"getName\", &Pet::getName);\n}\n```\n\n上面的代码向Python暴露了`Pet`类，其中有三个方法：`__init__`, `setName`, `getName`。\n\n### 设置关键字参数和默认参数\n\n在def函数时可以添加参数的名字及设置默认值。\n\n```c++\n#include <pybind11/pybind11.h>\n\nint add(int i, int j) {\n  return i + j;\n}\n\nPYBIND11_MODULE(example, m) {\n  //m.def(\"add\", &add, \"A function which adds two numbers\");\n  // 变为关键字参数\n  m.def(\"add\", &add, \"A function which adds two numbers\", py::arg(\"i\"), py::arg(\"j\"));\n}\n// python调用：example.add(i=1,  j=2)\n```\n\n设置默认值类似（NOTE: C++接口中定义的默认值不会自动捕获，需要bind时设置）：\n\n```c++\nPYBIND11_MODULE(example, m) {\n  // 设置参数默认值\n  m.def(\"add\", &add, \"A function which adds two numbers\", py::arg(\"i\") = 1, py::arg(\"j\") = 2);\n}\n```\n\n### 绑定Lambda函数\n\n上面的方法绑定是将Python方法绑定到方法指针上，实际上可以用Lambda函数替换。例如，给Pet类增加一个`__repr__`方法：\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n    .def(py::init<const std::string &>())\n    .def(\"setName\", &Pet::setName)\n    .def(\"getName\", &Pet::getName)\n    .def(\"__repr__\",\n        [](const Pet &a) {\n            return \"<example.Pet named '\" + a.name + \"'>\";\n        }\n    );\n```\n\n### 绑定成员变量\n\nC++中公有成员变量可以绑定为Python中可以读写的attributes（const成员绑定为只读attributes），例如：\n\n```c++\nPYBIND11_MODULE(example, m) {\n    py::class_<Pet>(m, \"Pet\")\n        .def(py::init<const std::string &>())\n        .def(\"setName\", &Pet::setName)\n        .def(\"getName\", &Pet::getName)\n        .def_readwrite(\"name\", &Pet::name); //公有非const成员变量\n}\n// Python中调用：\n// >>> p = example.Pet(\"Molly\")\n// >>> p.name\n// >>> p.name = \"Charly\"\n```\n\n私有成员变量可以通过绑定C++中的getter和setter成为Python中的property：\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n  .def(py::init<const std::string &>())\n  .def_property(\"name\", &Pet::getName, &Pet::setName);\n  ...\n```\n\n类似的方法还有：`def_readwrite_static()`, `def_readonly_static()`, `def_property_static()`, `def_property_readonly_static()`\n\nNOTE: Python可以动态的添加属性，绑定时也可以使能C++暴露的类在Python中支持动态属性：\n\n```c++\n// py::dynamic_attr()支持动态属性\npy::class_<Pet>(m, \"Pet\", py::dynamic_attr())\n    .def(py::init<>())\n    .def_readwrite(\"name\", &Pet::name);\n\n// Python中动态向Pet添加属性\n// >>> p = example.Pet()\n// >>> p.name = \"charly\"\n// >>> p.age = 2 # 动态添加age属性\n```\n\n### 保持继承关系\n\nC++中的继承关系有两种方式保留到暴露到Python的类中，下面以一个例子说明。\n\n```c++\nstruct Pet {\n    Pet(const std::string &name) : name(name) { }\n    std::string name;\n};\n\nstruct Dog : Pet {\n    Dog(const std::string &name) : Pet(name) { }\n    std::string bark() const { return \"woof!\"; }\n};\n```\n\n第一种方法是子类暴露时在`class_`的模板中指定基类\n\n```c++\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &>())\n   .def_readwrite(\"name\", &Pet::name);\n\n// Method 1: template parameter:\npy::class_<Dog, Pet /* <- specify C++ parent type */>(m, \"Dog\")\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n第二种方法是在子类暴露时在`class_`的参数中传入基类的`class_`闭包\n\n```c++\npy::class_<Pet> pet(m, \"Pet\");\npet.def(py::init<const std::string &>())\n   .def_readwrite(\"name\", &Pet::name);\n\n// Method 2: pass parent class_ object:\npy::class_<Dog>(m, \"Dog\", pet /* <- specify Python parent type */)\n    .def(py::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n### 自动向下类型转换（downcasting）\n\n自动向下类型转换指的是**多态类型**的基类指针形式返回子类对象，此指针被自动识别并转换为子类的指针。需要注意的是，上面的`Pet`和`Dog`并不是多态类型，因为`Pet`中没有定义虚函数。\n\n下面以`Pet`和`Dog`为例展示**没有**自动downcasting时的行为：\n\n```c++\n// 返回指向子类对象的基类指针\nm.def(\"pet_store\", []() { return std::unique_ptr<Pet>(new Dog(\"Molly\")); });\n\n// 没有自动downcasting时的行为\n// >>> p = example.pet_stor()\n// >>> type(p)\nPet                                          # 没有被识别为Dog\n// p.bark()\nAttributeError: 'Pet' object has no attribute 'bark'\n```\n\n我们可以向`Pet`中添加一个虚函数来通知Pybind11这种多态关系：\n\n```c++\nstruct PolymorphicPet {\n    virtual ~PolymorphicPet() = default;\n};\n\nstruct PolymorphicDog : PolymorphicPet {\n    std::string bark() const { return \"woof!\"; }\n};\n\n// Same binding code\npy::class_<PolymorphicPet>(m, \"PolymorphicPet\");\npy::class_<PolymorphicDog, PolymorphicPet>(m, \"PolymorphicDog\")\n    .def(py::init<>())\n    .def(\"bark\", &PolymorphicDog::bark);\n\n// Again, return a base pointer to a derived instance\nm.def(\"pet_store2\", []() { return std::unique_ptr<PolymorphicPet>(new PolymorphicDog); });\n\n// Python中调用\n// >>> p = example.pet_store2()\n// >>> type(p)\n// PolymorphicDog  # automatically downcast\n// >>> p.bark()\n// u'woof!'\n```\n\n### 方法重载\n\nC++中重载的方法直接通过方法名取指针会有歧义，Pybind11有两种方法消除这种歧义。\n\n```c++\nstruct Pet {\n    Pet(const std::string &name, int age) : name(name), age(age) { }\n\n    void set(int age_) { age = age_; }\n    void set(const std::string &name_) { name = name_; }\n\n    std::string name;\n    int age;\n};\n\n// 方法1：指定方法指针类型，C++11+支持\npy::class_<Pet>(m, \"Pet\")\n   .def(py::init<const std::string &, int>())\n   .def(\"set\", (void (Pet::*)(int)) &Pet::set, \"Set the pet's age\")\n   .def(\"set\", (void (Pet::*)(const std::string &)) &Pet::set, \"Set the pet's name\");\n// 方法2：py::overload_cast自动推导返回值类型， C++14+支持\npy::class_<Pet>(m, \"Pet\")\n    .def(\"set\", py::overload_cast<int>(&Pet::set), \"Set the pet's age\")\n    .def(\"set\", py::overload_cast<const std::string &>(&Pet::set), \"Set the pet's name\");\n```\n\n### 枚举类型\n\n```c++\nstruct Pet {\n    enum Kind {\n        Dog = 0,\n        Cat\n    };\n\n    Pet(const std::string &name, Kind type) : name(name), type(type) { }\n\n    std::string name;\n    Kind type;\n};\n\npy::class_<Pet> pet(m, \"Pet\");\n\npet.def(py::init<const std::string &, Pet::Kind>())\n    .def_readwrite(\"name\", &Pet::name)\n    .def_readwrite(\"type\", &Pet::type);\n\npy::enum_<Pet::Kind>(pet, \"Kind\")\n    .value(\"Dog\", Pet::Kind::Dog)\n    .value(\"Cat\", Pet::Kind::Cat)\n    .export_values();\n\n// Python 调用：\n// >>> p = Pet('Lucy', Pet.Cat)\n// >>> p.type\n// Kind.Cat\n// >>> int(p.type)\n// 1L\n```\n\n## 高级特性\n\n### 覆写虚函数\n\n直接以例子来说明：\n\n```c++\nclass Animal {\npublic:\n    virtual ~Animal() { }\n    // 纯虚函数， 有纯虚函数的类无法实例化， 因此无法定义构造函数\n    virtual std::string go(int n_times) = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += \"woof! \";\n        return result;\n    }\n};\n\n// 传入基类指针，调用实际对象的go方法\nstd::string call_go(Animal *animal) {\n    return animal->go(3);\n}\n\n// Bad binding! 无法扩展，因为此处Animal类没有构造函数\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal>(m, \"Animal\")\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n```\n\n我们可以在C++中新增一个跳转类来解决上述问题\n\n```c++\nclass PyAnimal : public Animal {\npublic:\n    /* Inherit the constructors */\n    using Animal::Animal;\n\n    /* Trampoline (need one for each virtual function) */\n    std::string go(int n_times) override {\n        /* 对纯虚函数使用此宏 */\n        /* 对有默认实现的虚函数，使用PYBIND11_OVERLOAD*/\n        PYBIND11_OVERLOAD_PURE(\n            std::string, /* Return type */\n            Animal,      /* Parent class */\n            go,          /* Name of function in C++ (must match Python name) */\n            n_times      /* Argument(s) */\n        );\n    }\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<Animal, PyAnimal /* <--- trampoline*/>(m, \"Animal\")\n        .def(py::init<>())\n        .def(\"go\", &Animal::go);\n\n    py::class_<Dog, Animal>(m, \"Dog\")\n        .def(py::init<>());\n\n    m.def(\"call_go\", &call_go);\n}\n/*\nPython中进行扩展和调用：\n>>> from example import *\n>>> d = Dog()\n>>> call_go(d)\nu'woof! woof! woof! '\n>>> class Cat(Animal):\n...     def go(self, n_times):\n...             return \"meow! \" * n_times\n...\n>>> class Dachshund(Dog):\n...        def __init__(self, name):\n...            Dog.__init__(self) # init c++ part\n...            self.name = name\n...        def bark(self):\n...            return \"yap!\"\n>>> c = Cat()\n>>> call_go(c)\nu'meow! meow! meow! '\n*/\n```\n\nNOTE: 用Python类扩展C++暴露出来的类时，不要使用`super()`, 不要使用`super()`, 不要使用`super()`! 应该直接使用对应类的`__init__`方法， 因为Python的方法解析顺序（MRO）和C++不一致。\n\n### 绑定虚函数和继承\n\n继续直接从例子开始\n\n```c++\nclass Animal {\npublic:\n    virtual std::string go(int n_times) = 0;\n    virtual std::string name() { return \"unknown\"; }\n};\nclass Dog : public Animal {\npublic:\n    std::string go(int n_times) override {\n        std::string result;\n        for (int i=0; i<n_times; ++i)\n            result += bark() + \" \";\n        return result;\n    }\n    virtual std::string bark() { return \"woof!\"; }\n};\n\n// 定义两个跳转类， 覆写虚函数\nclass PyAnimal : public Animal {\npublic:\n    using Animal::Animal; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Animal, go, n_times); }\n    std::string name() override { PYBIND11_OVERLOAD(std::string, Animal, name, ); }\n};\nclass PyDog : public Dog {\npublic:\n    using Dog::Dog; // Inherit constructors\n    std::string go(int n_times) override { PYBIND11_OVERLOAD(std::string, Dog, go, n_times); }\n    std::string name() override { PYBIND11_OVERLOAD(std::string, Dog, name, ); }\n    std::string bark() override { PYBIND11_OVERLOAD(std::string, Dog, bark, ); }\n};\n```\n\nNOTE: 上面通过pybind11注册过的类的子类都需要定义跳转类来覆写父类中的虚函数，当子类较多或者虚函数较多时，可以使用模板类来避免大量重复代码（参考[这里](https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance)）。\n\n### 绑定自定义构造函数\n\n使用`py::init<Args, ...>()`或者`py::init_alias<Args, ...>()`绑定构造函数较方便，但有时我们需要绑定自定义的方法作为构造函数（例如：工厂方法，单例获取静态方法）。\n\n下面的代码展示多种将C++方法绑定为Python构造函数的途径：\n\n```c++\nclass Example {\nprivate:\n    Example(int); // private constructor\npublic:\n    // Factory function - returned by value:\n    static Example create(int a) { return Example(a); }\n\n    // These constructors are publicly callable:\n    Example(double);\n    Example(int, int);\n    Example(std::string);\n};\n\npy::class_<Example>(m, \"Example\")\n    // Bind the factory function as a constructor:\n    .def(py::init(&Example::create))\n    // Bind a lambda function returning a pointer wrapped in a holder:\n    .def(py::init([](std::string arg) {\n        return std::unique_ptr<Example>(new Example(arg));\n    }))\n    // Return a raw pointer:\n    .def(py::init([](int a, int b) { return new Example(a, b); }))\n    // You can mix the above with regular C++ constructor bindings as well:\n    .def(py::init<double>())\n    ;\n```\n\n#### 有虚函数跳转类的构造函数\n\n两种方法：\n\n1. 以右值引用的方式将基类值传给子类构造函数\n2. 向`py::init<>`提供两个工厂函数，第一个在不需要子类时调（即暴露的类只在Python中被使用而没有被继承），第二个在需要子类时被调用\n\n两种方式的demo如下：\n\n```c++\n#include <pybind11/factory.h>\nclass Example {\npublic:\n    // ...\n    virtual ~Example() = default;\n};\nclass PyExample : public Example {\npublic:\n    using Example::Example;\n    // 第一种方式：跳转类以右值引用方式接收基类\n    PyExample(Example &&base) : Example(std::move(base)) {}\n};\npy::class_<Example, PyExample>(m, \"Example\")\n    // Returns an Example pointer.  If a PyExample is needed, the Example instance will be moved via the extra constructor in PyExample, above.\n    .def(py::init([]() { return new Example(); }))\n    // 第二种方式：提供两个工厂函数\n    .def(py::init([]() { return new Example(); } /* no alias needed */,\n                  []() { return new PyExample(); } /* alias needed */))\n    // *Always* returns an alias instance (like py::init_alias<>())\n    .def(py::init([]() { return new PyExample(); }))\n    ;\n```\n\n### 多重继承\n\n在`class_`的模板参数中指定所有的基类即可：\n\n```c++\npy::class_ <MyType, BaseType1, BaseType2, BaseType3>(m, \"MyType\")\n...\n```\n\n\n\n","slug":"Pybind11-classes","published":1,"updated":"2020-07-27T11:51:53.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd4gbd630000yz792p1w7hk5","content":"<h1 id=\"Pybind11-class绑定\"><a href=\"#Pybind11-class绑定\" class=\"headerlink\" title=\"Pybind11 class绑定\"></a>Pybind11 class绑定</h1><p>最近工作需要用到Pybind11 class绑定中一些较为高级的特性（虚函数、重载、继承），在此整理记录一下。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>class绑定对应<a href=\"https://omnimilk.github.io/2020/07/27/Pybind11-Type-Conversions/\" target=\"_blank\" rel=\"noopener\">上一篇</a>中的第一种场景，即将C++原生类型通过<code>class_</code>函数向Python暴露。下面用一个小例子展示class绑定最基本的用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> py = pybind11;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;<span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">        .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码向Python暴露了<code>Pet</code>类，其中有三个方法：<code>__init__</code>, <code>setName</code>, <code>getName</code>。</p>\n<h3 id=\"设置关键字参数和默认参数\"><a href=\"#设置关键字参数和默认参数\" class=\"headerlink\" title=\"设置关键字参数和默认参数\"></a>设置关键字参数和默认参数</h3><p>在def函数时可以添加参数的名字及设置默认值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//m.def(\"add\", &amp;add, \"A function which adds two numbers\");</span></span><br><span class=\"line\">  <span class=\"comment\">// 变为关键字参数</span></span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>, py::arg(<span class=\"string\">\"i\"</span>), py::arg(<span class=\"string\">\"j\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// python调用：example.add(i=1,  j=2)</span></span><br></pre></td></tr></table></figure>\n<p>设置默认值类似（NOTE: C++接口中定义的默认值不会自动捕获，需要bind时设置）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置参数默认值</span></span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>, py::arg(<span class=\"string\">\"i\"</span>) = <span class=\"number\">1</span>, py::arg(<span class=\"string\">\"j\"</span>) = <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定Lambda函数\"><a href=\"#绑定Lambda函数\" class=\"headerlink\" title=\"绑定Lambda函数\"></a>绑定Lambda函数</h3><p>上面的方法绑定是将Python方法绑定到方法指针上，实际上可以用Lambda函数替换。例如，给Pet类增加一个<code>__repr__</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">    .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName)</span><br><span class=\"line\">    .def(<span class=\"string\">\"__repr__\"</span>,</span><br><span class=\"line\">        [](<span class=\"keyword\">const</span> Pet &amp;a) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;example.Pet named '\"</span> + a.name + <span class=\"string\">\"'&gt;\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定成员变量\"><a href=\"#绑定成员变量\" class=\"headerlink\" title=\"绑定成员变量\"></a>绑定成员变量</h3><p>C++中公有成员变量可以绑定为Python中可以读写的attributes（const成员绑定为只读attributes），例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">        .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName)</span><br><span class=\"line\">        .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name); <span class=\"comment\">//公有非const成员变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Python中调用：</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.Pet(\"Molly\")</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name = \"Charly\"</span></span><br></pre></td></tr></table></figure>\n<p>私有成员变量可以通过绑定C++中的getter和setter成为Python中的property：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">  .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">  .def_property(<span class=\"string\">\"name\"</span>, &amp;Pet::getName, &amp;Pet::setName);</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>类似的方法还有：<code>def_readwrite_static()</code>, <code>def_readonly_static()</code>, <code>def_property_static()</code>, <code>def_property_readonly_static()</code></p>\n<p>NOTE: Python可以动态的添加属性，绑定时也可以使能C++暴露的类在Python中支持动态属性：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// py::dynamic_attr()支持动态属性</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>, py::dynamic_attr())</span><br><span class=\"line\">    .def(py::init&lt;&gt;())</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python中动态向Pet添加属性</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.Pet()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name = \"charly\"</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.age = 2 # 动态添加age属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"保持继承关系\"><a href=\"#保持继承关系\" class=\"headerlink\" title=\"保持继承关系\"></a>保持继承关系</h3><p>C++中的继承关系有两种方式保留到暴露到Python的类中，下面以一个例子说明。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dog</span> :</span> Pet &#123;</span><br><span class=\"line\">    Dog(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : Pet(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第一种方法是子类暴露时在<code>class_</code>的模板中指定基类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">   .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">   .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Method 1: template parameter:</span></span><br><span class=\"line\">py::class_&lt;Dog, Pet <span class=\"comment\">/* &lt;- specify C++ parent type */</span>&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure>\n<p>第二种方法是在子类暴露时在<code>class_</code>的参数中传入基类的<code>class_</code>闭包</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">py::class_&lt;Pet&gt; <span class=\"title\">pet</span><span class=\"params\">(m, <span class=\"string\">\"Pet\"</span>)</span></span>;</span><br><span class=\"line\">pet.def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">   .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Method 2: pass parent class_ object:</span></span><br><span class=\"line\">py::class_&lt;Dog&gt;(m, <span class=\"string\">\"Dog\"</span>, pet <span class=\"comment\">/* &lt;- specify Python parent type */</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动向下类型转换（downcasting）\"><a href=\"#自动向下类型转换（downcasting）\" class=\"headerlink\" title=\"自动向下类型转换（downcasting）\"></a>自动向下类型转换（downcasting）</h3><p>自动向下类型转换指的是<strong>多态类型</strong>的基类指针形式返回子类对象，此指针被自动识别并转换为子类的指针。需要注意的是，上面的<code>Pet</code>和<code>Dog</code>并不是多态类型，因为<code>Pet</code>中没有定义虚函数。</p>\n<p>下面以<code>Pet</code>和<code>Dog</code>为例展示<strong>没有</strong>自动downcasting时的行为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回指向子类对象的基类指针</span></span><br><span class=\"line\">m.def(<span class=\"string\">\"pet_store\"</span>, []() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Pet&gt;(<span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Molly\"</span>)); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有自动downcasting时的行为</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.pet_stor()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; type(p)</span></span><br><span class=\"line\">Pet                                          # 没有被识别为Dog</span><br><span class=\"line\"><span class=\"comment\">// p.bark()</span></span><br><span class=\"line\">AttributeError: 'Pet' object has no attribute 'bark'</span><br></pre></td></tr></table></figure>\n<p>我们可以向<code>Pet</code>中添加一个虚函数来通知Pybind11这种多态关系：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolymorphicPet</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~PolymorphicPet() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolymorphicDog</span> :</span> PolymorphicPet &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same binding code</span></span><br><span class=\"line\">py::class_&lt;PolymorphicPet&gt;(m, <span class=\"string\">\"PolymorphicPet\"</span>);</span><br><span class=\"line\">py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, <span class=\"string\">\"PolymorphicDog\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;PolymorphicDog::bark);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Again, return a base pointer to a derived instance</span></span><br><span class=\"line\">m.def(<span class=\"string\">\"pet_store2\"</span>, []() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;PolymorphicPet&gt;(<span class=\"keyword\">new</span> PolymorphicDog); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python中调用</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.pet_store2()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; type(p)</span></span><br><span class=\"line\"><span class=\"comment\">// PolymorphicDog  # automatically downcast</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.bark()</span></span><br><span class=\"line\"><span class=\"comment\">// u'woof!'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h3><p>C++中重载的方法直接通过方法名取指针会有歧义，Pybind11有两种方法消除这种歧义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">int</span> age) : name(name), age(age) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> age_)</span> </span>&#123; age = age_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1：指定方法指针类型，C++11+支持</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">   .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;, <span class=\"keyword\">int</span>&gt;())</span><br><span class=\"line\">   .def(<span class=\"string\">\"set\"</span>, (<span class=\"keyword\">void</span> (Pet::*)(<span class=\"keyword\">int</span>)) &amp;Pet::<span class=\"built_in\">set</span>, <span class=\"string\">\"Set the pet's age\"</span>)</span><br><span class=\"line\">   .def(<span class=\"string\">\"set\"</span>, (<span class=\"keyword\">void</span> (Pet::*)(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;)) &amp;Pet::<span class=\"built_in\">set</span>, <span class=\"string\">\"Set the pet's name\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 方法2：py::overload_cast自动推导返回值类型， C++14+支持</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">    .def(<span class=\"string\">\"set\"</span>, py::overload_cast&lt;<span class=\"keyword\">int</span>&gt;(&amp;Pet::<span class=\"built_in\">set</span>), <span class=\"string\">\"Set the pet's age\"</span>)</span><br><span class=\"line\">    .def(<span class=\"string\">\"set\"</span>, py::overload_cast&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;(&amp;Pet::<span class=\"built_in\">set</span>), <span class=\"string\">\"Set the pet's name\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> Kind &#123;</span><br><span class=\"line\">        Dog = <span class=\"number\">0</span>,</span><br><span class=\"line\">        Cat</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, Kind type) : name(name), type(type) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    Kind type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">py::class_&lt;Pet&gt; <span class=\"title\">pet</span><span class=\"params\">(m, <span class=\"string\">\"Pet\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">pet.def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;, Pet::Kind&gt;())</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name)</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"type\"</span>, &amp;Pet::type);</span><br><span class=\"line\"></span><br><span class=\"line\">py::enum_&lt;Pet::Kind&gt;(pet, <span class=\"string\">\"Kind\"</span>)</span><br><span class=\"line\">    .value(<span class=\"string\">\"Dog\"</span>, Pet::Kind::Dog)</span><br><span class=\"line\">    .value(<span class=\"string\">\"Cat\"</span>, Pet::Kind::Cat)</span><br><span class=\"line\">    .export_values();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python 调用：</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = Pet('Lucy', Pet.Cat)</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.type</span></span><br><span class=\"line\"><span class=\"comment\">// Kind.Cat</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; int(p.type)</span></span><br><span class=\"line\"><span class=\"comment\">// 1L</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h2><h3 id=\"覆写虚函数\"><a href=\"#覆写虚函数\" class=\"headerlink\" title=\"覆写虚函数\"></a>覆写虚函数</h3><p>直接以例子来说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Animal() &#123; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 纯虚函数， 有纯虚函数的类无法实例化， 因此无法定义构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n_times; ++i)</span><br><span class=\"line\">            result += <span class=\"string\">\"woof! \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入基类指针，调用实际对象的go方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">call_go</span><span class=\"params\">(Animal *animal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal-&gt;go(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad binding! 无法扩展，因为此处Animal类没有构造函数</span></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Animal&gt;(m, <span class=\"string\">\"Animal\"</span>)</span><br><span class=\"line\">        .def(<span class=\"string\">\"go\"</span>, &amp;Animal::go);</span><br><span class=\"line\"></span><br><span class=\"line\">    py::class_&lt;Dog, Animal&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    m.def(<span class=\"string\">\"call_go\"</span>, &amp;call_go);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以在C++中新增一个跳转类来解决上述问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyAnimal</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/* Inherit the constructors */</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Animal::Animal;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Trampoline (need one for each virtual function) */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 对纯虚函数使用此宏 */</span></span><br><span class=\"line\">        <span class=\"comment\">/* 对有默认实现的虚函数，使用PYBIND11_OVERLOAD*/</span></span><br><span class=\"line\">        PYBIND11_OVERLOAD_PURE(</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"comment\">/* Return type */</span></span><br><span class=\"line\">            Animal,      <span class=\"comment\">/* Parent class */</span></span><br><span class=\"line\">            go,          <span class=\"comment\">/* Name of function in C++ (must match Python name) */</span></span><br><span class=\"line\">            n_times      <span class=\"comment\">/* Argument(s) */</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Animal, PyAnimal <span class=\"comment\">/* &lt;--- trampoline*/</span>&gt;(m, <span class=\"string\">\"Animal\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"go\"</span>, &amp;Animal::go);</span><br><span class=\"line\"></span><br><span class=\"line\">    py::class_&lt;Dog, Animal&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    m.def(<span class=\"string\">\"call_go\"</span>, &amp;call_go);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Python中进行扩展和调用：</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; from example import *</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; d = Dog()</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; call_go(d)</span></span><br><span class=\"line\"><span class=\"comment\">u'woof! woof! woof! '</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; class Cat(Animal):</span></span><br><span class=\"line\"><span class=\"comment\">...     def go(self, n_times):</span></span><br><span class=\"line\"><span class=\"comment\">...             return \"meow! \" * n_times</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; class Dachshund(Dog):</span></span><br><span class=\"line\"><span class=\"comment\">...        def __init__(self, name):</span></span><br><span class=\"line\"><span class=\"comment\">...            Dog.__init__(self) # init c++ part</span></span><br><span class=\"line\"><span class=\"comment\">...            self.name = name</span></span><br><span class=\"line\"><span class=\"comment\">...        def bark(self):</span></span><br><span class=\"line\"><span class=\"comment\">...            return \"yap!\"</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; c = Cat()</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; call_go(c)</span></span><br><span class=\"line\"><span class=\"comment\">u'meow! meow! meow! '</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>NOTE: 用Python类扩展C++暴露出来的类时，不要使用<code>super()</code>, 不要使用<code>super()</code>, 不要使用<code>super()</code>! 应该直接使用对应类的<code>__init__</code>方法， 因为Python的方法解析顺序（MRO）和C++不一致。</p>\n<h3 id=\"绑定虚函数和继承\"><a href=\"#绑定虚函数和继承\" class=\"headerlink\" title=\"绑定虚函数和继承\"></a>绑定虚函数和继承</h3><p>继续直接从例子开始</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"unknown\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n_times; ++i)</span><br><span class=\"line\">            result += bark() + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义两个跳转类， 覆写虚函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyAnimal</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Animal::Animal; <span class=\"comment\">// Inherit constructors</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD_PURE(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Animal, go, n_times); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Animal, name, ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyDog</span> :</span> <span class=\"keyword\">public</span> Dog &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Dog::Dog; <span class=\"comment\">// Inherit constructors</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, go, n_times); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, name, ); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, bark, ); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>NOTE: 上面通过pybind11注册过的类的子类都需要定义跳转类来覆写父类中的虚函数，当子类较多或者虚函数较多时，可以使用模板类来避免大量重复代码（参考<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance\" target=\"_blank\" rel=\"noopener\">这里</a>）。</p>\n<h3 id=\"绑定自定义构造函数\"><a href=\"#绑定自定义构造函数\" class=\"headerlink\" title=\"绑定自定义构造函数\"></a>绑定自定义构造函数</h3><p>使用<code>py::init&lt;Args, ...&gt;()</code>或者<code>py::init_alias&lt;Args, ...&gt;()</code>绑定构造函数较方便，但有时我们需要绑定自定义的方法作为构造函数（例如：工厂方法，单例获取静态方法）。</p>\n<p>下面的代码展示多种将C++方法绑定为Python构造函数的途径：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Example(<span class=\"keyword\">int</span>); <span class=\"comment\">// private constructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Factory function - returned by value:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Example <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123; <span class=\"keyword\">return</span> Example(a); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These constructors are publicly callable:</span></span><br><span class=\"line\">    Example(<span class=\"keyword\">double</span>);</span><br><span class=\"line\">    Example(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">    Example(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">py::class_&lt;Example&gt;(m, <span class=\"string\">\"Example\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Bind the factory function as a constructor:</span></span><br><span class=\"line\">    .def(py::init(&amp;Example::create))</span><br><span class=\"line\">    <span class=\"comment\">// Bind a lambda function returning a pointer wrapped in a holder:</span></span><br><span class=\"line\">    .def(py::init([](<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> arg) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Example&gt;(<span class=\"keyword\">new</span> Example(arg));</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// Return a raw pointer:</span></span><br><span class=\"line\">    .def(py::init([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(a, b); &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// You can mix the above with regular C++ constructor bindings as well:</span></span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">double</span>&gt;())</span><br><span class=\"line\">    ;</span><br></pre></td></tr></table></figure>\n<h4 id=\"有虚函数跳转类的构造函数\"><a href=\"#有虚函数跳转类的构造函数\" class=\"headerlink\" title=\"有虚函数跳转类的构造函数\"></a>有虚函数跳转类的构造函数</h4><p>两种方法：</p>\n<ol>\n<li>以右值引用的方式将基类值传给子类构造函数</li>\n<li>向<code>py::init&lt;&gt;</code>提供两个工厂函数，第一个在不需要子类时调（即暴露的类只在Python中被使用而没有被继承），第二个在需要子类时被调用</li>\n</ol>\n<p>两种方式的demo如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/factory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyExample</span> :</span> <span class=\"keyword\">public</span> Example &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Example::Example;</span><br><span class=\"line\">    <span class=\"comment\">// 第一种方式：跳转类以右值引用方式接收基类</span></span><br><span class=\"line\">    PyExample(Example &amp;&amp;base) : Example(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(base)) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">py::class_&lt;Example, PyExample&gt;(m, <span class=\"string\">\"Example\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Returns an Example pointer.  If a PyExample is needed, the Example instance will be moved via the extra constructor in PyExample, above.</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(); &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// 第二种方式：提供两个工厂函数</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(); &#125; <span class=\"comment\">/* no alias needed */</span>,</span><br><span class=\"line\">                  []() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PyExample(); &#125; <span class=\"comment\">/* alias needed */</span>))</span><br><span class=\"line\">    <span class=\"comment\">// *Always* returns an alias instance (like py::init_alias&lt;&gt;())</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PyExample(); &#125;))</span><br><span class=\"line\">    ;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>在<code>class_</code>的模板参数中指定所有的基类即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_ &lt;MyType, BaseType1, BaseType2, BaseType3&gt;(m, <span class=\"string\">\"MyType\"</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pybind11-class绑定\"><a href=\"#Pybind11-class绑定\" class=\"headerlink\" title=\"Pybind11 class绑定\"></a>Pybind11 class绑定</h1><p>最近工作需要用到Pybind11 class绑定中一些较为高级的特性（虚函数、重载、继承），在此整理记录一下。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>class绑定对应<a href=\"https://omnimilk.github.io/2020/07/27/Pybind11-Type-Conversions/\" target=\"_blank\" rel=\"noopener\">上一篇</a>中的第一种场景，即将C++原生类型通过<code>class_</code>函数向Python暴露。下面用一个小例子展示class绑定最基本的用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> py = pybind11;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;<span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">        .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码向Python暴露了<code>Pet</code>类，其中有三个方法：<code>__init__</code>, <code>setName</code>, <code>getName</code>。</p>\n<h3 id=\"设置关键字参数和默认参数\"><a href=\"#设置关键字参数和默认参数\" class=\"headerlink\" title=\"设置关键字参数和默认参数\"></a>设置关键字参数和默认参数</h3><p>在def函数时可以添加参数的名字及设置默认值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//m.def(\"add\", &amp;add, \"A function which adds two numbers\");</span></span><br><span class=\"line\">  <span class=\"comment\">// 变为关键字参数</span></span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>, py::arg(<span class=\"string\">\"i\"</span>), py::arg(<span class=\"string\">\"j\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// python调用：example.add(i=1,  j=2)</span></span><br></pre></td></tr></table></figure>\n<p>设置默认值类似（NOTE: C++接口中定义的默认值不会自动捕获，需要bind时设置）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置参数默认值</span></span><br><span class=\"line\">  m.def(<span class=\"string\">\"add\"</span>, &amp;add, <span class=\"string\">\"A function which adds two numbers\"</span>, py::arg(<span class=\"string\">\"i\"</span>) = <span class=\"number\">1</span>, py::arg(<span class=\"string\">\"j\"</span>) = <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定Lambda函数\"><a href=\"#绑定Lambda函数\" class=\"headerlink\" title=\"绑定Lambda函数\"></a>绑定Lambda函数</h3><p>上面的方法绑定是将Python方法绑定到方法指针上，实际上可以用Lambda函数替换。例如，给Pet类增加一个<code>__repr__</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">    .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName)</span><br><span class=\"line\">    .def(<span class=\"string\">\"__repr__\"</span>,</span><br><span class=\"line\">        [](<span class=\"keyword\">const</span> Pet &amp;a) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;example.Pet named '\"</span> + a.name + <span class=\"string\">\"'&gt;\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定成员变量\"><a href=\"#绑定成员变量\" class=\"headerlink\" title=\"绑定成员变量\"></a>绑定成员变量</h3><p>C++中公有成员变量可以绑定为Python中可以读写的attributes（const成员绑定为只读attributes），例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"setName\"</span>, &amp;Pet::setName)</span><br><span class=\"line\">        .def(<span class=\"string\">\"getName\"</span>, &amp;Pet::getName)</span><br><span class=\"line\">        .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name); <span class=\"comment\">//公有非const成员变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Python中调用：</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.Pet(\"Molly\")</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name = \"Charly\"</span></span><br></pre></td></tr></table></figure>\n<p>私有成员变量可以通过绑定C++中的getter和setter成为Python中的property：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">  .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">  .def_property(<span class=\"string\">\"name\"</span>, &amp;Pet::getName, &amp;Pet::setName);</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>类似的方法还有：<code>def_readwrite_static()</code>, <code>def_readonly_static()</code>, <code>def_property_static()</code>, <code>def_property_readonly_static()</code></p>\n<p>NOTE: Python可以动态的添加属性，绑定时也可以使能C++暴露的类在Python中支持动态属性：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// py::dynamic_attr()支持动态属性</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>, py::dynamic_attr())</span><br><span class=\"line\">    .def(py::init&lt;&gt;())</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python中动态向Pet添加属性</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.Pet()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.name = \"charly\"</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.age = 2 # 动态添加age属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"保持继承关系\"><a href=\"#保持继承关系\" class=\"headerlink\" title=\"保持继承关系\"></a>保持继承关系</h3><p>C++中的继承关系有两种方式保留到暴露到Python的类中，下面以一个例子说明。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : name(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dog</span> :</span> Pet &#123;</span><br><span class=\"line\">    Dog(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name) : Pet(name) &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第一种方法是子类暴露时在<code>class_</code>的模板中指定基类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">   .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">   .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Method 1: template parameter:</span></span><br><span class=\"line\">py::class_&lt;Dog, Pet <span class=\"comment\">/* &lt;- specify C++ parent type */</span>&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure>\n<p>第二种方法是在子类暴露时在<code>class_</code>的参数中传入基类的<code>class_</code>闭包</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">py::class_&lt;Pet&gt; <span class=\"title\">pet</span><span class=\"params\">(m, <span class=\"string\">\"Pet\"</span>)</span></span>;</span><br><span class=\"line\">pet.def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">   .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Method 2: pass parent class_ object:</span></span><br><span class=\"line\">py::class_&lt;Dog&gt;(m, <span class=\"string\">\"Dog\"</span>, pet <span class=\"comment\">/* &lt;- specify Python parent type */</span>)</span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动向下类型转换（downcasting）\"><a href=\"#自动向下类型转换（downcasting）\" class=\"headerlink\" title=\"自动向下类型转换（downcasting）\"></a>自动向下类型转换（downcasting）</h3><p>自动向下类型转换指的是<strong>多态类型</strong>的基类指针形式返回子类对象，此指针被自动识别并转换为子类的指针。需要注意的是，上面的<code>Pet</code>和<code>Dog</code>并不是多态类型，因为<code>Pet</code>中没有定义虚函数。</p>\n<p>下面以<code>Pet</code>和<code>Dog</code>为例展示<strong>没有</strong>自动downcasting时的行为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回指向子类对象的基类指针</span></span><br><span class=\"line\">m.def(<span class=\"string\">\"pet_store\"</span>, []() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Pet&gt;(<span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Molly\"</span>)); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有自动downcasting时的行为</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.pet_stor()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; type(p)</span></span><br><span class=\"line\">Pet                                          # 没有被识别为Dog</span><br><span class=\"line\"><span class=\"comment\">// p.bark()</span></span><br><span class=\"line\">AttributeError: 'Pet' object has no attribute 'bark'</span><br></pre></td></tr></table></figure>\n<p>我们可以向<code>Pet</code>中添加一个虚函数来通知Pybind11这种多态关系：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolymorphicPet</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~PolymorphicPet() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolymorphicDog</span> :</span> PolymorphicPet &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same binding code</span></span><br><span class=\"line\">py::class_&lt;PolymorphicPet&gt;(m, <span class=\"string\">\"PolymorphicPet\"</span>);</span><br><span class=\"line\">py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, <span class=\"string\">\"PolymorphicDog\"</span>)</span><br><span class=\"line\">    .def(py::init&lt;&gt;())</span><br><span class=\"line\">    .def(<span class=\"string\">\"bark\"</span>, &amp;PolymorphicDog::bark);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Again, return a base pointer to a derived instance</span></span><br><span class=\"line\">m.def(<span class=\"string\">\"pet_store2\"</span>, []() &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;PolymorphicPet&gt;(<span class=\"keyword\">new</span> PolymorphicDog); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python中调用</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = example.pet_store2()</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; type(p)</span></span><br><span class=\"line\"><span class=\"comment\">// PolymorphicDog  # automatically downcast</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.bark()</span></span><br><span class=\"line\"><span class=\"comment\">// u'woof!'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h3><p>C++中重载的方法直接通过方法名取指针会有歧义，Pybind11有两种方法消除这种歧义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">int</span> age) : name(name), age(age) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> age_)</span> </span>&#123; age = age_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name_)</span> </span>&#123; name = name_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1：指定方法指针类型，C++11+支持</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">   .def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;, <span class=\"keyword\">int</span>&gt;())</span><br><span class=\"line\">   .def(<span class=\"string\">\"set\"</span>, (<span class=\"keyword\">void</span> (Pet::*)(<span class=\"keyword\">int</span>)) &amp;Pet::<span class=\"built_in\">set</span>, <span class=\"string\">\"Set the pet's age\"</span>)</span><br><span class=\"line\">   .def(<span class=\"string\">\"set\"</span>, (<span class=\"keyword\">void</span> (Pet::*)(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;)) &amp;Pet::<span class=\"built_in\">set</span>, <span class=\"string\">\"Set the pet's name\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 方法2：py::overload_cast自动推导返回值类型， C++14+支持</span></span><br><span class=\"line\">py::class_&lt;Pet&gt;(m, <span class=\"string\">\"Pet\"</span>)</span><br><span class=\"line\">    .def(<span class=\"string\">\"set\"</span>, py::overload_cast&lt;<span class=\"keyword\">int</span>&gt;(&amp;Pet::<span class=\"built_in\">set</span>), <span class=\"string\">\"Set the pet's age\"</span>)</span><br><span class=\"line\">    .def(<span class=\"string\">\"set\"</span>, py::overload_cast&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;&gt;(&amp;Pet::<span class=\"built_in\">set</span>), <span class=\"string\">\"Set the pet's name\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pet</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> Kind &#123;</span><br><span class=\"line\">        Dog = <span class=\"number\">0</span>,</span><br><span class=\"line\">        Cat</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pet(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, Kind type) : name(name), type(type) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    Kind type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">py::class_&lt;Pet&gt; <span class=\"title\">pet</span><span class=\"params\">(m, <span class=\"string\">\"Pet\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">pet.def(py::init&lt;<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;, Pet::Kind&gt;())</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"name\"</span>, &amp;Pet::name)</span><br><span class=\"line\">    .def_readwrite(<span class=\"string\">\"type\"</span>, &amp;Pet::type);</span><br><span class=\"line\"></span><br><span class=\"line\">py::enum_&lt;Pet::Kind&gt;(pet, <span class=\"string\">\"Kind\"</span>)</span><br><span class=\"line\">    .value(<span class=\"string\">\"Dog\"</span>, Pet::Kind::Dog)</span><br><span class=\"line\">    .value(<span class=\"string\">\"Cat\"</span>, Pet::Kind::Cat)</span><br><span class=\"line\">    .export_values();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Python 调用：</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p = Pet('Lucy', Pet.Cat)</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; p.type</span></span><br><span class=\"line\"><span class=\"comment\">// Kind.Cat</span></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt;&gt; int(p.type)</span></span><br><span class=\"line\"><span class=\"comment\">// 1L</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h2><h3 id=\"覆写虚函数\"><a href=\"#覆写虚函数\" class=\"headerlink\" title=\"覆写虚函数\"></a>覆写虚函数</h3><p>直接以例子来说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Animal() &#123; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 纯虚函数， 有纯虚函数的类无法实例化， 因此无法定义构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n_times; ++i)</span><br><span class=\"line\">            result += <span class=\"string\">\"woof! \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入基类指针，调用实际对象的go方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">call_go</span><span class=\"params\">(Animal *animal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal-&gt;go(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Bad binding! 无法扩展，因为此处Animal类没有构造函数</span></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Animal&gt;(m, <span class=\"string\">\"Animal\"</span>)</span><br><span class=\"line\">        .def(<span class=\"string\">\"go\"</span>, &amp;Animal::go);</span><br><span class=\"line\"></span><br><span class=\"line\">    py::class_&lt;Dog, Animal&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    m.def(<span class=\"string\">\"call_go\"</span>, &amp;call_go);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以在C++中新增一个跳转类来解决上述问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyAnimal</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/* Inherit the constructors */</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Animal::Animal;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Trampoline (need one for each virtual function) */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 对纯虚函数使用此宏 */</span></span><br><span class=\"line\">        <span class=\"comment\">/* 对有默认实现的虚函数，使用PYBIND11_OVERLOAD*/</span></span><br><span class=\"line\">        PYBIND11_OVERLOAD_PURE(</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"comment\">/* Return type */</span></span><br><span class=\"line\">            Animal,      <span class=\"comment\">/* Parent class */</span></span><br><span class=\"line\">            go,          <span class=\"comment\">/* Name of function in C++ (must match Python name) */</span></span><br><span class=\"line\">            n_times      <span class=\"comment\">/* Argument(s) */</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PYBIND11_MODULE(example, m) &#123;</span><br><span class=\"line\">    py::class_&lt;Animal, PyAnimal <span class=\"comment\">/* &lt;--- trampoline*/</span>&gt;(m, <span class=\"string\">\"Animal\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;())</span><br><span class=\"line\">        .def(<span class=\"string\">\"go\"</span>, &amp;Animal::go);</span><br><span class=\"line\"></span><br><span class=\"line\">    py::class_&lt;Dog, Animal&gt;(m, <span class=\"string\">\"Dog\"</span>)</span><br><span class=\"line\">        .def(py::init&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    m.def(<span class=\"string\">\"call_go\"</span>, &amp;call_go);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Python中进行扩展和调用：</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; from example import *</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; d = Dog()</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; call_go(d)</span></span><br><span class=\"line\"><span class=\"comment\">u'woof! woof! woof! '</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; class Cat(Animal):</span></span><br><span class=\"line\"><span class=\"comment\">...     def go(self, n_times):</span></span><br><span class=\"line\"><span class=\"comment\">...             return \"meow! \" * n_times</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; class Dachshund(Dog):</span></span><br><span class=\"line\"><span class=\"comment\">...        def __init__(self, name):</span></span><br><span class=\"line\"><span class=\"comment\">...            Dog.__init__(self) # init c++ part</span></span><br><span class=\"line\"><span class=\"comment\">...            self.name = name</span></span><br><span class=\"line\"><span class=\"comment\">...        def bark(self):</span></span><br><span class=\"line\"><span class=\"comment\">...            return \"yap!\"</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; c = Cat()</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;&gt; call_go(c)</span></span><br><span class=\"line\"><span class=\"comment\">u'meow! meow! meow! '</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>NOTE: 用Python类扩展C++暴露出来的类时，不要使用<code>super()</code>, 不要使用<code>super()</code>, 不要使用<code>super()</code>! 应该直接使用对应类的<code>__init__</code>方法， 因为Python的方法解析顺序（MRO）和C++不一致。</p>\n<h3 id=\"绑定虚函数和继承\"><a href=\"#绑定虚函数和继承\" class=\"headerlink\" title=\"绑定虚函数和继承\"></a>绑定虚函数和继承</h3><p>继续直接从例子开始</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"unknown\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n_times; ++i)</span><br><span class=\"line\">            result += bark() + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"woof!\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义两个跳转类， 覆写虚函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyAnimal</span> :</span> <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Animal::Animal; <span class=\"comment\">// Inherit constructors</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD_PURE(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Animal, go, n_times); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Animal, name, ); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyDog</span> :</span> <span class=\"keyword\">public</span> Dog &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Dog::Dog; <span class=\"comment\">// Inherit constructors</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> n_times)</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, go, n_times); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, name, ); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">bark</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; PYBIND11_OVERLOAD(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, Dog, bark, ); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>NOTE: 上面通过pybind11注册过的类的子类都需要定义跳转类来覆写父类中的虚函数，当子类较多或者虚函数较多时，可以使用模板类来避免大量重复代码（参考<a href=\"https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance\" target=\"_blank\" rel=\"noopener\">这里</a>）。</p>\n<h3 id=\"绑定自定义构造函数\"><a href=\"#绑定自定义构造函数\" class=\"headerlink\" title=\"绑定自定义构造函数\"></a>绑定自定义构造函数</h3><p>使用<code>py::init&lt;Args, ...&gt;()</code>或者<code>py::init_alias&lt;Args, ...&gt;()</code>绑定构造函数较方便，但有时我们需要绑定自定义的方法作为构造函数（例如：工厂方法，单例获取静态方法）。</p>\n<p>下面的代码展示多种将C++方法绑定为Python构造函数的途径：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Example(<span class=\"keyword\">int</span>); <span class=\"comment\">// private constructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Factory function - returned by value:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Example <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123; <span class=\"keyword\">return</span> Example(a); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These constructors are publicly callable:</span></span><br><span class=\"line\">    Example(<span class=\"keyword\">double</span>);</span><br><span class=\"line\">    Example(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">    Example(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">py::class_&lt;Example&gt;(m, <span class=\"string\">\"Example\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Bind the factory function as a constructor:</span></span><br><span class=\"line\">    .def(py::init(&amp;Example::create))</span><br><span class=\"line\">    <span class=\"comment\">// Bind a lambda function returning a pointer wrapped in a holder:</span></span><br><span class=\"line\">    .def(py::init([](<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> arg) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Example&gt;(<span class=\"keyword\">new</span> Example(arg));</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// Return a raw pointer:</span></span><br><span class=\"line\">    .def(py::init([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(a, b); &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// You can mix the above with regular C++ constructor bindings as well:</span></span><br><span class=\"line\">    .def(py::init&lt;<span class=\"keyword\">double</span>&gt;())</span><br><span class=\"line\">    ;</span><br></pre></td></tr></table></figure>\n<h4 id=\"有虚函数跳转类的构造函数\"><a href=\"#有虚函数跳转类的构造函数\" class=\"headerlink\" title=\"有虚函数跳转类的构造函数\"></a>有虚函数跳转类的构造函数</h4><p>两种方法：</p>\n<ol>\n<li>以右值引用的方式将基类值传给子类构造函数</li>\n<li>向<code>py::init&lt;&gt;</code>提供两个工厂函数，第一个在不需要子类时调（即暴露的类只在Python中被使用而没有被继承），第二个在需要子类时被调用</li>\n</ol>\n<p>两种方式的demo如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pybind11/factory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PyExample</span> :</span> <span class=\"keyword\">public</span> Example &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Example::Example;</span><br><span class=\"line\">    <span class=\"comment\">// 第一种方式：跳转类以右值引用方式接收基类</span></span><br><span class=\"line\">    PyExample(Example &amp;&amp;base) : Example(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(base)) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">py::class_&lt;Example, PyExample&gt;(m, <span class=\"string\">\"Example\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Returns an Example pointer.  If a PyExample is needed, the Example instance will be moved via the extra constructor in PyExample, above.</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(); &#125;))</span><br><span class=\"line\">    <span class=\"comment\">// 第二种方式：提供两个工厂函数</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Example(); &#125; <span class=\"comment\">/* no alias needed */</span>,</span><br><span class=\"line\">                  []() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PyExample(); &#125; <span class=\"comment\">/* alias needed */</span>))</span><br><span class=\"line\">    <span class=\"comment\">// *Always* returns an alias instance (like py::init_alias&lt;&gt;())</span></span><br><span class=\"line\">    .def(py::init([]() &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PyExample(); &#125;))</span><br><span class=\"line\">    ;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>在<code>class_</code>的模板参数中指定所有的基类即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">py::class_ &lt;MyType, BaseType1, BaseType2, BaseType3&gt;(m, <span class=\"string\">\"MyType\"</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n"},{"layout":"posts","title":"Python_Pass","date":"2020-08-09T07:00:53.000Z","_content":"\n# Mindspore Python Pass\n\nMindspore的Python Pass特性简单来说就是使能在Python中编写优化器中的pass。现在这一特性的开发将告一段落，简单记录一下。\n\n## PRs\n\n1. [基本功能](https://gitee.com/mindspore/mindspore/pulls/2478)\n\n2. [Python UT支持&用例](https://gitee.com/mindspore/mindspore/pulls/2963)\n3. [新Pattern表达方式](https://gitee.com/mindspore/mindspore/pulls/3715)\n4. [添加Parameter支持](https://gitee.com/mindspore/mindspore/pulls/4126)","source":"_posts/Python-Pass.md","raw":"---\nlayout: posts\ntitle: Python_Pass\ndate: 2020-08-09 15:00:53\ntags: Mindspore, Python, Optimizer, C++\n---\n\n# Mindspore Python Pass\n\nMindspore的Python Pass特性简单来说就是使能在Python中编写优化器中的pass。现在这一特性的开发将告一段落，简单记录一下。\n\n## PRs\n\n1. [基本功能](https://gitee.com/mindspore/mindspore/pulls/2478)\n\n2. [Python UT支持&用例](https://gitee.com/mindspore/mindspore/pulls/2963)\n3. [新Pattern表达方式](https://gitee.com/mindspore/mindspore/pulls/3715)\n4. [添加Parameter支持](https://gitee.com/mindspore/mindspore/pulls/4126)","slug":"Python-Pass","published":1,"updated":"2020-08-14T02:52:05.678Z","comments":1,"photos":[],"link":"","_id":"ckdtmyesc00003a79f8it7f7l","content":"<h1 id=\"Mindspore-Python-Pass\"><a href=\"#Mindspore-Python-Pass\" class=\"headerlink\" title=\"Mindspore Python Pass\"></a>Mindspore Python Pass</h1><p>Mindspore的Python Pass特性简单来说就是使能在Python中编写优化器中的pass。现在这一特性的开发将告一段落，简单记录一下。</p>\n<h2 id=\"PRs\"><a href=\"#PRs\" class=\"headerlink\" title=\"PRs\"></a>PRs</h2><ol>\n<li><p><a href=\"https://gitee.com/mindspore/mindspore/pulls/2478\" target=\"_blank\" rel=\"noopener\">基本功能</a></p>\n</li>\n<li><p><a href=\"https://gitee.com/mindspore/mindspore/pulls/2963\" target=\"_blank\" rel=\"noopener\">Python UT支持&amp;用例</a></p>\n</li>\n<li><a href=\"https://gitee.com/mindspore/mindspore/pulls/3715\" target=\"_blank\" rel=\"noopener\">新Pattern表达方式</a></li>\n<li><a href=\"https://gitee.com/mindspore/mindspore/pulls/4126\" target=\"_blank\" rel=\"noopener\">添加Parameter支持</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mindspore-Python-Pass\"><a href=\"#Mindspore-Python-Pass\" class=\"headerlink\" title=\"Mindspore Python Pass\"></a>Mindspore Python Pass</h1><p>Mindspore的Python Pass特性简单来说就是使能在Python中编写优化器中的pass。现在这一特性的开发将告一段落，简单记录一下。</p>\n<h2 id=\"PRs\"><a href=\"#PRs\" class=\"headerlink\" title=\"PRs\"></a>PRs</h2><ol>\n<li><p><a href=\"https://gitee.com/mindspore/mindspore/pulls/2478\" target=\"_blank\" rel=\"noopener\">基本功能</a></p>\n</li>\n<li><p><a href=\"https://gitee.com/mindspore/mindspore/pulls/2963\" target=\"_blank\" rel=\"noopener\">Python UT支持&amp;用例</a></p>\n</li>\n<li><a href=\"https://gitee.com/mindspore/mindspore/pulls/3715\" target=\"_blank\" rel=\"noopener\">新Pattern表达方式</a></li>\n<li><a href=\"https://gitee.com/mindspore/mindspore/pulls/4126\" target=\"_blank\" rel=\"noopener\">添加Parameter支持</a></li>\n</ol>\n"},{"layout":"posts","title":"C++ Performance Trick: OutOfLine Pattern","date":"2020-08-14T02:54:58.000Z","_content":"\n# OutOfLine模式提升C++代码访存局部性\n\n公司内网看到一个提升C++代码性能的模式（源头是[这篇blog](https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/)），能够以一种容易维护的方式很大程度提升访存的局部性，感觉挺有意思，记录一下。\n\n## 从例子说起\n\n假设你的系统需要打开大量的路径(文件、sockets，pipes)，对于这些路径你需要打开、处理、关闭对应的文件描述符并取消文件描述符和对应路径之间的联系。\n\n对于这样的需求，我们可能写出下面的代码：\n\n```c++\nclass UnlinkingFD {\n  std::string path;\n public:\n  int fd;\n\n  UnlinkingFD(const std::string& p) : path(p) {\n    fd = open(p.c_str(), O_RDWR, 0);\n  }\n  ~UnlinkingFD() {\n      close(fd); \n      unlink(path.c_str());\n  }\n  UnlinkingFD(const UnlinkingFD&) = delete;\n};\n```\n\n每个打开的路径对应一个上面的对象保存对应的路径和文件描述符，大量的打开的文件描述符可能以`UnlinkingFD`对象形式保存在数组中。上面的代码在功能和逻辑上是完好的，RAII也会在对象生命周期结束时关掉文件描述符并取消和对应路径之间的关联。\n\n### 场景&性能分析\n\n假设我们经常需要用到`fd`，但是`path`只在对象生命周期结束时使用。因为一个上面的`UnlinkingFD`对象需要占用40Bytes，而我们常用的`fd`只占用了其中的4Bytes，这意味着我们在访问`UnlinkingFD`数组时cache miss的概率大大提升。\n\n### 方案1\n\n将`array-of-structs`变为`struct-of-arrays`，这当然可以帮助提升性能，但是我们将无法使用RAII来帮我们做资源管理，单一的fd无法及时得到释放。\n\n### 方案2\n\n`UnlinkingFD`对象中不直接保存`string`对象，而是使用一个`unique_ptr`指针。这样一个`UnlinkingFD`对象就从40Bytes降低到了16Bytes，降低了cache miss的概率。\n\n### 方案3：OutOfLine模式\n\nOutOfLine模式可以帮我们将像`path`这样的冷数据完全移到对象之外，但是仍然保留RAII为我们管理资源。\n\n#### OutOfLine用法\n\n`OutOfLine`类是一个[静态多态](https://omnimilk.github.io/2020/07/01/expression-template/)的基类。 使用此基类时要传入两个模板参数，第一个模板参数为继承的子类，第二个模板参数为要挂在“热”对象上的冷数据的类型。\n\n例如，对于上面的`UnlinkingFD`类，改写后的用法如下：\n\n```c++\nstruct UnlinkingFD : private OutOfLine<UnlinkingFD, std::string> {\n  int fd;\n\n  UnlinkingFD(const std::string& p) : OutOfLine<UnlinkingFD, std::string>(p) {\n    fd = open(p.c_str(), O_RDWR, 0);\n  }\n  ~UnlinkingFD();\n  UnlinkingFD(const UnlinkingFD&) = delete;\n};\n```\n\n#### 原理\n\nOutOfLine模式将冷数据从对象中剥离出去的思路时通过一个全局对象将“热”对象的指针和冷数据关联起来。\n\n```c++\ntemplate <class FastData, class ColdData>\nclass OutOfLine {\ninline static std::map<OutOfLine const*, std::unique_ptr<ColdData>> global_map_;\n public:\n    // 每次创建“热”数据对象时，将热数据对象的指针关联到对应的冷数据上\n    template<class... TArgs>\n    explicit OutOfLine(TArgs&&.. args) {\n        global_map_[this] = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n    }\n    // “热”数据对象析构时，将全局映射中对应的冷数据对象也清理掉\n    ~OutOfLine() {global_map_.erase(this);}\n    // move “热”数据对象时，将对应的冷数据重新关联（此后不应该在通过旧的“热”数据对象来找冷数据）\n    explicit OutOfLine(OutOfLine&& other) { *this = other;}\n    OutOfLine& operator=(OutOfLine&& other) {\n        global_map_[this] = std::move(global_map_[&other]);\n        return *this;\n    }\n    // non-copyable for simplicity\n    OutOfLine(OutOfLine const&) = delete;\n    OutOfLine& operator=(OutOfLine const&) = delete;\n    // 获取当前“热”对象对应的冷数据\n    ColdData& cold() noexcept { return *global_map_[this]; }\n    ColdData const& cold() const noexcept { return *global_map_[this]; }\n}\n```\n\n#### 性能&资源管理\n\n静态继承自`OutOfLine`类的`UnlinkingFD`现在只有4Bytes， 因此需要高频访问的`UnlinkingFD`对象的数组的cache miss被降到最低。同时RAII会同时替我们管理“热”数据对象及对应的冷数据。\n\n#### NOTE: 构造函数初始化顺序\n\n上面静态继承的过程实际上一定程度上限定了热数据和冷数据构造的顺序，因为C++构造函数初始化的顺序如下：\n\n1. 构造虚拟基类，继承自多个虚拟基类时，按照被继承的顺序构造\n2. 构造非虚拟基类，继承自多个非虚拟基类时，按照被继承的顺序构造\n3. 构造成员对象，按照成员对象的声明顺序构造\n4. 调用类自身的构造函数\n\n因此，当我们构造一个“热”数据对象时，会首先构造`OutOfLine`基类（此时`OutOfLine`类的构造函数中会构造冷数据对象），然后构造“热”数据对象。这就意味着***冷数据对象的构造不能依赖于“热”数据对象***。\n\n#### 控制初始化顺序\n\n当冷数据对象的初始化依赖于热数据对象时，我们需要hack一下初始化的顺序。方法如下：为`OutOfLine`静态基类提供一个特别的构造函数，这个构造函数以tag类`TwoPhaseInit`为入参。当我们调用这个构造函数时，冷数据不会被初始化，此时处于一种半构造的状态。然后我们在“热”数据初始化之后显式的调用`init_cold_data`来初始化冷数据。释放时同理可以引入`release_cold_data`来hack析构的顺序。代码如下：\n\n```c++\nstruct TwoPhaseInit {};\n  OutOfLine(TwoPhaseInit){}\n  template <class... TArgs>\n  void init_cold_data(TArgs&&... args) {\n    global_map_.find(this)->second = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n  }\n  void release_cold_data() { global_map_[this].reset(); }\n```\n\n### 性能测试\n\n#### `OutOfLine`代码\n\n```c++\n#pragma once\n#include <map>\n#include <memory>\n\ntemplate <class FastData, class ColdData>\nclass OutOfLine {\n  inline static std::map<OutOfLine const*, std::unique_ptr<ColdData>> global_map_;\n public:\n  template <class... TArgs>\n  OutOfLine(TArgs&&... args) : OutOfLine(TwoPhaseInit()) {\n    init_cold_data(std::forward<TArgs>(args)...);\n  }\n  ~OutOfLine() { global_map_.erase(this); }\n  explicit OutOfLine(OutOfLine&& other) : OutOfLine(OutOfLine::TwoPhaseInit()) { (*this) = std::move(other); }\n  OutOfLine& operator=(OutOfLine&& other) {\n    global_map_[this] = std::move(global_map_[&other]);\n    return *this;\n  }\n  OutOfLine(OutOfLine const&) = delete;\n  OutOfLine& operator=(OutOfLine const&) = delete;\n\n  ColdData& cold() noexcept { return *global_map_[this]; }\n  ColdData const& cold() const noexcept { return *global_map_[this]; }\n\n  struct TwoPhaseInit {};\n  OutOfLine(TwoPhaseInit) { global_map_.try_emplace(this); }\n  template <class... TArgs>\n  void init_cold_data(TArgs&&... args) {\n    global_map_.find(this)->second = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n  }\n\n  void release_cold_data() { global_map_[this].reset(); }\n};\n```\n\n#### benchmark代码\n\n```c++\n// g++ --std=c++1z -Wall -Wextra -O3 -o ool_benchmark ool_benchmark.cpp\n#include \"out_of_line.h\"\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n\n// Deomonstrates keeping the cold data in the object with the fast data\nstruct Together {\n  std::uint32_t value;\n  std::string metadata;\n};\n\n// Demonstrates \"giving up\" and just not storing the associated cold-data\nstruct OnlyFastData {\n  std::uint32_t value;\n};\n\n// Demonstrates using OutOfLine to store the cold data\nstruct WithOOL : public OutOfLine<WithOOL, std::string> {\n  std::uint32_t value;\n};\n\n// The crux of the optimization is that there's no space-overhead\nstatic_assert(sizeof(WithOOL) == sizeof(OnlyFastData));\n\n// We synthesize the data up-front so the generation can't interfere with the measured behavior in any way\ntemplate <class Data>\nauto make_data() {\n  srand(20180101);\n  std::vector<Data> data(10000000);\n  for (Data& d : data) { d.value = rand(); }\n  return data;\n}\n\n// We time to measure throughput of touching all the fast data once in sequence\ntemplate <class Data>\nvoid trial(const char* const name, const Data& data, const bool print) {\n  std::uint32_t running = 0U;\n  const auto before = std::chrono::system_clock::now();\n  for (const auto& d : data) { running += d.value; }\n  const auto after = std::chrono::system_clock::now();\n\n  if (print) {\n    std::cout << name << \" took \" << (after - before).count() << \"ns and \" << running\n              << \" is a value I don't want optimized away\" << std::endl;\n  }\n}\n\nint main() {\n  // We generate all the datasets up front, to keep the effects of the allocator distant\n  const auto together  = make_data<Together>();\n  const auto only_fast = make_data<OnlyFastData>();\n  const auto with_ool  = make_data<WithOOL>();\n\n  // We run each trial twice, recording the results only the second time. The idea is to give a fair comparison, where\n  // all 3 options have their caches primed and nobody thus has data fresher from the allocation.\n  trial(\"With cold data in-line (original)               \", together, false);\n  trial(\"With cold data in-line (original)               \", together, true);\n\n  trial(\"With cold data thrown away (best-case scenario) \", only_fast, false);\n  trial(\"With cold data thrown away (best-case scenario) \", only_fast, true);\n\n  trial(\"With OutOfLIne                                  \", with_ool, false);\n  trial(\"With OutOfLIne                                  \", with_ool, true);\nreturn 0;\n}\n```\n\n#### 结果\n\n注意map的`try_emplace`方法是C++17引入的新特性，编译命令如下：`g++ benchmark.cpp -o benchmark -std=c++17`。在我自己的笔记本上运行的结果如下：\n\n```\nWith cold data in-line (original)                took 82936589ns and 3350498669 is a value I don't want optimized away\nWith cold data thrown away (best-case scenario)  took 74243139ns and 3350498669 is a value I don't want optimized away\nWith OutOfLIne                                   took 73445932ns and 3350498669 is a value I don't want optimized away\n```\n\n加速效果没有原始博客中的那么大，但付出的成本近乎免费，因此在性能优化时是很值得考虑的一个选项。\n\n\n\n","source":"_posts/C-Performance-Trick-OutOfLine-Pattern.md","raw":"---\nlayout: posts\ntitle: 'C++ Performance Trick: OutOfLine Pattern'\ndate: 2020-08-14 10:54:58\ntags: Performance, C++\n---\n\n# OutOfLine模式提升C++代码访存局部性\n\n公司内网看到一个提升C++代码性能的模式（源头是[这篇blog](https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/)），能够以一种容易维护的方式很大程度提升访存的局部性，感觉挺有意思，记录一下。\n\n## 从例子说起\n\n假设你的系统需要打开大量的路径(文件、sockets，pipes)，对于这些路径你需要打开、处理、关闭对应的文件描述符并取消文件描述符和对应路径之间的联系。\n\n对于这样的需求，我们可能写出下面的代码：\n\n```c++\nclass UnlinkingFD {\n  std::string path;\n public:\n  int fd;\n\n  UnlinkingFD(const std::string& p) : path(p) {\n    fd = open(p.c_str(), O_RDWR, 0);\n  }\n  ~UnlinkingFD() {\n      close(fd); \n      unlink(path.c_str());\n  }\n  UnlinkingFD(const UnlinkingFD&) = delete;\n};\n```\n\n每个打开的路径对应一个上面的对象保存对应的路径和文件描述符，大量的打开的文件描述符可能以`UnlinkingFD`对象形式保存在数组中。上面的代码在功能和逻辑上是完好的，RAII也会在对象生命周期结束时关掉文件描述符并取消和对应路径之间的关联。\n\n### 场景&性能分析\n\n假设我们经常需要用到`fd`，但是`path`只在对象生命周期结束时使用。因为一个上面的`UnlinkingFD`对象需要占用40Bytes，而我们常用的`fd`只占用了其中的4Bytes，这意味着我们在访问`UnlinkingFD`数组时cache miss的概率大大提升。\n\n### 方案1\n\n将`array-of-structs`变为`struct-of-arrays`，这当然可以帮助提升性能，但是我们将无法使用RAII来帮我们做资源管理，单一的fd无法及时得到释放。\n\n### 方案2\n\n`UnlinkingFD`对象中不直接保存`string`对象，而是使用一个`unique_ptr`指针。这样一个`UnlinkingFD`对象就从40Bytes降低到了16Bytes，降低了cache miss的概率。\n\n### 方案3：OutOfLine模式\n\nOutOfLine模式可以帮我们将像`path`这样的冷数据完全移到对象之外，但是仍然保留RAII为我们管理资源。\n\n#### OutOfLine用法\n\n`OutOfLine`类是一个[静态多态](https://omnimilk.github.io/2020/07/01/expression-template/)的基类。 使用此基类时要传入两个模板参数，第一个模板参数为继承的子类，第二个模板参数为要挂在“热”对象上的冷数据的类型。\n\n例如，对于上面的`UnlinkingFD`类，改写后的用法如下：\n\n```c++\nstruct UnlinkingFD : private OutOfLine<UnlinkingFD, std::string> {\n  int fd;\n\n  UnlinkingFD(const std::string& p) : OutOfLine<UnlinkingFD, std::string>(p) {\n    fd = open(p.c_str(), O_RDWR, 0);\n  }\n  ~UnlinkingFD();\n  UnlinkingFD(const UnlinkingFD&) = delete;\n};\n```\n\n#### 原理\n\nOutOfLine模式将冷数据从对象中剥离出去的思路时通过一个全局对象将“热”对象的指针和冷数据关联起来。\n\n```c++\ntemplate <class FastData, class ColdData>\nclass OutOfLine {\ninline static std::map<OutOfLine const*, std::unique_ptr<ColdData>> global_map_;\n public:\n    // 每次创建“热”数据对象时，将热数据对象的指针关联到对应的冷数据上\n    template<class... TArgs>\n    explicit OutOfLine(TArgs&&.. args) {\n        global_map_[this] = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n    }\n    // “热”数据对象析构时，将全局映射中对应的冷数据对象也清理掉\n    ~OutOfLine() {global_map_.erase(this);}\n    // move “热”数据对象时，将对应的冷数据重新关联（此后不应该在通过旧的“热”数据对象来找冷数据）\n    explicit OutOfLine(OutOfLine&& other) { *this = other;}\n    OutOfLine& operator=(OutOfLine&& other) {\n        global_map_[this] = std::move(global_map_[&other]);\n        return *this;\n    }\n    // non-copyable for simplicity\n    OutOfLine(OutOfLine const&) = delete;\n    OutOfLine& operator=(OutOfLine const&) = delete;\n    // 获取当前“热”对象对应的冷数据\n    ColdData& cold() noexcept { return *global_map_[this]; }\n    ColdData const& cold() const noexcept { return *global_map_[this]; }\n}\n```\n\n#### 性能&资源管理\n\n静态继承自`OutOfLine`类的`UnlinkingFD`现在只有4Bytes， 因此需要高频访问的`UnlinkingFD`对象的数组的cache miss被降到最低。同时RAII会同时替我们管理“热”数据对象及对应的冷数据。\n\n#### NOTE: 构造函数初始化顺序\n\n上面静态继承的过程实际上一定程度上限定了热数据和冷数据构造的顺序，因为C++构造函数初始化的顺序如下：\n\n1. 构造虚拟基类，继承自多个虚拟基类时，按照被继承的顺序构造\n2. 构造非虚拟基类，继承自多个非虚拟基类时，按照被继承的顺序构造\n3. 构造成员对象，按照成员对象的声明顺序构造\n4. 调用类自身的构造函数\n\n因此，当我们构造一个“热”数据对象时，会首先构造`OutOfLine`基类（此时`OutOfLine`类的构造函数中会构造冷数据对象），然后构造“热”数据对象。这就意味着***冷数据对象的构造不能依赖于“热”数据对象***。\n\n#### 控制初始化顺序\n\n当冷数据对象的初始化依赖于热数据对象时，我们需要hack一下初始化的顺序。方法如下：为`OutOfLine`静态基类提供一个特别的构造函数，这个构造函数以tag类`TwoPhaseInit`为入参。当我们调用这个构造函数时，冷数据不会被初始化，此时处于一种半构造的状态。然后我们在“热”数据初始化之后显式的调用`init_cold_data`来初始化冷数据。释放时同理可以引入`release_cold_data`来hack析构的顺序。代码如下：\n\n```c++\nstruct TwoPhaseInit {};\n  OutOfLine(TwoPhaseInit){}\n  template <class... TArgs>\n  void init_cold_data(TArgs&&... args) {\n    global_map_.find(this)->second = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n  }\n  void release_cold_data() { global_map_[this].reset(); }\n```\n\n### 性能测试\n\n#### `OutOfLine`代码\n\n```c++\n#pragma once\n#include <map>\n#include <memory>\n\ntemplate <class FastData, class ColdData>\nclass OutOfLine {\n  inline static std::map<OutOfLine const*, std::unique_ptr<ColdData>> global_map_;\n public:\n  template <class... TArgs>\n  OutOfLine(TArgs&&... args) : OutOfLine(TwoPhaseInit()) {\n    init_cold_data(std::forward<TArgs>(args)...);\n  }\n  ~OutOfLine() { global_map_.erase(this); }\n  explicit OutOfLine(OutOfLine&& other) : OutOfLine(OutOfLine::TwoPhaseInit()) { (*this) = std::move(other); }\n  OutOfLine& operator=(OutOfLine&& other) {\n    global_map_[this] = std::move(global_map_[&other]);\n    return *this;\n  }\n  OutOfLine(OutOfLine const&) = delete;\n  OutOfLine& operator=(OutOfLine const&) = delete;\n\n  ColdData& cold() noexcept { return *global_map_[this]; }\n  ColdData const& cold() const noexcept { return *global_map_[this]; }\n\n  struct TwoPhaseInit {};\n  OutOfLine(TwoPhaseInit) { global_map_.try_emplace(this); }\n  template <class... TArgs>\n  void init_cold_data(TArgs&&... args) {\n    global_map_.find(this)->second = std::make_unique<ColdData>(std::forward<TArgs>(args)...);\n  }\n\n  void release_cold_data() { global_map_[this].reset(); }\n};\n```\n\n#### benchmark代码\n\n```c++\n// g++ --std=c++1z -Wall -Wextra -O3 -o ool_benchmark ool_benchmark.cpp\n#include \"out_of_line.h\"\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n\n// Deomonstrates keeping the cold data in the object with the fast data\nstruct Together {\n  std::uint32_t value;\n  std::string metadata;\n};\n\n// Demonstrates \"giving up\" and just not storing the associated cold-data\nstruct OnlyFastData {\n  std::uint32_t value;\n};\n\n// Demonstrates using OutOfLine to store the cold data\nstruct WithOOL : public OutOfLine<WithOOL, std::string> {\n  std::uint32_t value;\n};\n\n// The crux of the optimization is that there's no space-overhead\nstatic_assert(sizeof(WithOOL) == sizeof(OnlyFastData));\n\n// We synthesize the data up-front so the generation can't interfere with the measured behavior in any way\ntemplate <class Data>\nauto make_data() {\n  srand(20180101);\n  std::vector<Data> data(10000000);\n  for (Data& d : data) { d.value = rand(); }\n  return data;\n}\n\n// We time to measure throughput of touching all the fast data once in sequence\ntemplate <class Data>\nvoid trial(const char* const name, const Data& data, const bool print) {\n  std::uint32_t running = 0U;\n  const auto before = std::chrono::system_clock::now();\n  for (const auto& d : data) { running += d.value; }\n  const auto after = std::chrono::system_clock::now();\n\n  if (print) {\n    std::cout << name << \" took \" << (after - before).count() << \"ns and \" << running\n              << \" is a value I don't want optimized away\" << std::endl;\n  }\n}\n\nint main() {\n  // We generate all the datasets up front, to keep the effects of the allocator distant\n  const auto together  = make_data<Together>();\n  const auto only_fast = make_data<OnlyFastData>();\n  const auto with_ool  = make_data<WithOOL>();\n\n  // We run each trial twice, recording the results only the second time. The idea is to give a fair comparison, where\n  // all 3 options have their caches primed and nobody thus has data fresher from the allocation.\n  trial(\"With cold data in-line (original)               \", together, false);\n  trial(\"With cold data in-line (original)               \", together, true);\n\n  trial(\"With cold data thrown away (best-case scenario) \", only_fast, false);\n  trial(\"With cold data thrown away (best-case scenario) \", only_fast, true);\n\n  trial(\"With OutOfLIne                                  \", with_ool, false);\n  trial(\"With OutOfLIne                                  \", with_ool, true);\nreturn 0;\n}\n```\n\n#### 结果\n\n注意map的`try_emplace`方法是C++17引入的新特性，编译命令如下：`g++ benchmark.cpp -o benchmark -std=c++17`。在我自己的笔记本上运行的结果如下：\n\n```\nWith cold data in-line (original)                took 82936589ns and 3350498669 is a value I don't want optimized away\nWith cold data thrown away (best-case scenario)  took 74243139ns and 3350498669 is a value I don't want optimized away\nWith OutOfLIne                                   took 73445932ns and 3350498669 is a value I don't want optimized away\n```\n\n加速效果没有原始博客中的那么大，但付出的成本近乎免费，因此在性能优化时是很值得考虑的一个选项。\n\n\n\n","slug":"C-Performance-Trick-OutOfLine-Pattern","published":1,"updated":"2020-08-23T12:08:21.480Z","comments":1,"photos":[],"link":"","_id":"cke71smb80000eq79clr7hvia","content":"<h1 id=\"OutOfLine模式提升C-代码访存局部性\"><a href=\"#OutOfLine模式提升C-代码访存局部性\" class=\"headerlink\" title=\"OutOfLine模式提升C++代码访存局部性\"></a>OutOfLine模式提升C++代码访存局部性</h1><p>公司内网看到一个提升C++代码性能的模式（源头是<a href=\"https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/\" target=\"_blank\" rel=\"noopener\">这篇blog</a>），能够以一种容易维护的方式很大程度提升访存的局部性，感觉挺有意思，记录一下。</p>\n<h2 id=\"从例子说起\"><a href=\"#从例子说起\" class=\"headerlink\" title=\"从例子说起\"></a>从例子说起</h2><p>假设你的系统需要打开大量的路径(文件、sockets，pipes)，对于这些路径你需要打开、处理、关闭对应的文件描述符并取消文件描述符和对应路径之间的联系。</p>\n<p>对于这样的需求，我们可能写出下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnlinkingFD</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> path;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\"></span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; p) : path(p) &#123;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(p.c_str(), O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~UnlinkingFD() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">close</span>(fd); </span><br><span class=\"line\">      unlink(path.c_str());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> UnlinkingFD&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个打开的路径对应一个上面的对象保存对应的路径和文件描述符，大量的打开的文件描述符可能以<code>UnlinkingFD</code>对象形式保存在数组中。上面的代码在功能和逻辑上是完好的，RAII也会在对象生命周期结束时关掉文件描述符并取消和对应路径之间的关联。</p>\n<h3 id=\"场景-amp-性能分析\"><a href=\"#场景-amp-性能分析\" class=\"headerlink\" title=\"场景&amp;性能分析\"></a>场景&amp;性能分析</h3><p>假设我们经常需要用到<code>fd</code>，但是<code>path</code>只在对象生命周期结束时使用。因为一个上面的<code>UnlinkingFD</code>对象需要占用40Bytes，而我们常用的<code>fd</code>只占用了其中的4Bytes，这意味着我们在访问<code>UnlinkingFD</code>数组时cache miss的概率大大提升。</p>\n<h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>将<code>array-of-structs</code>变为<code>struct-of-arrays</code>，这当然可以帮助提升性能，但是我们将无法使用RAII来帮我们做资源管理，单一的fd无法及时得到释放。</p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p><code>UnlinkingFD</code>对象中不直接保存<code>string</code>对象，而是使用一个<code>unique_ptr</code>指针。这样一个<code>UnlinkingFD</code>对象就从40Bytes降低到了16Bytes，降低了cache miss的概率。</p>\n<h3 id=\"方案3：OutOfLine模式\"><a href=\"#方案3：OutOfLine模式\" class=\"headerlink\" title=\"方案3：OutOfLine模式\"></a>方案3：OutOfLine模式</h3><p>OutOfLine模式可以帮我们将像<code>path</code>这样的冷数据完全移到对象之外，但是仍然保留RAII为我们管理资源。</p>\n<h4 id=\"OutOfLine用法\"><a href=\"#OutOfLine用法\" class=\"headerlink\" title=\"OutOfLine用法\"></a>OutOfLine用法</h4><p><code>OutOfLine</code>类是一个<a href=\"https://omnimilk.github.io/2020/07/01/expression-template/\" target=\"_blank\" rel=\"noopener\">静态多态</a>的基类。 使用此基类时要传入两个模板参数，第一个模板参数为继承的子类，第二个模板参数为要挂在“热”对象上的冷数据的类型。</p>\n<p>例如，对于上面的<code>UnlinkingFD</code>类，改写后的用法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UnlinkingFD</span> :</span> <span class=\"keyword\">private</span> OutOfLine&lt;UnlinkingFD, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\"></span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;(p) &#123;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(p.c_str(), O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~UnlinkingFD();</span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> UnlinkingFD&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>OutOfLine模式将冷数据从对象中剥离出去的思路时通过一个全局对象将“热”对象的指针和冷数据关联起来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastData</span>, <span class=\"title\">class</span> <span class=\"title\">ColdData</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">OutOfLine</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;OutOfLine <span class=\"keyword\">const</span>*, <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 每次创建“热”数据对象时，将热数据对象的指针关联到对应的冷数据上</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">explicit</span> <span class=\"title\">OutOfLine</span>(<span class=\"title\">TArgs</span>&amp;&amp;.. <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">        global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// “热”数据对象析构时，将全局映射中对应的冷数据对象也清理掉</span></span><br><span class=\"line\">    ~OutOfLine() &#123;global_map_.erase(<span class=\"keyword\">this</span>);&#125;</span><br><span class=\"line\">    <span class=\"comment\">// move “热”数据对象时，将对应的冷数据重新关联（此后不应该在通过旧的“热”数据对象来找冷数据）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine&amp;&amp; other)</span> </span>&#123; *<span class=\"keyword\">this</span> = other;&#125;</span><br><span class=\"line\">    OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class=\"line\">        global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(global_map_[&amp;other]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// non-copyable for simplicity</span></span><br><span class=\"line\">    OutOfLine(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前“热”对象对应的冷数据</span></span><br><span class=\"line\">    <span class=\"function\">ColdData&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">    <span class=\"function\">ColdData <span class=\"keyword\">const</span>&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"性能-amp-资源管理\"><a href=\"#性能-amp-资源管理\" class=\"headerlink\" title=\"性能&amp;资源管理\"></a>性能&amp;资源管理</h4><p>静态继承自<code>OutOfLine</code>类的<code>UnlinkingFD</code>现在只有4Bytes， 因此需要高频访问的<code>UnlinkingFD</code>对象的数组的cache miss被降到最低。同时RAII会同时替我们管理“热”数据对象及对应的冷数据。</p>\n<h4 id=\"NOTE-构造函数初始化顺序\"><a href=\"#NOTE-构造函数初始化顺序\" class=\"headerlink\" title=\"NOTE: 构造函数初始化顺序\"></a>NOTE: 构造函数初始化顺序</h4><p>上面静态继承的过程实际上一定程度上限定了热数据和冷数据构造的顺序，因为C++构造函数初始化的顺序如下：</p>\n<ol>\n<li>构造虚拟基类，继承自多个虚拟基类时，按照被继承的顺序构造</li>\n<li>构造非虚拟基类，继承自多个非虚拟基类时，按照被继承的顺序构造</li>\n<li>构造成员对象，按照成员对象的声明顺序构造</li>\n<li>调用类自身的构造函数</li>\n</ol>\n<p>因此，当我们构造一个“热”数据对象时，会首先构造<code>OutOfLine</code>基类（此时<code>OutOfLine</code>类的构造函数中会构造冷数据对象），然后构造“热”数据对象。这就意味着<strong><em>冷数据对象的构造不能依赖于“热”数据对象</em></strong>。</p>\n<h4 id=\"控制初始化顺序\"><a href=\"#控制初始化顺序\" class=\"headerlink\" title=\"控制初始化顺序\"></a>控制初始化顺序</h4><p>当冷数据对象的初始化依赖于热数据对象时，我们需要hack一下初始化的顺序。方法如下：为<code>OutOfLine</code>静态基类提供一个特别的构造函数，这个构造函数以tag类<code>TwoPhaseInit</code>为入参。当我们调用这个构造函数时，冷数据不会被初始化，此时处于一种半构造的状态。然后我们在“热”数据初始化之后显式的调用<code>init_cold_data</code>来初始化冷数据。释放时同理可以引入<code>release_cold_data</code>来hack析构的顺序。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class=\"line\">  OutOfLine(TwoPhaseInit)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">init_cold_data</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">    global_map_.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>)-&gt;second = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_cold_data</span><span class=\"params\">()</span> </span>&#123; global_map_[<span class=\"keyword\">this</span>].reset(); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><h4 id=\"OutOfLine代码\"><a href=\"#OutOfLine代码\" class=\"headerlink\" title=\"OutOfLine代码\"></a><code>OutOfLine</code>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastData</span>, <span class=\"title\">class</span> <span class=\"title\">ColdData</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">OutOfLine</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;OutOfLine <span class=\"keyword\">const</span>*, <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">OutOfLine</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) :</span> OutOfLine(TwoPhaseInit()) &#123;</span><br><span class=\"line\">    init_cold_data(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~OutOfLine() &#123; global_map_.erase(<span class=\"keyword\">this</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine&amp;&amp; other)</span> : <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine::TwoPhaseInit())</span> </span>&#123; (*<span class=\"keyword\">this</span>) = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(other); &#125;</span><br><span class=\"line\">  OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class=\"line\">    global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(global_map_[&amp;other]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  OutOfLine(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">ColdData&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">  <span class=\"function\">ColdData <span class=\"keyword\">const</span>&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class=\"line\">  OutOfLine(TwoPhaseInit) &#123; global_map_.try_emplace(<span class=\"keyword\">this</span>); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">init_cold_data</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">    global_map_.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>)-&gt;second = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_cold_data</span><span class=\"params\">()</span> </span>&#123; global_map_[<span class=\"keyword\">this</span>].reset(); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"benchmark代码\"><a href=\"#benchmark代码\" class=\"headerlink\" title=\"benchmark代码\"></a>benchmark代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ --std=c++1z -Wall -Wextra -O3 -o ool_benchmark ool_benchmark.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"out_of_line.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Deomonstrates keeping the cold data in the object with the fast data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Together</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> metadata;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Demonstrates \"giving up\" and just not storing the associated cold-data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OnlyFastData</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Demonstrates using OutOfLine to store the cold data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WithOOL</span> :</span> <span class=\"keyword\">public</span> OutOfLine&lt;WithOOL, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The crux of the optimization is that there's no space-overhead</span></span><br><span class=\"line\"><span class=\"keyword\">static_assert</span>(<span class=\"keyword\">sizeof</span>(WithOOL) == <span class=\"keyword\">sizeof</span>(OnlyFastData));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We synthesize the data up-front so the generation can't interfere with the measured behavior in any way</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">auto</span> <span class=\"title\">make_data</span>() &#123;</span></span><br><span class=\"line\">  srand(<span class=\"number\">20180101</span>);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Data&gt; <span class=\"title\">data</span><span class=\"params\">(<span class=\"number\">10000000</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Data&amp; d : data) &#123; d.value = rand(); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We time to measure throughput of touching all the fast data once in sequence</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">trial</span>(<span class=\"title\">const</span> <span class=\"title\">char</span>* <span class=\"title\">const</span> <span class=\"title\">name</span>, <span class=\"title\">const</span> <span class=\"title\">Data</span>&amp; <span class=\"title\">data</span>, <span class=\"title\">const</span> <span class=\"title\">bool</span> <span class=\"title\">print</span>) &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> <span class=\"built_in\">running</span> = <span class=\"number\">0U</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> before = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; d : data) &#123; <span class=\"built_in\">running</span> += d.value; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> after = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">print</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\" took \"</span> &lt;&lt; (after - before).count() &lt;&lt; <span class=\"string\">\"ns and \"</span> &lt;&lt; <span class=\"built_in\">running</span></span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" is a value I don't want optimized away\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// We generate all the datasets up front, to keep the effects of the allocator distant</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> together  = make_data&lt;Together&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> only_fast = make_data&lt;OnlyFastData&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> with_ool  = make_data&lt;WithOOL&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// We run each trial twice, recording the results only the second time. The idea is to give a fair comparison, where</span></span><br><span class=\"line\">  <span class=\"comment\">// all 3 options have their caches primed and nobody thus has data fresher from the allocation.</span></span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data in-line (original)               \"</span>, together, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data in-line (original)               \"</span>, together, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data thrown away (best-case scenario) \"</span>, only_fast, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data thrown away (best-case scenario) \"</span>, only_fast, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trial(<span class=\"string\">\"With OutOfLIne                                  \"</span>, with_ool, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With OutOfLIne                                  \"</span>, with_ool, <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>注意map的<code>try_emplace</code>方法是C++17引入的新特性，编译命令如下：<code>g++ benchmark.cpp -o benchmark -std=c++17</code>。在我自己的笔记本上运行的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">With cold data in-line (original)                took 82936589ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class=\"line\">With cold data thrown away (best-case scenario)  took 74243139ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class=\"line\">With OutOfLIne                                   took 73445932ns and 3350498669 is a value I don&#39;t want optimized away</span><br></pre></td></tr></table></figure>\n<p>加速效果没有原始博客中的那么大，但付出的成本近乎免费，因此在性能优化时是很值得考虑的一个选项。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"OutOfLine模式提升C-代码访存局部性\"><a href=\"#OutOfLine模式提升C-代码访存局部性\" class=\"headerlink\" title=\"OutOfLine模式提升C++代码访存局部性\"></a>OutOfLine模式提升C++代码访存局部性</h1><p>公司内网看到一个提升C++代码性能的模式（源头是<a href=\"https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/\" target=\"_blank\" rel=\"noopener\">这篇blog</a>），能够以一种容易维护的方式很大程度提升访存的局部性，感觉挺有意思，记录一下。</p>\n<h2 id=\"从例子说起\"><a href=\"#从例子说起\" class=\"headerlink\" title=\"从例子说起\"></a>从例子说起</h2><p>假设你的系统需要打开大量的路径(文件、sockets，pipes)，对于这些路径你需要打开、处理、关闭对应的文件描述符并取消文件描述符和对应路径之间的联系。</p>\n<p>对于这样的需求，我们可能写出下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnlinkingFD</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> path;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\"></span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; p) : path(p) &#123;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(p.c_str(), O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~UnlinkingFD() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">close</span>(fd); </span><br><span class=\"line\">      unlink(path.c_str());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> UnlinkingFD&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个打开的路径对应一个上面的对象保存对应的路径和文件描述符，大量的打开的文件描述符可能以<code>UnlinkingFD</code>对象形式保存在数组中。上面的代码在功能和逻辑上是完好的，RAII也会在对象生命周期结束时关掉文件描述符并取消和对应路径之间的关联。</p>\n<h3 id=\"场景-amp-性能分析\"><a href=\"#场景-amp-性能分析\" class=\"headerlink\" title=\"场景&amp;性能分析\"></a>场景&amp;性能分析</h3><p>假设我们经常需要用到<code>fd</code>，但是<code>path</code>只在对象生命周期结束时使用。因为一个上面的<code>UnlinkingFD</code>对象需要占用40Bytes，而我们常用的<code>fd</code>只占用了其中的4Bytes，这意味着我们在访问<code>UnlinkingFD</code>数组时cache miss的概率大大提升。</p>\n<h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>将<code>array-of-structs</code>变为<code>struct-of-arrays</code>，这当然可以帮助提升性能，但是我们将无法使用RAII来帮我们做资源管理，单一的fd无法及时得到释放。</p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p><code>UnlinkingFD</code>对象中不直接保存<code>string</code>对象，而是使用一个<code>unique_ptr</code>指针。这样一个<code>UnlinkingFD</code>对象就从40Bytes降低到了16Bytes，降低了cache miss的概率。</p>\n<h3 id=\"方案3：OutOfLine模式\"><a href=\"#方案3：OutOfLine模式\" class=\"headerlink\" title=\"方案3：OutOfLine模式\"></a>方案3：OutOfLine模式</h3><p>OutOfLine模式可以帮我们将像<code>path</code>这样的冷数据完全移到对象之外，但是仍然保留RAII为我们管理资源。</p>\n<h4 id=\"OutOfLine用法\"><a href=\"#OutOfLine用法\" class=\"headerlink\" title=\"OutOfLine用法\"></a>OutOfLine用法</h4><p><code>OutOfLine</code>类是一个<a href=\"https://omnimilk.github.io/2020/07/01/expression-template/\" target=\"_blank\" rel=\"noopener\">静态多态</a>的基类。 使用此基类时要传入两个模板参数，第一个模板参数为继承的子类，第二个模板参数为要挂在“热”对象上的冷数据的类型。</p>\n<p>例如，对于上面的<code>UnlinkingFD</code>类，改写后的用法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UnlinkingFD</span> :</span> <span class=\"keyword\">private</span> OutOfLine&lt;UnlinkingFD, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\"></span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;(p) &#123;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(p.c_str(), O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~UnlinkingFD();</span><br><span class=\"line\">  UnlinkingFD(<span class=\"keyword\">const</span> UnlinkingFD&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>OutOfLine模式将冷数据从对象中剥离出去的思路时通过一个全局对象将“热”对象的指针和冷数据关联起来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastData</span>, <span class=\"title\">class</span> <span class=\"title\">ColdData</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">OutOfLine</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;OutOfLine <span class=\"keyword\">const</span>*, <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 每次创建“热”数据对象时，将热数据对象的指针关联到对应的冷数据上</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">explicit</span> <span class=\"title\">OutOfLine</span>(<span class=\"title\">TArgs</span>&amp;&amp;.. <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">        global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// “热”数据对象析构时，将全局映射中对应的冷数据对象也清理掉</span></span><br><span class=\"line\">    ~OutOfLine() &#123;global_map_.erase(<span class=\"keyword\">this</span>);&#125;</span><br><span class=\"line\">    <span class=\"comment\">// move “热”数据对象时，将对应的冷数据重新关联（此后不应该在通过旧的“热”数据对象来找冷数据）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine&amp;&amp; other)</span> </span>&#123; *<span class=\"keyword\">this</span> = other;&#125;</span><br><span class=\"line\">    OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class=\"line\">        global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(global_map_[&amp;other]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// non-copyable for simplicity</span></span><br><span class=\"line\">    OutOfLine(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前“热”对象对应的冷数据</span></span><br><span class=\"line\">    <span class=\"function\">ColdData&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">    <span class=\"function\">ColdData <span class=\"keyword\">const</span>&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"性能-amp-资源管理\"><a href=\"#性能-amp-资源管理\" class=\"headerlink\" title=\"性能&amp;资源管理\"></a>性能&amp;资源管理</h4><p>静态继承自<code>OutOfLine</code>类的<code>UnlinkingFD</code>现在只有4Bytes， 因此需要高频访问的<code>UnlinkingFD</code>对象的数组的cache miss被降到最低。同时RAII会同时替我们管理“热”数据对象及对应的冷数据。</p>\n<h4 id=\"NOTE-构造函数初始化顺序\"><a href=\"#NOTE-构造函数初始化顺序\" class=\"headerlink\" title=\"NOTE: 构造函数初始化顺序\"></a>NOTE: 构造函数初始化顺序</h4><p>上面静态继承的过程实际上一定程度上限定了热数据和冷数据构造的顺序，因为C++构造函数初始化的顺序如下：</p>\n<ol>\n<li>构造虚拟基类，继承自多个虚拟基类时，按照被继承的顺序构造</li>\n<li>构造非虚拟基类，继承自多个非虚拟基类时，按照被继承的顺序构造</li>\n<li>构造成员对象，按照成员对象的声明顺序构造</li>\n<li>调用类自身的构造函数</li>\n</ol>\n<p>因此，当我们构造一个“热”数据对象时，会首先构造<code>OutOfLine</code>基类（此时<code>OutOfLine</code>类的构造函数中会构造冷数据对象），然后构造“热”数据对象。这就意味着<strong><em>冷数据对象的构造不能依赖于“热”数据对象</em></strong>。</p>\n<h4 id=\"控制初始化顺序\"><a href=\"#控制初始化顺序\" class=\"headerlink\" title=\"控制初始化顺序\"></a>控制初始化顺序</h4><p>当冷数据对象的初始化依赖于热数据对象时，我们需要hack一下初始化的顺序。方法如下：为<code>OutOfLine</code>静态基类提供一个特别的构造函数，这个构造函数以tag类<code>TwoPhaseInit</code>为入参。当我们调用这个构造函数时，冷数据不会被初始化，此时处于一种半构造的状态。然后我们在“热”数据初始化之后显式的调用<code>init_cold_data</code>来初始化冷数据。释放时同理可以引入<code>release_cold_data</code>来hack析构的顺序。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class=\"line\">  OutOfLine(TwoPhaseInit)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">init_cold_data</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">    global_map_.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>)-&gt;second = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_cold_data</span><span class=\"params\">()</span> </span>&#123; global_map_[<span class=\"keyword\">this</span>].reset(); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><h4 id=\"OutOfLine代码\"><a href=\"#OutOfLine代码\" class=\"headerlink\" title=\"OutOfLine代码\"></a><code>OutOfLine</code>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastData</span>, <span class=\"title\">class</span> <span class=\"title\">ColdData</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">OutOfLine</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;OutOfLine <span class=\"keyword\">const</span>*, <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;ColdData&gt;&gt; global_map_;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">OutOfLine</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) :</span> OutOfLine(TwoPhaseInit()) &#123;</span><br><span class=\"line\">    init_cold_data(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~OutOfLine() &#123; global_map_.erase(<span class=\"keyword\">this</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine&amp;&amp; other)</span> : <span class=\"title\">OutOfLine</span><span class=\"params\">(OutOfLine::TwoPhaseInit())</span> </span>&#123; (*<span class=\"keyword\">this</span>) = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(other); &#125;</span><br><span class=\"line\">  OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine&amp;&amp; other) &#123;</span><br><span class=\"line\">    global_map_[<span class=\"keyword\">this</span>] = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(global_map_[&amp;other]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  OutOfLine(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  OutOfLine&amp; <span class=\"keyword\">operator</span>=(OutOfLine <span class=\"keyword\">const</span>&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">ColdData&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\">  <span class=\"function\">ColdData <span class=\"keyword\">const</span>&amp; <span class=\"title\">cold</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> *global_map_[<span class=\"keyword\">this</span>]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoPhaseInit</span> &#123;</span>&#125;;</span><br><span class=\"line\">  OutOfLine(TwoPhaseInit) &#123; global_map_.try_emplace(<span class=\"keyword\">this</span>); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span>... <span class=\"title\">TArgs</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">void</span> <span class=\"title\">init_cold_data</span>(<span class=\"title\">TArgs</span>&amp;&amp;... <span class=\"title\">args</span>) &#123;</span></span><br><span class=\"line\">    global_map_.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>)-&gt;second = <span class=\"built_in\">std</span>::make_unique&lt;ColdData&gt;(<span class=\"built_in\">std</span>::forward&lt;TArgs&gt;(args)...);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_cold_data</span><span class=\"params\">()</span> </span>&#123; global_map_[<span class=\"keyword\">this</span>].reset(); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"benchmark代码\"><a href=\"#benchmark代码\" class=\"headerlink\" title=\"benchmark代码\"></a>benchmark代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ --std=c++1z -Wall -Wextra -O3 -o ool_benchmark ool_benchmark.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"out_of_line.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Deomonstrates keeping the cold data in the object with the fast data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Together</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> metadata;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Demonstrates \"giving up\" and just not storing the associated cold-data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OnlyFastData</span> &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Demonstrates using OutOfLine to store the cold data</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WithOOL</span> :</span> <span class=\"keyword\">public</span> OutOfLine&lt;WithOOL, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The crux of the optimization is that there's no space-overhead</span></span><br><span class=\"line\"><span class=\"keyword\">static_assert</span>(<span class=\"keyword\">sizeof</span>(WithOOL) == <span class=\"keyword\">sizeof</span>(OnlyFastData));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We synthesize the data up-front so the generation can't interfere with the measured behavior in any way</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">auto</span> <span class=\"title\">make_data</span>() &#123;</span></span><br><span class=\"line\">  srand(<span class=\"number\">20180101</span>);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Data&gt; <span class=\"title\">data</span><span class=\"params\">(<span class=\"number\">10000000</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Data&amp; d : data) &#123; d.value = rand(); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We time to measure throughput of touching all the fast data once in sequence</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">trial</span>(<span class=\"title\">const</span> <span class=\"title\">char</span>* <span class=\"title\">const</span> <span class=\"title\">name</span>, <span class=\"title\">const</span> <span class=\"title\">Data</span>&amp; <span class=\"title\">data</span>, <span class=\"title\">const</span> <span class=\"title\">bool</span> <span class=\"title\">print</span>) &#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"keyword\">uint32_t</span> <span class=\"built_in\">running</span> = <span class=\"number\">0U</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> before = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; d : data) &#123; <span class=\"built_in\">running</span> += d.value; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> after = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">print</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\" took \"</span> &lt;&lt; (after - before).count() &lt;&lt; <span class=\"string\">\"ns and \"</span> &lt;&lt; <span class=\"built_in\">running</span></span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" is a value I don't want optimized away\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// We generate all the datasets up front, to keep the effects of the allocator distant</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> together  = make_data&lt;Together&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> only_fast = make_data&lt;OnlyFastData&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> with_ool  = make_data&lt;WithOOL&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// We run each trial twice, recording the results only the second time. The idea is to give a fair comparison, where</span></span><br><span class=\"line\">  <span class=\"comment\">// all 3 options have their caches primed and nobody thus has data fresher from the allocation.</span></span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data in-line (original)               \"</span>, together, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data in-line (original)               \"</span>, together, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data thrown away (best-case scenario) \"</span>, only_fast, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With cold data thrown away (best-case scenario) \"</span>, only_fast, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trial(<span class=\"string\">\"With OutOfLIne                                  \"</span>, with_ool, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  trial(<span class=\"string\">\"With OutOfLIne                                  \"</span>, with_ool, <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>注意map的<code>try_emplace</code>方法是C++17引入的新特性，编译命令如下：<code>g++ benchmark.cpp -o benchmark -std=c++17</code>。在我自己的笔记本上运行的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">With cold data in-line (original)                took 82936589ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class=\"line\">With cold data thrown away (best-case scenario)  took 74243139ns and 3350498669 is a value I don&#39;t want optimized away</span><br><span class=\"line\">With OutOfLIne                                   took 73445932ns and 3350498669 is a value I don&#39;t want optimized away</span><br></pre></td></tr></table></figure>\n<p>加速效果没有原始博客中的那么大，但付出的成本近乎免费，因此在性能优化时是很值得考虑的一个选项。</p>\n"},{"title":"two-list system","date":"2020-08-23T12:09:15.000Z","_content":"\n# 注意力分配：Two-List System\n\n对于我这种容易分心的人，有限的精力很容易被看起来有趣的事情骗走。但是要做一只卓有成效的社畜，有长远的目标并为之专注是必须的。最近看到一个巴菲特的目标管理方式，感觉很有启发，记录并用起来。\n\n故事最原始的出处没有查证，[随手找了一个版本](https://hacpai.com/article/1534498720955)。大意是，我们都有很多的目标，花时间将其中对我们来说最重要的整理出来是很值得的。首先，我们可以整理出对我们最重要的25个目标。但我们精力有限，显然不可能同时追求这些目标，可以再从这25个目标中选出对我们来说最重要的5个形成一个短名单。\n\n对于这样两个目标列表的使用容易陷入一个误区：优先追求对我们最重要的5个目标，剩下的20个目标放于次要的优先级，等我们有空再去花精力。但是巴菲特告诉我们，我们要尽力避免在剩下的20个目标上花任何精力。因为正是这些次要目标才是最容易让我们分心浪费掉精力的，因为他们会给我们错误的激励（那些我们完全不感兴趣的目标反而不会）。\n\n知易行难，小目标理起来～","source":"_posts/two-list-system.md","raw":"---\ntitle: two-list system\ndate: 2020-08-23 20:09:15\ntags: mind-hack\n---\n\n# 注意力分配：Two-List System\n\n对于我这种容易分心的人，有限的精力很容易被看起来有趣的事情骗走。但是要做一只卓有成效的社畜，有长远的目标并为之专注是必须的。最近看到一个巴菲特的目标管理方式，感觉很有启发，记录并用起来。\n\n故事最原始的出处没有查证，[随手找了一个版本](https://hacpai.com/article/1534498720955)。大意是，我们都有很多的目标，花时间将其中对我们来说最重要的整理出来是很值得的。首先，我们可以整理出对我们最重要的25个目标。但我们精力有限，显然不可能同时追求这些目标，可以再从这25个目标中选出对我们来说最重要的5个形成一个短名单。\n\n对于这样两个目标列表的使用容易陷入一个误区：优先追求对我们最重要的5个目标，剩下的20个目标放于次要的优先级，等我们有空再去花精力。但是巴菲特告诉我们，我们要尽力避免在剩下的20个目标上花任何精力。因为正是这些次要目标才是最容易让我们分心浪费掉精力的，因为他们会给我们错误的激励（那些我们完全不感兴趣的目标反而不会）。\n\n知易行难，小目标理起来～","slug":"two-list-system","published":1,"updated":"2020-08-23T12:25:00.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke72e6ac0000t3794pc6fg4o","content":"<h1 id=\"注意力分配：Two-List-System\"><a href=\"#注意力分配：Two-List-System\" class=\"headerlink\" title=\"注意力分配：Two-List System\"></a>注意力分配：Two-List System</h1><p>对于我这种容易分心的人，有限的精力很容易被看起来有趣的事情骗走。但是要做一只卓有成效的社畜，有长远的目标并为之专注是必须的。最近看到一个巴菲特的目标管理方式，感觉很有启发，记录并用起来。</p>\n<p>故事最原始的出处没有查证，<a href=\"https://hacpai.com/article/1534498720955\" target=\"_blank\" rel=\"noopener\">随手找了一个版本</a>。大意是，我们都有很多的目标，花时间将其中对我们来说最重要的整理出来是很值得的。首先，我们可以整理出对我们最重要的25个目标。但我们精力有限，显然不可能同时追求这些目标，可以再从这25个目标中选出对我们来说最重要的5个形成一个短名单。</p>\n<p>对于这样两个目标列表的使用容易陷入一个误区：优先追求对我们最重要的5个目标，剩下的20个目标放于次要的优先级，等我们有空再去花精力。但是巴菲特告诉我们，我们要尽力避免在剩下的20个目标上花任何精力。因为正是这些次要目标才是最容易让我们分心浪费掉精力的，因为他们会给我们错误的激励（那些我们完全不感兴趣的目标反而不会）。</p>\n<p>知易行难，小目标理起来～</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注意力分配：Two-List-System\"><a href=\"#注意力分配：Two-List-System\" class=\"headerlink\" title=\"注意力分配：Two-List System\"></a>注意力分配：Two-List System</h1><p>对于我这种容易分心的人，有限的精力很容易被看起来有趣的事情骗走。但是要做一只卓有成效的社畜，有长远的目标并为之专注是必须的。最近看到一个巴菲特的目标管理方式，感觉很有启发，记录并用起来。</p>\n<p>故事最原始的出处没有查证，<a href=\"https://hacpai.com/article/1534498720955\" target=\"_blank\" rel=\"noopener\">随手找了一个版本</a>。大意是，我们都有很多的目标，花时间将其中对我们来说最重要的整理出来是很值得的。首先，我们可以整理出对我们最重要的25个目标。但我们精力有限，显然不可能同时追求这些目标，可以再从这25个目标中选出对我们来说最重要的5个形成一个短名单。</p>\n<p>对于这样两个目标列表的使用容易陷入一个误区：优先追求对我们最重要的5个目标，剩下的20个目标放于次要的优先级，等我们有空再去花精力。但是巴菲特告诉我们，我们要尽力避免在剩下的20个目标上花任何精力。因为正是这些次要目标才是最容易让我们分心浪费掉精力的，因为他们会给我们错误的激励（那些我们完全不感兴趣的目标反而不会）。</p>\n<p>知易行难，小目标理起来～</p>\n"},{"layout":"posts","title":"LLVM0","date":"2020-09-07T02:29:44.000Z","_content":"\n# LLVM学习笔记0：安装\n\n算是重拾LLVM，这次重头记录学习历程。\n\n## 安装\n\n安装比较简单，`apt-get`直接安装即可：\n\n```shell\nsudo apt-get install clang\nsudo apt-get install llvm\n```\n\n## 测试安装\n\n使用LLVM CookBook里的一个小例子验证安装是否成功。\n\ndemo code:\n\n```\ndefine i32 @test1(i32 %A) {\n    %B = add i32 %A, 0\n    ret i32 %B\n}\n\ndefine internal i32 @test(i32 %X, i32 %dead) {\n    ret i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123, i32 456)\n    ret i32 %A\n}\n```\n\n1. 将上述LLVM代码输入到`testfile.ll`\n2. 运行`opt`工具中指令合并的pass：`opt -S -instcombine testfile.ll -o output1.ll`\n3. 运行死代码消除pass：`opt -S -deadargelim testfile.ll -o output2.ll`\n\n我们容易通过查看上面运行pass后的输出代码确认pass已生效：\n\n`output1.ll`：\n\n```\n; ModuleID = 'tesetfile.ll'\n\ndefine i32 @test1(i32 %A) {\n    ret i32 %A  ; eliminated adding 0\n}\n\ndefine internal i32 @test(i32 %X, i32 %dead) {\n    return i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123, i32 456)\n    ret i32 %A\n}\n```\n\n`output2.ll`：\n\n```\n; ModuleID = 'testfile.ll'\n\ndefine i32 @test1(i32 %A) {\n    %B = add i32 %A, 0\n    ret i32 %B\n}\n\ndefine internal i32 @test(i32 %X) { ; eliminated dead arg\n    ret i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123) ; elminated dead arg\n    ret i32 %A\n}\n```\n\n","source":"_posts/LLVM0.md","raw":"---\nlayout: posts\ntitle: LLVM0\ndate: 2020-09-07 10:29:44\ntags: LLVM, compiler\n---\n\n# LLVM学习笔记0：安装\n\n算是重拾LLVM，这次重头记录学习历程。\n\n## 安装\n\n安装比较简单，`apt-get`直接安装即可：\n\n```shell\nsudo apt-get install clang\nsudo apt-get install llvm\n```\n\n## 测试安装\n\n使用LLVM CookBook里的一个小例子验证安装是否成功。\n\ndemo code:\n\n```\ndefine i32 @test1(i32 %A) {\n    %B = add i32 %A, 0\n    ret i32 %B\n}\n\ndefine internal i32 @test(i32 %X, i32 %dead) {\n    ret i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123, i32 456)\n    ret i32 %A\n}\n```\n\n1. 将上述LLVM代码输入到`testfile.ll`\n2. 运行`opt`工具中指令合并的pass：`opt -S -instcombine testfile.ll -o output1.ll`\n3. 运行死代码消除pass：`opt -S -deadargelim testfile.ll -o output2.ll`\n\n我们容易通过查看上面运行pass后的输出代码确认pass已生效：\n\n`output1.ll`：\n\n```\n; ModuleID = 'tesetfile.ll'\n\ndefine i32 @test1(i32 %A) {\n    ret i32 %A  ; eliminated adding 0\n}\n\ndefine internal i32 @test(i32 %X, i32 %dead) {\n    return i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123, i32 456)\n    ret i32 %A\n}\n```\n\n`output2.ll`：\n\n```\n; ModuleID = 'testfile.ll'\n\ndefine i32 @test1(i32 %A) {\n    %B = add i32 %A, 0\n    ret i32 %B\n}\n\ndefine internal i32 @test(i32 %X) { ; eliminated dead arg\n    ret i32 %X\n}\n\ndefine i32 @caller() {\n    %A = call i32 @test(i32 123) ; elminated dead arg\n    ret i32 %A\n}\n```\n\n","slug":"LLVM0","published":1,"updated":"2020-09-07T07:15:18.258Z","_id":"ckes6o93a00009079gvsa4wbj","comments":1,"photos":[],"link":"","content":"<h1 id=\"LLVM学习笔记0：安装\"><a href=\"#LLVM学习笔记0：安装\" class=\"headerlink\" title=\"LLVM学习笔记0：安装\"></a>LLVM学习笔记0：安装</h1><p>算是重拾LLVM，这次重头记录学习历程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装比较简单，<code>apt-get</code>直接安装即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install clang</span><br><span class=\"line\">sudo apt-get install llvm</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试安装\"><a href=\"#测试安装\" class=\"headerlink\" title=\"测试安装\"></a>测试安装</h2><p>使用LLVM CookBook里的一个小例子验证安装是否成功。</p>\n<p>demo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    %B &#x3D; add i32 %A, 0</span><br><span class=\"line\">    ret i32 %B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class=\"line\">    ret i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将上述LLVM代码输入到<code>testfile.ll</code></li>\n<li>运行<code>opt</code>工具中指令合并的pass：<code>opt -S -instcombine testfile.ll -o output1.ll</code></li>\n<li>运行死代码消除pass：<code>opt -S -deadargelim testfile.ll -o output2.ll</code></li>\n</ol>\n<p>我们容易通过查看上面运行pass后的输出代码确认pass已生效：</p>\n<p><code>output1.ll</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; ModuleID &#x3D; &#39;tesetfile.ll&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    ret i32 %A  ; eliminated adding 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class=\"line\">    return i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>output2.ll</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; ModuleID &#x3D; &#39;testfile.ll&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    %B &#x3D; add i32 %A, 0</span><br><span class=\"line\">    ret i32 %B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X) &#123; ; eliminated dead arg</span><br><span class=\"line\">    ret i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123) ; elminated dead arg</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"LLVM学习笔记0：安装\"><a href=\"#LLVM学习笔记0：安装\" class=\"headerlink\" title=\"LLVM学习笔记0：安装\"></a>LLVM学习笔记0：安装</h1><p>算是重拾LLVM，这次重头记录学习历程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装比较简单，<code>apt-get</code>直接安装即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install clang</span><br><span class=\"line\">sudo apt-get install llvm</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试安装\"><a href=\"#测试安装\" class=\"headerlink\" title=\"测试安装\"></a>测试安装</h2><p>使用LLVM CookBook里的一个小例子验证安装是否成功。</p>\n<p>demo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    %B &#x3D; add i32 %A, 0</span><br><span class=\"line\">    ret i32 %B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class=\"line\">    ret i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将上述LLVM代码输入到<code>testfile.ll</code></li>\n<li>运行<code>opt</code>工具中指令合并的pass：<code>opt -S -instcombine testfile.ll -o output1.ll</code></li>\n<li>运行死代码消除pass：<code>opt -S -deadargelim testfile.ll -o output2.ll</code></li>\n</ol>\n<p>我们容易通过查看上面运行pass后的输出代码确认pass已生效：</p>\n<p><code>output1.ll</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; ModuleID &#x3D; &#39;tesetfile.ll&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    ret i32 %A  ; eliminated adding 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X, i32 %dead) &#123;</span><br><span class=\"line\">    return i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123, i32 456)</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>output2.ll</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; ModuleID &#x3D; &#39;testfile.ll&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @test1(i32 %A) &#123;</span><br><span class=\"line\">    %B &#x3D; add i32 %A, 0</span><br><span class=\"line\">    ret i32 %B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define internal i32 @test(i32 %X) &#123; ; eliminated dead arg</span><br><span class=\"line\">    ret i32 %X</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">define i32 @caller() &#123;</span><br><span class=\"line\">    %A &#x3D; call i32 @test(i32 123) ; elminated dead arg</span><br><span class=\"line\">    ret i32 %A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"posts","title":"Taichi0","date":"2020-08-31T08:26:51.000Z","_content":"\n# Taichi学习\n\n占个坑，定个无ddl小目标：做个小青蛙。","source":"_posts/Taichi0.md","raw":"---\nlayout: posts\ntitle: Taichi0\ndate: 2020-08-31 16:26:51\ntags: 太极, rendering\n---\n\n# Taichi学习\n\n占个坑，定个无ddl小目标：做个小青蛙。","slug":"Taichi0","published":1,"updated":"2020-09-07T02:29:23.232Z","comments":1,"photos":[],"link":"","_id":"ckes6o93f000190792zwzherk","content":"<h1 id=\"Taichi学习\"><a href=\"#Taichi学习\" class=\"headerlink\" title=\"Taichi学习\"></a>Taichi学习</h1><p>占个坑，定个无ddl小目标：做个小青蛙。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Taichi学习\"><a href=\"#Taichi学习\" class=\"headerlink\" title=\"Taichi学习\"></a>Taichi学习</h1><p>占个坑，定个无ddl小目标：做个小青蛙。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckcbb9uco0005ys1d8i39bbjv","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcbb9ucs000dys1ddlj57hmy"},{"post_id":"ckcbb9uch0000ys1dhtq89m63","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcbb9ucu000iys1d8shfenii"},{"post_id":"ckcbb9ucl0001ys1df2db6hs0","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcbb9ucu000kys1d74d7g2z1"},{"post_id":"ckcbb9uco0004ys1dbqpog38p","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcbb9ucv000nys1d6lr9ft0i"},{"post_id":"ckcbb9ucp0006ys1d39py6uhg","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckcbb9ucw000sys1dg2t1ggp3"},{"post_id":"ckcbb9ucs000cys1d6rvned7p","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckcbb9ucw000vys1d65zy9b30"},{"post_id":"ckcbb9uct000hys1df0rjd77e","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckcbb9ucw000xys1dge8l8k0v"},{"post_id":"ckcbb9ud4000yys1d2plc2s6p","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckcbb9ud60010ys1d9ekzgcub"},{"post_id":"ckcd5lqko0000k41dbcun7nx5","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcd5lqkv0002k41d0x0kfffn"},{"post_id":"ckcugunuv00003s79coth05ko","category_id":"ckcbb9ucm0002ys1dhihe1ujk","_id":"ckcugunv400023s79dalnhued"},{"post_id":"ckd3zdaqx00000d79hxtz43ip","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckd3zdar200020d799grq7pxz"},{"post_id":"ckd4gbd630000yz792p1w7hk5","category_id":"ckcbb9ucu000jys1d7w05fhto","_id":"ckd4gbd680002yz79gi6vbgjt"}],"PostTag":[{"post_id":"ckcbb9uco0005ys1d8i39bbjv","tag_id":"ckcbb9ucn0003ys1d8ypu5vyq","_id":"ckcbb9ucr0009ys1daopkb8op"},{"post_id":"ckcbb9uch0000ys1dhtq89m63","tag_id":"ckcbb9ucn0003ys1d8ypu5vyq","_id":"ckcbb9ucs000bys1d067s8diz"},{"post_id":"ckcbb9ucl0001ys1df2db6hs0","tag_id":"ckcbb9ucn0003ys1d8ypu5vyq","_id":"ckcbb9uct000gys1dai910x77"},{"post_id":"ckcbb9uco0004ys1dbqpog38p","tag_id":"ckcbb9ucn0003ys1d8ypu5vyq","_id":"ckcbb9ucv000mys1d5hcsg2ec"},{"post_id":"ckcbb9ucp0006ys1d39py6uhg","tag_id":"ckcbb9ucu000lys1d344q2noe","_id":"ckcbb9ucv000qys1dfsg3ge5q"},{"post_id":"ckcbb9ucs000cys1d6rvned7p","tag_id":"ckcbb9ucv000pys1d7cju7f3k","_id":"ckcbb9ucw000uys1dabz55nw8"},{"post_id":"ckcbb9uct000hys1df0rjd77e","tag_id":"ckcbb9ucv000pys1d7cju7f3k","_id":"ckcbb9ucw000wys1d0unxfamp"},{"post_id":"ckcbb9ud4000yys1d2plc2s6p","tag_id":"ckcbb9ucv000pys1d7cju7f3k","_id":"ckcbb9ud6000zys1dh0nvflqt"},{"post_id":"ckcd5lqko0000k41dbcun7nx5","tag_id":"ckcbb9ucn0003ys1d8ypu5vyq","_id":"ckcd5lqkv0001k41ddkdi2r6b"},{"post_id":"ckcugunuv00003s79coth05ko","tag_id":"ckcugunv100013s790qbw4bqv","_id":"ckcugunv400033s79db9ebrpt"},{"post_id":"ckd2kgi660000c67975gd8ml8","tag_id":"ckd2kgi6c0001c6790uh8djjx","_id":"ckd2kgi6f0002c679culi64n4"},{"post_id":"ckd3zdaqx00000d79hxtz43ip","tag_id":"ckcbb9ucu000lys1d344q2noe","_id":"ckd3zdar200010d7991okdh0d"},{"post_id":"ckd4gbd630000yz792p1w7hk5","tag_id":"ckcbb9ucu000lys1d344q2noe","_id":"ckd4gbd680001yz79ac5lf7nw"},{"post_id":"ckdtmyesc00003a79f8it7f7l","tag_id":"ckdtmyesh00013a79b7ck3hwa","_id":"ckdtmyesn00023a79440ofvpt"},{"post_id":"cke71smb80000eq79clr7hvia","tag_id":"cke71smbf0001eq79a4mh5org","_id":"cke71smbi0002eq796fek33zr"},{"post_id":"cke72e6ac0000t3794pc6fg4o","tag_id":"cke72e6ag0001t3798rx804us","_id":"cke72e6ak0002t3793ysrf3dy"},{"post_id":"ckes6o93a00009079gvsa4wbj","tag_id":"ckes6o93g00029079e4xg0klo","_id":"ckes6o93k00049079equzejyi"},{"post_id":"ckes6o93f000190792zwzherk","tag_id":"ckes6o93k000390790fgfdqjl","_id":"ckes6o93k000590798vtq5wtt"}],"Tag":[{"name":"SNN, Deep Learning","_id":"ckcbb9ucn0003ys1d8ypu5vyq"},{"name":"pybind11, c++, python","_id":"ckcbb9ucu000lys1d344q2noe"},{"name":"c++","_id":"ckcbb9ucv000pys1d7cju7f3k"},{"name":"TensorFlow, Deep Learning","_id":"ckcugunv100013s790qbw4bqv"},{"name":"Mood","_id":"ckd2kgi6c0001c6790uh8djjx"},{"name":"Mindspore, Python, Optimizer, C++","_id":"ckdtmyesh00013a79b7ck3hwa"},{"name":"Performance, C++","_id":"cke71smbf0001eq79a4mh5org"},{"name":"mind-hack","_id":"cke72e6ag0001t3798rx804us"},{"name":"LLVM, compiler","_id":"ckes6o93g00029079e4xg0klo"},{"name":"太极, rendering","_id":"ckes6o93k000390790fgfdqjl"}]}}